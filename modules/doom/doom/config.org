#+TITLE: My Doom Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: showall

* Enable lexical binding for Emacs Lisp

#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src

* Quickly jumping to this Doom Emacs configuration

I /very often/ jump into /this/ file to quickly tweak things. So let's make this
even more convenient than the default binding =SPC f P=.

#+begin_src emacs-lisp
(defun my/open-init-file ()
  "Open my config.org file."
  (interactive)
  (find-file (concat doom-user-dir "config.org")))

(map! :leader :desc "Open config" :n "e" #'my/open-init-file)
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.

One thing to pay attention to is that nearly all those operations on "visuals"
work slightly differently when starting Emacs as =emacsclient=, for instance via

#+begin_src shell :tangle no
emacsclient -a ''
#+end_src

Setting some things at this point often results in the changes not being applied
correctly. It's due to them happening in a technical, invisible Emacs frame. So
you'll often see =(daemonp)= being called, checking whether this instance of Emacs
is using the daemon, then adding some initializer function to
=server-after-make-frame-hook= if it is.

** Add an SVG splash screen image

An awesome source for ELisp bits and Doom/Emacs configuration is [[https://tecosaur.github.io/emacs-config/config.html][tecosaur's Doom
Emacs configuration]]. That's where I got the splash screen from and I love this
crisp Emacs =E=.

#+begin_src emacs-lisp
(setq fancy-splash-image (concat doom-private-dir "splash.svg"))
#+end_src

FIXME: add MIT license to dotfiles in order to use the splash screen

** Don't highlight the current line

Vanilla Emacs does not enable =hl-line-mode= (which always highlights the line the
point is currently on), but Doom does. I don't like it, so let's turn it off
again.

#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook #'global-hl-line-mode)
#+end_src

** Cursor

The default cursor is black, which interferes with mostly using a dark theme.
Brighten it up a bit.

#+begin_src emacs-lisp
(set-mouse-color "white")
#+end_src

Enable a forever-blinking cursor. I used to disable this mode but I found myself
searching for the cursor a couple of times lately.

#+begin_src emacs-lisp
(setq blink-cursor-delay 0.5)
(setq blink-cursor-blinks -1)
(blink-cursor-mode 1)
#+end_src

Don't show a cursor in inactive windows.

#+begin_src emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

** Fonts

An alist of my preferred font families, together with a plist of certain
attributes that need to be applied when switching to the respective font.

FIXME: Respect custom properties defined here

#+begin_src emacs-lisp
(defcustom my/fonts nil
  "A list of custom font definitions. Each font definition is a plist,
usually created by a call to `my/define-font'.")

(cl-defun my/define-font (family &key default-height org-height weight)
  "Add a font definition for FAMILY."
  (add-to-list
   'my/fonts
   (list
    :family family
    :default-height (or default-height 180)
    :org-height (or org-height 0.9)
    :weight (or weight 'regular))))

(defun my/get-font (family)
  "Get the font definition for FAMILY."
  (seq-find
   (lambda (f)
     (string=
      (plist-get f :family)
      family))
   my/fonts))

(my/define-font "Pragmata Pro Mono")
(my/define-font "MxPlus IBM VGA 8x14" :default-height 200)
(my/define-font "MxPlus IBM VGA 9x16" :default-height 200)
(my/define-font "Mx437 DOS/V TWN16" :default-height 200)
(my/define-font "Iosevka Term")
(my/define-font "Iosevka Comfy")
(my/define-font "DejaVu Sans Mono")
(my/define-font "IBM Plex Mono")
(my/define-font "Cascadia Code")
(my/define-font "Source Code Pro")
(my/define-font "Consolas")
(my/define-font "Fira Code" :org-height 0.8)
(my/define-font "JetBrains Mono" :org-height 0.8)
(my/define-font "Julia Mono")
(my/define-font "Courier Prime" :org-height 0.95)
(my/define-font "Fantasque Sans Mono")
(my/define-font "Lucida Console")
(my/define-font "Inconsolata")
(my/define-font "Unifont" :default-height 200)
(my/define-font "Geist Mono")
(my/define-font "Berkeley Mono")
(my/define-font "Ubuntu Sans Mono")
(my/define-font "Fixedsys Excelsior 3.01")
(my/define-font "PT Mono")
#+end_src

#+begin_src emacs-lisp
(setq my/current-font-family "JetBrains Mono")
(setq doom-font
      (apply #'font-spec
             (plist-put
              (my/get-font my/current-font-family)
              :size 23)))
#+end_src

The default text scaling increment produces jumps in font size that are way too
big for me. Let's tune it down a bit.

#+begin_src emacs-lisp
(setq doom-font-increment 1)
#+end_src

When streaming or just showing something to colleagues at work, there's no need
to manually zoom due to =doom-big-font-mode= now! I don't specify a different
font; =doom-big-font-increment= then controls how much the current font size is
increased.

#+begin_src emacs-lisp
(setq doom-big-font-increment 10)
#+end_src

The function I use to switch between the various fonts I like. It applies the
attributes of its value in =my/fonts=.

#+begin_src emacs-lisp
(defun my/switch-font (family)
  "Apply the attributes stored for FAMILY in `my/fonts."
  (interactive
   (list
    (completing-read
     "Font: "
     (seq-remove
      (lambda (f) (string= f my/current-font-family))
      (mapcar (lambda (f) (plist-get f :family))
              my/fonts)))))
  (let* ((size (font-get doom-font :size))
         (attrs (plist-put (my/get-font family) :size size)))
    (setq my/current-font-family family)
    (setq doom-font (apply #'font-spec attrs))
    (doom/reload-font)))
#+end_src

Since I prefer to use the built-in ~C-h~ bindings for /help/ commands I'll happily
replace ~SPC f~.

#+begin_src emacs-lisp
(map! :leader :g "h f" #'my/switch-font)
#+end_src

*** Changing the font size

FIXME: fix resetting of the font after ~SPC z r~

#+begin_src emacs-lisp
(defun my/set-font-size (size)
  "Set the font size of the current font to a fixed value SIZE."
  (interactive "nFont size: ")
  (doom-adjust-font-size size t))

(setq my/font-resize-map
      (define-keymap
        (kbd "g") #'doom/increase-font-size
        (kbd "l") #'doom/decrease-font-size
        (kbd "r") #'doom/reset-font-size))

(defhydra hydra-global-zoom (:hint nil :timeout 3)
  "\n
  [_g_]: [+]     [_s_]: set
  [_l_]: [-]     [_r_]: reset\n
  "
  ("g" doom/increase-font-size)
  ("l" doom/decrease-font-size)
  ("r" doom/reset-font-size)
  ("s" my/set-font-size :color blue)
  ("q" nil "exit"))

(map! :leader :desc "Font zoom" :g "z" #'hydra-global-zoom/body)
#+end_src

** Color theme(s)
*** Favorite themes

Since I cannot ever decide which theme I like best, there are a few themes, or
theme collections, loaded here.

**** Custom theme: =naga=

I usually use [[https://github.com/kenranunderscore/emacs-naga-theme][my own /naga/ theme]]. It can be found on MELPA nowadays, though it's
still only "finished" for the parts I really use. Should there be enough
interest, I could style some more parts, but it's not anything I plan on doing
for now.

This theme is loaded directly from GitHub via [[file:packages.el][packages.el]], but I have to see
whether this suffices for quick iteration. I don't know what the workflow is
going to look like yet.

FIXME: how to configure this now? some options don't seem to be respected, like
the red cursor

#+begin_src emacs-lisp
(use-package! naga-theme
  :defer
  :init
  (setq naga-theme-modeline-style 'green-box)
  (setq naga-theme-use-red-cursor t)
  (setq naga-theme-surround-org-blocks t)
  (setq naga-theme-use-lighter-org-block-background t))
#+end_src

**** Modus themes

[[https://protesilaos.com/emacs/modus-themes][This package]] by Protesilaos Stavrou is my first choice of "external" themes. I
find myself going back to =modus-vivendi= in the evening, even though I keep
saying that I don't like that high of a contrast.

These two themes are very customizable and come with the most comprehensive and
extensive documentation (same as with basically anything that Prot makes
available).

#+begin_src emacs-lisp
(use-package! modus-themes
  :defer
  :config
  (setq modus-themes-subtle-line-numbers t)
  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs nil)
  (setq modus-themes-syntax '(green-strings alt-syntax))
  (setq modus-themes-prompts '(background bold))
  (setq modus-themes-mode-line nil)
  (setq modus-themes-completions
        '((matches . (intense background))
          (selection . (intense accented))
          (popup . (intense accented))))
  (setq modus-themes-fringes nil)
  (setq modus-themes-paren-match '(bold intense))
  (setq modus-themes-region '(accented bg-only))
  ;; TODO: org agenda, mail citations
  (setq modus-themes-org-blocks nil))
#+end_src

**** Gruber darker

Whenever you want or need to channel your inner [[https://twitch.tv/tsoding][Tsoding]], switch to Iosevka and
turn on:

#+begin_src emacs-lisp
(use-package! gruber-darker-theme
  :defer)
#+end_src

**** Srcery

I discovered this package by accident, while randomly selecting themes to try
out via =straight-use-package=.

#+begin_src emacs-lisp
(use-package! srcery-theme
  :defer)
#+end_src

**** Spacemacs themes

For nostalgic reasons I like to pretend I'm using Spacemacs from time to time.

#+begin_src emacs-lisp
(use-package! spacemacs-theme
  :defer)
#+end_src

**** =base16= themes

#+begin_src emacs-lisp
(use-package! base16-theme
  :defer)
#+end_src

**** Default theme

Doom comes with the =doom-themes= package which contains lots of great themes
(even though in some themes I dislike the low contrast between the mode line and
buffers). Let's use one of those for now until everything else is up and
running. =Gruvbox= is always a good choice, anywhere.

#+begin_src emacs-lisp
(setq doom-theme 'base16-gruvbox-dark-hard)
#+end_src

** Mode line (TODO: port and conditionalize with =featurep!=)

FIXME: flycheck

#+begin_src emacs-lisp
(defmacro my/with-active-face (face)
  "Return FACE if we're in the mode line of the active window, and
the `mode-line-inactive' face otherwise."
  `(if (mode-line-window-selected-p)
       ,face
     'mode-line-inactive))

(defcustom my/evil-state-mode-line-format
  '(:eval
    (let ((fg (face-attribute 'default :foreground))
          (bg (face-attribute 'default :background))
          (error-fg (face-attribute 'error :foreground)))
      (cond
       ((eq evil-state 'insert)
        (propertize
         " INSERT "
         'face
         (my/with-active-face `(:foreground ,bg :background ,error-fg))))
       ((eq evil-state 'normal)
        (propertize
         " NORMAL "
         'face
         (my/with-active-face `(:foreground ,bg :background ,fg))))
       ((eq evil-state 'motion)
        (propertize
         " MOTION "
         'face
         (my/with-active-face `(:foreground ,bg :background ,fg))))
       ((eq evil-state 'visual)
        (propertize
         " VISUAL "
         'face
         (my/with-active-face `(:foreground ,bg :background ,(face-attribute 'font-lock-function-name-face :foreground)))))
       ((eq evil-state 'emacs)
        (propertize
         " EMACS "
         'face
         (my/with-active-face `(:foreground ,bg :background ,(face-attribute 'font-lock-keyword-face :foreground)))))
       (t "        "))))
  "Specifies how to display the current `evil-state' in the mode
line."
  :risky t)

(defun my/visible-minor-modes ()
  "Return `minor-mode-alist', but with certain modes I don't want to
see filtered out."
  (let ((hidden-modes
         '(
           abbrev-mode
           auto-fill-function
           auto-revert-mode
           better-jumper-mode
           better-jumper-local-mode
           buffer-face-mode
           company-box-mode
           company-mode
           dot-mode
           editorconfig-mode
           eldoc-mode
           evil-collection-unimpaired-mode
           evil-commentary-mode
           evil-escape-mode
           evil-org-mode
           evil-snipe-mode
           evil-snipe-local-mode
           flymake-mode
           gcmh-mode
           global-company-mode
           lsp-lens-mode
           org-indent-mode
           projectile-mode
           visual-line-mode
           which-key-mode
           ws-butler-global-mode
           ws-butler-mode
           yas-minor-mode)))
    (seq-difference minor-mode-alist
                    hidden-modes
                    (lambda (hidden cell)
                      (eq (car cell)
                          hidden)))))

(defcustom my/minor-modes-mode-line-format
  '(:eval
    (let ((s (format-mode-line (my/visible-minor-modes))))
      (if (string-empty-p s) ""
        (concat "(" (substring s 1) ")"))))
  "How to display the active minor modes in the mode line."
  :risky t)

(defcustom my/mode-line-compilation-format
  '(compilation-in-progress
    (:eval (propertize
            "   [Compiling...]"
            'face
            (my/with-active-face compilation-mode-line-run))))
  "How to display the indicator for a running compilation process in
the mode line."
  :risky t)

(defcustom my/major-mode-mode-line-format
  '("" (:eval (string-replace "-mode" "" (symbol-name major-mode))))
  "How to display the active major mode in the mode line."
  :risky t)

(setq-default
 mode-line-format
 '(""
   my/evil-state-mode-line-format
   ;; my/mode-line-flymake-format
   my/mode-line-compilation-format
   (:propertize "   %b" face mode-line-buffer-id)
   ;; Always show current line and column, without checking `column-number-mode'
   ;; and `line-number-mode'
   ("   L%l C%c")
   ("   " my/major-mode-mode-line-format)
   ("   " my/minor-modes-mode-line-format)))
#+end_src

* Basic options
** Use a POSIX-compliant shell for processes started via Emacs

#+begin_src emacs-lisp
(setq shell-file-name (executable-find "bash"))
#+end_src

** Use =SPC SPC= as an alias for =M-x=

Doom by default sets =SPC SPC= to =projective-find-file=, which I am used to
invoking via =SPC p f= (that's also bound by default).

I'd like to get used to just pressing =M-x= for extended commands, but =SPC SPC= is
ingrained in my muscle memory. Remapping it for when I "accidentally" press it
seems like a good idea.

#+begin_src emacs-lisp
(map! :leader :desc "M-x" :nmv "SPC" #'execute-extended-command)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode. Note: this doesn't
work correctly yet, as =(command-modes 'some-command)= seems to return the modes
in an unexpected format.

#+begin_src emacs-lisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

To display line numbers, the aptly named =display-line-numbers= package is used. I
prefer a hybrid mode for displaying line numbers. That is, line numbers are
shown in a relative way, but the current line displays its absolute line number.
In insert mode, line numbers should be disabled altogether. That's what these
two functions are used for.

#+begin_src emacs-lisp
(defun my/switch-to-absolute-line-numbers ()
  "Enable absolute line numbers."
  (interactive)
  (when (bound-and-true-p display-line-numbers-mode)
    (setq display-line-numbers t)))

(defun my/switch-to-hybrid-line-numbers ()
  "Enable relative line numbers, but with the current line
showing its absolute line number."
  (interactive)
  (when (bound-and-true-p display-line-numbers-mode)
    (setq display-line-numbers 'relative)
    (setq display-line-numbers-current-absolute t)))

(defun my/toggle-line-numbers ()
  "Toggle `display-line-numbers-mode'.  Meant to be used in a
keybinding."
  (interactive)
  (display-line-numbers-mode 'toggle))

(use-package! display-line-numbers
  :defer
  :init
  (remove-hook!
    '(prog-mode-hook text-mode-hook conf-mode-hook)
    #'display-line-numbers-mode)
  :hook ((evil-insert-state-entry . my/switch-to-absolute-line-numbers)
         (evil-insert-state-exit . my/switch-to-hybrid-line-numbers))
  :config
  (setq display-line-numbers-type 'relative)
  (setq display-line-numbers-current-absolute t)
  (map! :leader :desc "Line numbers" :nmv "t l" #'my/toggle-line-numbers))
#+end_src

** If I have to use tabs, at least make them smaller

Looking at you, [[https://go.dev/][Go]].

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

** File name searches should be case-insensitive

#+begin_src emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+end_src

** Yank (paste) at point with the mouse

The default Emacs behavior when yanking (in the Emacs sense of the word) things
from the clipboard by clicking the middle mouse button is to insert those at the
mouse cursor position. I wish to be able to carelessly click anywhere and have
it insert at point, similar to how it's done in most terminal emulators.

Of course there's an existing Emacs options for this:

#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

** Breaking long lines

When writing prose I often use =auto-fill-mode= to automatically break long lines.
Emacs uses the =fill-column= variable to determine when to break. Its default of
70 is a little low for my taste, though.

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

** Don't require two spaces to end sentences

Controversial, I know, but I've gotten used to it in Doom (where it's the
default) and actually like not having to change my typing flow depending on the
context anymore.

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

** Automatically scroll compilation output

Emacs' =M-x compile= command (and =M-x project-compile=, which I use much more
often) create a new buffer that contains the compilation output. This buffer
does not automatically follow the output if it reaches the bottom of the first
page, so let's change that.

#+begin_src emacs-lisp
(setq compilation-scroll-output t)
#+end_src

* Vim emulation with =evil=

The =evil= package offers a very complete Vim experience inside of Emacs. Most of
the configuration is done by Doom already, so I only need to slightly tweak some
things to my liking.

#+begin_src emacs-lisp
(setq doom-localleader-key ",")
(after! evil
  ;; Use a special cursor for insert mode
  (setq evil-insert-state-cursor 'box)
  ;; Don't make certain commands repeatable with '.'
  (mapc #'evil-declare-ignore-repeat
        '(haskell-process-load-file
          haskell-process-reload
          haskell-goto-first-error
          haskell-goto-next-error
          haskell-goto-prev-error
          hydra-haskell-error-navigation/body
          my/haskell-add-import
          my/haskell-add-ghc-option
          my/haskell-add-language-extension))
  (add-to-list 'evil-emacs-state-modes 'sieve-manage-mode)
  ;; U for `redo' is easier to type than C-r for me
  (map! :desc "Redo" :n "U" #'evil-redo
        :map evil-window-map
        :g "C-d" #'evil-window-delete))
#+end_src

* Window management
** Interactive window switching

The =ace-window= package comes with Doom's =window-select= module. I need a couple
of customizations due to using the alternative keyboard layout MTGAP; I'm also
used to my =C-l= rebind to more comfortably switch than =C-w C-w=.

#+begin_src emacs-lisp
(use-package! ace-window
  :defer
  :init
  (map! :desc "Switch window" :inmve "C-l" #'ace-window)
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5)
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r)))
#+end_src

* Built-in packages with extensions
** Emacs Lisp
*** Evaluating with =C-c C-c=

I like evaluating the top-level form I'm currently on by pressing =C-c C-c=,
similar to how one compiles in SLY/SLIME.

FIXME: this destroys the nice bindings in =org-src= buffers.  fix possible?

#+begin_src emacs-lisp :tangle no
(map! :map emacs-lisp-mode-map
      :desc "Eval defun" :g "C-c C-c" #'eval-defun)
#+end_src

*** Don't trim ELisp evaluation results

#+begin_src emacs-lisp
(setq eval-expression-print-length nil)
(setq eval-expression-print-level nil)
#+end_src

** Display whitespace

Make whitespace symbols visible using =whitespace-mode=. I don't use this often
anymore, but sometimes it's helpful.

#+begin_src emacs-lisp
(use-package! whitespace
  :defer
  :config
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode
              org-mode))
  (setq whitespace-style
        '(face newline newline-mark missing-newline-at-eof
               trailing empty tabs tab-mark))
  (setq whitespace-display-mappings
        '((newline-mark 10
                        [9166 10])
          (tab-mark 9
                    [187 9]
                    [92 9]))))
#+end_src

** Render manpages in Emacs

#+begin_src emacs-lisp
(after! man
  ;; As soon as it is ready open the manpage in a separate, focused window.
  (setq Man-notify-method 'aggressive))
#+end_src

** Directory editor: =dired=

#+begin_src emacs-lisp
(after! dired
  (setq dired-kill-when-opening-new-dired-buffer t))
#+end_src

** Ediff

=Ediff= is a great way to diff and/or merge files or buffers. By default it
creates a new frame containing a "control buffer" used to navigate the diff and
manipulate the output. Unfortunately for the longest time this behaved weirdly
for me: whenever I'd tab to the frame containing the diff, do something, then
tab back, the next navigational command from the control frame would work but
drop me back in the diff frame. It's possible to use =ediff-setup-windows-plain=
as setup function, which makes =ediff= single-frame, circumventing the problem.

#+begin_src emacs-lisp
(after! ediff-wind
  (setq ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

** Disabling =smartparens=

I don't use or need =smartparens=. If I want auto-closing parentheses then
=electric-pair-mode= is great, and for LISPy languages there's =lispy-mode= and
=lispyville-mode=.

#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook #'smartparens-global-mode)
#+end_src

** Correct typos while typing with =abbrev=

=Abbrev-mode= is a nice built-in minor mode that silently replaces some things I
type with other things. It is mostly used for correcting typos, though I haven't
really "trained" my self-made list of abbrevs -- I've just started using it.

Since it doesn't come with a global mode itself, I use =setq-default= to enable
it everywhere.

#+begin_src emacs-lisp
(use-package! emacs
  :init
  (setq-default abbrev-mode t)
  :config
  (setq save-abbrevs nil
        abbrev-file-name (locate-user-emacs-file "abbrev_defs")))
#+end_src

* Incremental narrowing etc.
** =Vertico=

Doom does it well out of the box. I should probably look into configuring =embark=
here later on, maybe to even obsolete =which-key=.

*** =Consult=

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite some
time, though not in any extent close to full. This only defines some basic
bindings that Doom doesn't use by default.

#+begin_src emacs-lisp
(map! :g "M-g o" #'consult-outline)
#+end_src

*** =Embark=

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet. It seems to be amazing, though! What I
mostly use it for at the moment is its =embark-act= command in conjunction with
=embark-export=. With this I often push the results of some =grep=-like command into
a separate buffer, where I can then utilize =wgrep= to bulk-modify the original
buffers.

* TODO Jumping around with =avy=
* TODO Org mode
** Tweaks to the default configuration

When writing text with =org=, =auto-fill-mode= should be enabled to automatically
break overly long lines into smaller pieces when typing. One may still use =M-q=
to re-fill paragraphs when editing text. After loading =org=, a custom font setup
might run to adjust the headers.

#+begin_src emacs-lisp
(use-package! org
  :hook
  ((org-mode . auto-fill-mode))
  :custom
  ((org-directory "~/org")
   (org-startup-indented t)
   (org-log-done t)
   (org-edit-src-content-indentation 0)
   (org-agenda-files '("~/org/inbox.org"))
   (org-html-htmlize-output-type 'css))
  :config
  (setq-default org-hide-emphasis-markers t)
  (advice-add 'org-refile
              :after (lambda (&rest _) (org-save-all-org-buffers))))
#+end_src

** Giving org a more modern look&feel

Minad's [[https://github.com/minad/org-modern][org-modern package]] looks very promising, so let's try it out.

#+begin_src emacs-lisp
(use-package! org-modern
  :hook
  (org-mode . org-modern-mode)
  :config
  (setq org-modern-star '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-modern-block-name '((t . t)
                                ("src" "»" "«")
                                ("example" "»–" "–«")
                                ("quote" "❝" "❞")
                                ("export" "⏩" "⏪"))))
#+end_src

** Show emphasis markers depending on point

In my =org= configuration I'm setting =org-hide-emphasis-markers= to =t=, thus hiding
certain markup elements around text. Unfortunately it seem to be currently
impossible to switch this interactively, or I just don't know how, which
prevents me from simply adding a keybinding to toggle it.

Thankfully a new package has appeared recently: [[https://github.com/awth13/org-appear][org-appear]]. It reacts to the
position of point to automatically show surrounding markup.

#+begin_src emacs-lisp
(use-package! org-appear
  :defer
  :hook ((org-mode . org-appear-mode))
  :config
  (setq org-appear-autolinks t
        org-appear-autosubmarkers t
        org-appear-autoentities t
        org-appear-autokeywords t
        org-appear-trigger 'always))
#+end_src

* On-the-fly syntax checking (and other things): =Flymake=

#+begin_src emacs-lisp
(after! flymake
  ;; HACK: This variable is needed for helpful or haskell-mode to start up for
  ;; some reason
  (setq flymake-allowed-file-name-masks nil))

(add-hook! sh-mode #'flymake-mode)
#+end_src

* Full terminal inside Emacs: =vterm=

The Doom defaults for =vterm=, and also the way how it is handled and used as a
quick-use popup, are great. The only small accommodation I have to make is to
specify the interactive shell I'd like to use explicitly, as I've configured
=shell-file-name= to point to a POSIX-compliant shell (=bash=).

#+begin_src emacs-lisp
(after! vterm
  (setq-default vterm-shell (executable-find "fish")))
#+end_src

** Static analysis of shell scripts

[[https://github.com/koalaman/shellcheck][ShellCheck]] is a great little program providing feedback when writing shell
scripts. The Emacs package [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]] integrates ShellCheck with
Flymake. We have to trigger =flymake-shellcheck-load= when loading shell scripts,
and also enable Flymake itself, both done via hooks to =sh-mode=.

#+begin_src emacs-lisp :tangle no
(use-package! flymake-shellcheck
  :commands (flymake-shellcheck-load)
  :hook ((sh-mode . flymake-shellcheck-load)
         (sh-mode . flymake-mode)))
#+end_src

* E-mail configuration

There are several different ways to "do e-mail in Emacs". Over the last two
years I've tried out =notmuch=, =gnus=, and =mu4e=. Some thoughts on each of those:

** Notmuch

The Emacs integration for =notmuch= is great; it has the most intuitive and
appealing UI from each of the options. =Notmuch= works by referencing incoming
e-mail in a separate database only, not ever touching or modifying it. I really
like this idea, and in practice it also felt great due to the quick und
customizable searches. The usual approach is to use a tag-based system of
categorizing your e-mail, but simply having lots of stored queries is a little
bit more flexible.

But =notmuch= only handles this single aspect; this means that one needs to find
solutions to the following:

- Getting mail
- Initial tagging
- Sending mail
- Synchronization between machines

Due to the declarative e-mail account configuration from =home-manager= the first
part is very simple, and I could also easily switch between different tools like
=isync= or =offlineimap=. For sending mail I use =msmtp=.

*** =muchsync=

Using =muchsync= looks great on paper but is very finicky with sent mail, which
I'd also like to sync back via IMAP to my accounts. The client machine sends
this and puts it into respective =sent= directories; =muchsync= synchronizes these
directories as well, but I've had problems with mails appearing twice, or not
appearing at all on the respective "other" machine, at least in the past. It
looks or feels like my usage of =muchsync --nonew= on the clients was a potential
problem: I've verified that after sending a mail and it having landed in the
correct =sent= directory, a simple =muchsync my-server= didn't lead to the mail
appearing on my servers. It worked after executing =notmuch new= once, though, so
I guess =muchsync= only synchronizes those mails that are part of the current
=notmuch= database state.

One solution would be to make sure that whenever I'm polling from within Emacs,
both =muchsync my-server= and =notmuch new= are executed. Since =notmuch= has
deprecated the =notmuch-poll-script= variable in their Emacs client, I have to use
the hooks it provides to make sure =muchsync= is executed. Putting =muchsync
--nonew= into the =preNew= hook while having an unsynchronized sent mail on the
client sounds correct on paper in order to not execute =notmuch new= twice, but it
means that in the case of an unsynchronized sent mail, this mail won't have been
pushed to the server after the first call, if I am correct. So I'll have to
experiment and probably live with =notmuch new= being called twice (which is fine
as it's blazingly fast).

I've never managed to get it quite right, and debugging misbehavior has been a
nightmare as I cannot reliably reproduce it. So when trying out =notmuch= once
more, I'll do so without any tagging at all, utilizing saved queries only.

Let's first define some utility functions that I'll then bind to special keys
later.

*** Configuration

Now pull in and configure the actual =notmuch= package. Note that some options
rather belong to built-in functionality, but they fit here very well.

#+begin_src emacs-lisp
(setq user-mail-address "johannes.maier@mailbox.org")

(after! notmuch
  ;; msmtp is registered as sendmail
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq message-kill-buffer-on-exit t)
  ;; When replying to mail, choose the account to use based on the recipient
  ;; address
  (setq message-sendmail-envelope-from 'header)
  (setq mail-envelope-from 'header)
  (setq mail-user-agent 'message-user-agent)
  ;; Settings for notmuch itself
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-hello-sections
        '(notmuch-hello-insert-header
          notmuch-hello-insert-saved-searches
          notmuch-hello-insert-footer))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-archive-tags nil)
  (setq notmuch-fcc-dirs
        '(("johannes.maier@mailbox.org" . "mailbox/Sent")
          ("johannes.maier@active-group.de" . "ag/Sent")
          (".*" . "sent")))
  (setq notmuch-saved-searches
        '((:name "work inbox"
           :query "folder:ag/Inbox"
           :key "w"
           :search-type tree)
          (:name "sent"
           :query "folder:ag/Sent or folder:mailbox/Sent"
           :key "s"
           :search-type tree)
          (:name "private inbox"
           :query "folder:mailbox/Inbox"
           :key "p"
           :search-type tree)
          (:name "work archive"
           :query "path:ag/Archives/**"
           :search-type tree)
          (:name "private archive"
           :query "path:mailbox/Archive/**"
           :search-type tree)))
  (map!
   :map notmuch-show-mode-map
   :desc "Archive" :n "a" #'my/notmuch-archive
   :desc "Delete" :n "d" #'my/notmuch-delete
   :map notmuch-tree-mode-map
   :desc "Archive" :n "a" #'my/notmuch-archive
   :desc "Delete" :n "d" #'my/notmuch-delete
   :map notmuch-hello-mode-map
   :desc "Search (tree)" :n "s" #'notmuch-tree))
#+end_src

In order to be able to use =notmuch= again, I need to rely on saved searches only
in a way that I get the same state from a clean maildir sync on each machine. So
let's circumvent the whole idea of =notmuch= and /actually touch/ our mail to
archive, delete, etc. We don't actually delete things, just move them from
maildir to maildir, which requires some small hacks to refresh the notmuch
buffers.

#+begin_src emacs-lisp
(defun my/notmuch-get-source-file ()
  "Get the source file for the currently hovered email."
  (car
   (cond
    ((equal major-mode #'notmuch-tree-mode)
     (notmuch-tree-get-prop :filename))
    ((equal major-mode #'notmuch-show-mode)
     (notmuch-show-get-prop :filename))
    ((equal major-mode #'notmuch-search-mode)
     (warn "FIXME: Not implemented for `notmuch-search-mode'!"))
    (warn "cannot find source file for mail"))))

(defun my/notmuch-new-without-hooks ()
  "Execute 'notmuch new --no-hooks', circumventing the automatic polling
notmuch does in its preNew hook, yielding quicker refreshes."
  (interactive)
  (if (equal major-mode #'notmuch-tree-mode)
      (notmuch-call-notmuch-process "new" "--no-hooks")))

(defun my/notmuch-move-into-maildir (email maildir)
  "Move EMAIL (that is, the corresponding file) into MAILDIR."
  (let* ((parts (split-string (file-truename email) ":"))
         (target-file (concat
                       maildir
                       "/cur/"
                       (org-id-uuid)
                       (when-let (rest (cadr parts))
                         (format ":%s" rest)))))
    (message "[+email] moving %s to %s" email target-file)
    (rename-file email target-file)
    (let ((line (line-number-at-pos)))
      (my/notmuch-new-without-hooks)
      (add-hook 'notmuch-tree-process-exit-functions
                (defun my/notmuch-restore-point (proc)
                  (goto-line line)
                  (remove-hook 'notmuch-tree-process-exit-functions #'my/notmuch-restore-point)))
      (notmuch-refresh-this-buffer))))

(defun my/is-work-email (email)
  "Determine whether a given EMAIL belongs to my work account."
  (string-match "/ag/" (file-name-directory email)))

(defun my/notmuch-archive ()
  "Archive the current email."
  (interactive)
  (let* ((email (my/notmuch-get-source-file))
         (archive-year (caddr (calendar-current-date)))
         ;; TODO: get maildir location from system configuration
         (archive-dir (if (my/is-work-email email)
                          (format "~/.mail/ag/Archives/%s" archive-year)
                        (format "~/.mail/mailbox/Archive/%s" archive-year))))
    (my/notmuch-move-into-maildir email archive-dir)))

(defun my/notmuch-unarchive ()
  "Unarchive the current email."
  (interactive)
  (let* ((email (my/notmuch-get-source-file))
         (maildir (if (my/is-work-email email)
                      "~/.mail/ag/Inbox"
                    "~/.mail/mailbox/Inbox")))
    (my/notmuch-move-into-maildir email maildir)))

(defun my/notmuch-delete ()
  "Delete the current email (by moving it into the trash)."
  (interactive)
  (let ((email (my/notmuch-get-source-file)))
    (my/notmuch-move-into-maildir
     email
     (if (my/is-work-email email)
         "~/.mail/ag/Trash"
       "~/.mail/mailbox/Trash"))))
#+end_src
=Gnus-alias= makes it possible to use different identities when composing mail. I
mostly use it to make sure that replies to a mail are sent from the address I've
received it at.

#+begin_src emacs-lisp
(use-package gnus-alias
  :defer t
  :config
  (setq gnus-alias-identity-alist
        `(("mailbox"
           nil
           "Johannes Maier <johannes.maier@mailbox.org>"
           nil
           nil
           nil
           nil)
          ("ag"
           nil
           "Johannes Maier <johannes.maier@active-group.de>"
           "Active Group GmbH"
           nil
           nil
           ,(concat
             "Johannes Maier\n"
             "johannes.maier@active-group.de\n\n"
             "+49 (7071) 70896-67\n\n"
             "Active Group GmbH\n"
             "Hechinger Str. 12/1\n"
             "72072 Tübingen\n"
             "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
             "Geschäftsführer: Dr. Michael Sperber"))))
  (setq gnus-alias-default-identity "mailbox")
  (setq gnus-alias-identity-rules
        '(("ag" ("any" "@active-group.de" both) "ag")))
  :hook
  (message-setup . gnus-alias-determine-identity))
#+end_src

** Mu for Emacs (=mu4e=)

[[https://www.djcbsoftware.nl/code/mu/][Mu]] is what I was using for the longest period of time, with =mu4e= being its Emacs
frontend. It's not as customizable as =notmuch=, but part of its charm is that I
don't need to sync anything between my machines, at the cost of =mu= touching my
e-mail (adding custom headers I believe). I don't mind this at all, and I can
use =isync= and =msmtp= to receive and send mail on any host.

For writing e-mails =mu4e= uses =message-mode= like the other tools. This sets the
=user-full-name= variable to fill in my name.

#+begin_src emacs-lisp :tangle no
(setq user-full-name "Johannes Maier")
#+end_src

Usually there's one /context/ (see =mu4e-contexts=) for each of my e-mail addresses,
and switching between them I may set some context-specific variables, or even
change the =mu4e= UI accordingly. The Doom Emacs =mu4e= module hides this variable
behind a nicer interface. I don't yet know whether everything still works as
intended, but let's give it a try.

#+begin_src emacs-lisp :tangle no
(after! mu4e
  (setq message-send-mail-function #'message-send-mail-with-sendmail
        message-kill-buffer-on-exit t
        send-mail-function #'message-send-mail-with-sendmail
        message-sendmail-envelope-from 'header
        mail-envelope-from 'header
        mail-specify-envelope-from 'header
        +mu4e-backend 'mbsync
        mu4e-drafts-folder "/drafts"
        mu4e-completing-read-function #'completing-read
        mu4e-confirm-quit nil
        mu4e-change-filenames-when-moving t
        mu4e-attachment-dir "~/Downloads/"
        mu4e-context-policy 'pick-first
        mu4e-compose-context-policy 'ask
        mu4e-headers-results-limit -1
        mu4e-search-results-limit -1
        mu4e-search-skip-duplicates nil
        mu4e-headers-skip-duplicates nil
        mu4e-headers-fields '((:human-date . 12)
                              (:flags . 6)
                              (:maildir . 15)
                              (:mailing-list . 10)
                              (:from . 22)
                              (:subject))
        mu4e-bookmarks '((:name "AG inbox" :query "maildir:/ag/Inbox" :key ?a)
                         (:name "Mailbox inbox" :query "maildir:/mailbox/Inbox" :key ?m)
                         (:name "Unread messages" :query "flag:unread AND NOT flag:trashed" :key ?u)
                         (:name "Sent" :query "maildir:/ag/Sent OR maildir:/mailbox/Sent" :key ?s)))
  (set-email-account!
   "mailbox"
   '((user-mail-address . "johannes.maier@mailbox.org")
     (mu4e-sent-folder . "/mailbox/Sent")
     (mu4e-trash-folder . "/mailbox/Trash")
     (mu4e-compose-signature . nil)
     (mu4e-refile-folder . (lambda (msg)
                             (let* ((date (mu4e-message-field-at-point :date))
                                    (year (decoded-time-year (decode-time date))))
                               (concat "/mailbox/Archive/"
                                       (number-to-string year))))))
   t)
  (set-email-account!
   "ag"
   `((user-mail-address . "johannes.maier@active-group.de")
     (mu4e-sent-folder . "/ag/Sent")
     (mu4e-trash-folder . "/ag/Trash")
     (mu4e-compose-signature . ,(concat
                                 "Johannes Maier\n"
                                 "johannes.maier@active-group.de\n\n"
                                 "+49 (7071) 70896-67\n\n"
                                 "Active Group GmbH\n"
                                 "Hechinger Str. 12/1\n"
                                 "72072 Tübingen\n"
                                 "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                                 "Geschäftsführer: Dr. Michael Sperber"))
     (mu4e-refile-folder . (lambda (msg)
                             (let* ((date (mu4e-message-field-at-point :date))
                                    (year (decoded-time-year (decode-time date))))
                               (concat "/ag/Archives/"
                                       (number-to-string year))))))
   t))
#+end_src

I also want to use a slightly wider =fill-column= in e-mails.

#+begin_src emacs-lisp :tangle no
(setq-hook! mml-mode fill-column 80)
#+end_src

=Mu4e= buffers are recognized as popups by Doom, so the initial buffer opens up
very small at the bottom of the frame; subsequent buffers do the same. Now that
it's easier to handle popups, I'm not entirely certain what kind of behavior I'd
like to have, but let's try some things out:

#+begin_src emacs-lisp :tangle no
(set-popup-rule! "^\\*mu4e"
  :ignore t)
#+end_src

*** Warn/confirm when trying to send with empty subject

=mu4e= uses the built-in =message-mode= for composing mail. In order to receive a
warning or yes/no question whenever I try sending without having specified a
subject header, I have to hook into this.

#+begin_src emacs-lisp
(defun my/confirm-empty-mail-subject ()
  "Check whether the subject header of the current message is empty,
and abort in this case (https://emacs.stackexchange.com/a/41176)."
  (or (message-field-value "Subject")
      (y-or-n-p "Really send without subject? ")
      (keyboard-quit)))

(add-hook 'message-send-mail-hook #'my/confirm-empty-mail-subject)
#+end_src

** Gnus

As I've written before, I've never given the mighty =gnus= the trial it deserves.
Getting into this package is really quite scary, for lack of a better word. The
reason is that =gnus= defines abstractions over "news", where the word nowadays
can incorporate everything from feeds, reddit, usenet, email, etc. The result is
that one has to learn lots of specialized and often confusing terminology before
being able to use =gnus= (especially for email). Due to the length and
comprehensiveness of the manual the learning curve is quite steep.

Plus, I feel like you cannot "just start using =gnus=" and get used to it, whereas
that is an actual path to succees in something like =mu4e=, for instance. With
=gnus= there's a lot of configuration to be done before even being able to do
anything.

I'm not sure yet what I will have to sync between machines; the automatically
created =.newsrc.eld= file is the most likely candidate. It seems like that the
path to this file can (only?) be configured by setting the path to the /startup
file/, meaning the newsreader-agnostic =.newsrc= file -- that I'm not actually
using, as I will only be using =gnus=.

#+begin_src emacs-lisp
(use-package! gnus
  :disabled
  :init
  (setq gnus-directory "~/.gnus/")
  (setq gnus-home-directory "~/.gnus/")
  (setq gnus-startup-file "~/org/newsrc")
  (setq gnus-init-file (locate-user-emacs-file "gnus.el"))
  :config
  (setq user-full-name "Johannes Maier")
  (setq user-mail-address "johannes.maier@mailbox.org")
  (setq message-directory "~/.gnus")
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq send-mail-function 'message-send-mail-with-sendmail)
  (setq message-sendmail-envelope-from 'header)
  (setq mail-envelope-from 'header)
  (setq mail-specify-envelope-from 'header)
  (setq gnus-check-new-newsgroups t)
  (setq gnus-gcc-mark-as-read t)
  (setq nnml-directory "~/.gnus")
  (setq gnus-interactive-exit t)
  (setq gnus-asynchronous t)
  (setq gnus-use-article-prefetch 15)
  (setq gnus-select-method '(nnnil ""))
  (setq gnus-secondary-select-methods
        '((nntp "news.gwene.org")
          (nnimap "ag"
                  (nnimap-address "imap.active-group.de")
                  (nnimap-server-port 993)
                  (nnimap-stream ssl)
                  (nnimap-inbox "INBOX"))
          (nnimap "mailbox"
                  (nnimap-address "imap.mailbox.org")
                  (nnimap-server-port 993)
                  (nnimap-stream ssl)
                  (nnimap-inbox "INBOX")))))
#+end_src

* IRC with =circe=

TODO: docs

#+begin_src emacs-lisp
(after! circe
  (set-irc-server! "irc.libera.chat"
    `(:tls t
      :port 6697
      :nick "kenran"
      :tls-keylist ,(let ((cert-dir (getenv "KENRAN_IRC_CERTS")))
                      `((,(concat cert-dir "/kenran.key")
                         ,(concat cert-dir "/kenran.crt"))))
      :channels ("#emacs"
                 "#nyxt"
                 "#systemcrafters"
                 "#org-mode"
                 "#haskell"
                 "#nim"
                 "#notmuch"
                 "#zig"
                 "#crawl"
                 "#guix"
                 "#commonlisp"
                 "#lisp"
                 "#herrhotzenplotz"))))
#+end_src

* TODO Project management

#+begin_src emacs-lisp
(setq projectile-project-search-path '("~/projects" "~/ag" "~/tmpdev"))
(setq projectile-enable-caching nil)
#+end_src

* =Magit=

Not much to say here: =magit= is awesome and in my top 3 reasons why I can't ever
switch to any editor that doesn't have anything remotely comparable. I've tried
=vim-fugitive= and =neogit= for (neo)vim, and while they're great, I still missed
=magit=.

Once again, the default Doom configuration already does most of what I
previously did (and more), like:

- Setting a smaller =fill-column= for commit messages
- Opening commit message buffers in insert mode
- Adding a transient =autostash= flag
- Making windows/popups behave etc.

#+begin_src emacs-lisp
(after! magit
  (map! :leader
        :desc "Magit status here" :nvm "g g" #'magit-status-here
        :desc "Magit status" :nvm "g G" #'magit-status)
  (setq git-commit-summary-max-length 68))
#+end_src

** Interactively browse =git= history

The =git-timemachine= plugin lets me go back and forth in a file's history.

#+begin_src emacs-lisp
(map! :leader
      :desc "Git timemachine" :nvm "g t" #'git-timemachine)
#+end_src

* TODO Modal LISP editing with =lispy= and =lispyville=
* Discovering keybindings with =which-key=

When pressing the first key in a hotkey chain, =which-key= displays a popup
showing the possible completions and associated functions. I stopped using this
for my custom Emacs configuration as I had gotten used to all my own
keybindings. With Doom that's a different story, and discovery has become
important once again, because why not leech off of someone else's keybinding
work :)

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.2)
#+end_src

** TODO check out =embark-prefix-help-command=
* Programming languages
** Haskell
*** Insert language extensions and GHC options

A couple of Emacs Lisp functions that help me make quick changes to Haskell
files (adding pragmas, language extensions, GHC options). =Haskell-mode= has some
similar functionality built-in, but I've never been happy with it.

#+begin_src emacs-lisp
(defun my/make-pragma (pragma content)
  "Create a pragma line of type `pragma' containing `content'."
  (concat "{-# " pragma " " content " #-}\n"))

(defun my/haskell-add-language-extension (ext-name)
  "Add an extension from the list of available language extensions
to the top of the file."
  (interactive
   (list
    (completing-read
     "Extension: "
     haskell-ghc-supported-extensions)))
  (let ((pragma (my/make-pragma "LANGUAGE" ext-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun my/haskell-add-ghc-option (opt-name)
  "Add a GHC option from the list of options to the top of the
file."
  (interactive
   (list
    (completing-read
     "GHC option: "
     haskell-ghc-supported-options)))
  (let ((pragma (my/make-pragma "OPTIONS_GHC" opt-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))
#+end_src

*** Insert imports

This function is the one is use by far the most. It makes it somewhat easy to
add =import= statements to Haskell files. It's surely not perfect, but fits my
preferences well; that is, I almost never use the combinations that are harder
to add with this template. For instance, adding a qualified import with import
list, or an unqualified one with an alias, would require "tricks".

#+begin_src emacs-lisp
(defun my/read-non-empty-string (prompt &optional initial-input)
  "Read a string from the minibuffer.  When the result is the empty
string, return nil instead."
  (let ((str (read-string prompt initial-input)))
    (unless (string-empty-p str)
      str)))

(defun my/haskell-add-import (arg module &optional qualified? alias)
  "Add an import to the import list.  When no prefix ARG is set, the
user will be prompted whether the import should be qualified, and
what the identifier should be in that case."
  (interactive
   (let* ((arg current-prefix-arg)
          (module (read-string "Module: "))
          (qualified?
           (unless (or arg (string-match-p "(" module))
             (y-or-n-p (concat "Import " module " qualified?"))))
          (default-alias
           (last (split-string module "[\.]" t)))
          (alias (when qualified?
                   (my/read-non-empty-string "Alias: " default-alias))))
     (list arg module qualified? alias)))
  (let ((import-line
         (concat "import "
                 module
                 (when qualified? " qualified")
                 (when (and alias
                            (not (string= alias module)))
                   (concat " as " alias))
                 "\n")))
    (save-excursion
      (haskell-navigate-imports-go)
      (insert import-line))))
#+end_src

*** Templates

While I'm using =yasnippet= for templates in Emacs, some things are just a tad bit
too complex to handle in a template language, and much easier to do in ELisp.
These go here.

**** Newtypes

In Haskell, =newtype= is a mechanism I use all the time. These are different (but
not all) scenarios that need to be possible to output with a utility command:

#+begin_src haskell :tangle no
newtype Foo = Foo Int
newtype Foo a = Foo (IO a)
newtype Foo = Foo { unFoo :: Int } -- the default
newtype Foo = SomeCtor { unFoo :: Int }
newtype Foo = SomeCtor { custom :: Int }
newtype Foo a = SomeCtor { unFoo :: ReaderT Config IO a }
-- etc.
#+end_src

The following rather complicated command /should/ handle all the cases above. I
rarely use it, as quickly typing out a short ~newtype~ is usually sufficient. It
/is/ helpful for longer type names, though.

#+begin_src emacs-lisp
(defun my/haskell-newtype-template (arg name ctor accessor type)
  "Create a Haskell newtype declaration.  This will ask you for the
type NAME, the inner TYPE, and optionally for constructor and
accessor name.  If called with a non-nil prefix ARG then it won't
create and accessor and omit the curly braces."
  (interactive
   (let* ((arg current-prefix-arg)
          (name (my/read-non-empty-string "Name: "))
          (ctor (or (my/read-non-empty-string
                     (concat "Constructor [default " name "]: "))
                    name))
          (accessor-def (concat "un" name))
          (accessor (unless arg
                      (or (my/read-non-empty-string
                           (concat "Accessor [default " accessor-def "]: "))
                          accessor-def)))
          (type (my/read-non-empty-string "Inner type: ")))
     (list arg name ctor accessor type)))
  (let* ((type-parts
          (mapcar (lambda (s)
                    (replace-regexp-in-string "[\\(\\)]" "" s))
                  (split-string type split-string-default-separators t)))
         (type-param (seq-find (lambda (s)
                                 (let ((c (string-to-char s)))
                                   (equal c (downcase c))))
                               type-parts))
         (lhs (if type-param
                  (concat name " " type-param)
                name))
         (final-type (if (and arg
                              type-param
                              (> (seq-length type-parts) 1)) ; need parens around type
                         (concat "(" type ")")
                       type))
         (content (if accessor
                      (concat "{ " accessor " :: " final-type " }")
                    final-type)))
    (insert
     (concat "newtype " lhs " = " ctor " " content "\n"))))
#+end_src

*** Navigating errors

As always, =hydra= is highly capable of simplifying all sorts of navigational sets
of commands.

#+begin_src emacs-lisp
(defhydra hydra-haskell-error-navigation (:hint nil)
  "\n
  Navigate Haskell compilation errors\n
  [_f_]: first   [_n_]: next   [_p_]: previous"
  ("f" haskell-goto-first-error)
  ("n" haskell-goto-next-error)
  ("p" haskell-goto-prev-error))
#+end_src

*** Formatting

Several formatters are in use in different Haskell projects, like =fourmolu=,
=ormolu=, =brittany= and several more. =Haskell-mode= comes with builtin integration
for =stylish-haskell=, which often works for other formatters but is sometimes a
little flaky. =Reformatter= is a better solution, as I can define modes for
different formatters here and then use =eval= in =.dir-locals.el= on a per-project
basis to enable the fitting mode there.

**** Fourmolu

#+begin_src emacs-lisp
(after! haskell-mode
  (reformatter-define my/fourmolu-format
    :program "fourmolu"
    :args (list "--stdin-input-file" (or (buffer-file-name) input-file))
    :lighter " my/fourmolu"))
#+end_src

**** Cabal files

#+begin_src emacs-lisp
(after! haskell-mode
  (reformatter-define my/cabal-fmt-format
    :program "cabal-fmt"
    :args (list "-i" input-file)
    :stdin nil
    :stdout nil
    :lighter " my/cabal-fmt")
  (map! :map haskell-cabal-mode-map
        :localleader
        :desc "Format" :n "f" #'my/cabal-fmt-format-buffer))
#+end_src

*** Configuration of =haskell-mode=

Now load the actual =haskell-mode= package, and put some often-used functions as
well as some of the above utilities into a local keymap for easy access.

#+begin_src emacs-lisp
(add-hook! haskell-mode #'interactive-haskell-mode)

(after! haskell-mode
  (setq haskell-process-type 'cabal-repl
        haskell-interactive-popup-errors nil
        haskell-process-args-cabal-repl '("--repl-options=-ferror-spans"))
  (map! :map haskell-mode-map
        :prefix ("C-c p" . "pragmas")
        :desc "Enable language extension" :n "l" #'my/haskell-add-language-extension
        :desc "Set GHC option" :n "o" #'my/haskell-add-ghc-option
        :prefix "C-c"
        :desc "Add import" :n "i" #'my/haskell-add-import
        :localleader
        :desc "Kill session" :n "k" #'haskell-session-kill
        :desc "Format with fourmolu" :n "f" #'my/fourmolu-format-buffer))
#+end_src
** OCaml

[[https://github.com/ocaml/tuareg][tuareg]] is the standard mode for OCaml editing, providing syntax highlighting,
REPL support, etc., similar to what =haskell-mode= does for Haskell.

#+begin_src emacs-lisp
(after! tuareg
  (setq tuareg-indent-align-with-first-arg nil
        tuareg-match-patterns-aligned t)
  (reformatter-define my/ocamlformat-format
    :program "ocamlformat"
    :args (list "--name" (buffer-file-name) "-")
    :lighter " +ocamlformat")
  (map!
   :map tuareg-mode-map
   :localleader
   :desc "Format file"
   :nmv "f" #'my/ocamlformat-format-buffer))
#+end_src

** Rust

#+begin_src emacs-lisp
(after! rustic
  (map!
   :map rustic-mode-map
   :localleader
   :desc "Format buffer"
   :nmv "f" #'rustic-format-buffer))
#+end_src
