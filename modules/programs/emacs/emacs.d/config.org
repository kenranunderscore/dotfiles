#+TITLE: My GNU Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: show2levels indent

* Package management

I'm usually specifying the Emacs I'm using via [[https://github.com/nixos/nixpkgs][nixpkgs]] / my
[[https://github.com/nix-community/home-manager][home-manager]] setup, but it's still useful to have MELPA accessible
directly in case something is broken in =nixpkgs=.  This seems to happen
rather often with packages from ELPA especially.

#+begin_src elisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+end_src

Install [[https://github.com/jwiegley/use-package][use-package]].  The =nixpkgs= version of Emacs on my systems
already contains most packages, including =use-package= itself, but when
self-compiling Emacs or on Windows I rely on =use-package= for the
installation of most/all the packages.

#+begin_src elisp
(unless (package-installed-p 'use-package)
  (package-install package))
#+end_src

Due the aforementioned setup I used to specify =:ensure nil= in my
=use-package= calls.  Now that I've run into lots of problems especially
with ELPA packages I want to have a fallback method.

#+begin_src elisp
(setq use-package-always-ensure t)
#+end_src

* Keybinding management

The [[https://github.com/noctuid/general][general]] package allows me to define keybindings in a more
straightforward and declarative way.  This is especially useful for
its =evil-mode= integration, where I have to bind keys according to the
current mode.

#+begin_src elisp
(use-package general)
#+end_src

Some additional and modified basic Emacs keybindings go here (evil-
and mode-specific ones can be found in the evil section or the one for
the respective mode).

#+begin_src elisp
(general-define-key
 :states '(normal visual motion emacs operator)
 "C-h F" 'describe-face
 "C-h M" 'describe-keymap
 "C-h V" 'set-variable)
#+end_src

* Loading additional ELisp configuration files

#+begin_src elisp
(defmacro kenran/load-config-file (file)
  "Load FILE relative to the .emacs.d directory."
  `(load (locate-user-emacs-file ,file)
         'no-error))
#+end_src

I do not want customizations done via =customize= to end up in this
file.  Use a separate file instead and load that one on startup.

#+begin_src elisp
(let ((my-custom-file (locate-user-emacs-file "custom.el")))
  (setq custom-file my-custom-file)
  (load custom-file 'no-error))
#+end_src

A quick way to get to my =init.el= file.  FIXME: This should be changed
when the switch to the literate config is complete.

#+begin_src elisp
(defun kenran/open-init-file ()
  "Open my config.org file."
  (interactive)
  (find-file (file-truename (locate-user-emacs-file "config.org"))))
#+end_src

This is where my custom ELisp files reside.

#+begin_src elisp
(setq kenran/lisp-dir (concat user-emacs-directory "lisp/"))
#+end_src

And this is where I put custom themes.

#+begin_src elisp
(setq custom-theme-directory (concat kenran/lisp-dir "themes/"))
#+end_src

Without loading the =f= package the following function won't work any
longer.  It must have broken at some point when I switched to Emacs
29, or some other package must have loaded it before I ever tried
opening any of my configuration files.

#+begin_src elisp
(require 'f)

(defun kenran/open-other-config-file (file)
  "Open FILE of the config files in the lisp directory."
  (interactive
   (list
    (completing-read
     "Config file: "
     (mapcar #'f-filename
             (f-files kenran/lisp-dir)))))
  (find-file (file-truename (concat kenran/lisp-dir file))))
#+end_src

A similar thing for opening custom theme files quickly.

#+begin_src elisp
(defun kenran/open-custom-theme-file (file)
  "Open FILE of the themes in `custom-theme-directory'."
  (interactive
   (list
    (completing-read
     "Theme: "
     (mapcar #'f-filename
             (f-files custom-theme-directory)))))
  (find-file (file-truename (concat custom-theme-directory file))))
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.

One thing to pay attention to is that nearly all those operations on
"visuals" work slightly differently when starting Emacs as
=emacsclient=, for instance via

#+begin_src shell :tangle no
emacsclient -a ''
#+end_src

Setting some things at this point often results in the changes not
being applied correctly.  I think it's due to them happening in a
technical, visible Emacs frame.  See also
=kenran/is-initial-daemon-frame= below.

** Cursor

The default cursor is black, which interferes with mostly using a dark
theme.  Brighten it up a bit.

#+begin_src elisp
(set-mouse-color "white")
(add-hook 'server-after-make-frame-hook
          (lambda () (set-mouse-color "white")))
#+end_src

Enable a forever-blinking cursor.  I used to disable this mode but I
found myself searching for the cursor a couple of times lately.

#+begin_src elisp
(setq blink-cursor-delay 0.5)
(setq blink-cursor-blinks -1)
(blink-cursor-mode 1)
#+end_src

Don't show a cursor in inactive windows.  The default, hollow cursor
in inactive windows changes colors when switching evil modes as well;
that's kind of annoying.

#+begin_src elisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

Set the cursor to my preferred style, a box, and some very visible
colors for normal and insert mode.

#+begin_src elisp
(setq kenran/has-set-cursor-colors nil)
(defun kenran/set-evil-state-cursors (&optional force)
  "Set the cursor to a box, and use a different color for insert
and emacs mode.  The default color should be the one that the
current theme uses as background for the 'cursor face.  If FORCE
is true, then always set the colors anew."
  (when (or force (not kenran/has-set-cursor-colors))
    (setq kenran/has-set-cursor-colors t)
    (let* ((color "red")
           (default-cursor `(,color box))
           (insert-cursor `("chartreuse1" box)))
      (setq evil-operator-state-cursor default-cursor)
      (setq evil-normal-state-cursor default-cursor)
      (setq evil-replace-state-cursor default-cursor)
      (setq evil-visual-state-cursor default-cursor)
      (setq evil-motion-state-cursor default-cursor)
      (setq evil-emacs-state-cursor insert-cursor)
      (setq evil-insert-state-cursor insert-cursor)
      (remove-hook 'server-after-make-frame-hook
                   #'kenran/set-evil-state-cursors))))
#+end_src

** Check whether the current frame is the initial daemon frame

#+begin_src elisp
(defun kenran/is-initial-daemon-frame-p ()
  "Check whether the selected frame is the one that seems to be
automatically created when the daemon starts.  If this is the
selected frame we don't want to do certain things, like modifying
faces."
  (string= (frame-parameter (selected-frame) 'name) "F1"))
#+end_src

** Fonts

An alist of my preferred font families, together with a plist of
certain attributes that need to be applied when switching to the
respective font.

#+begin_src elisp
(setq kenran/font-alist
      '((pragmata-pro . (:family
                         "Pragmata Pro Mono Liga"
                         :default-height
                         170
                         :weight
                         regular))
        (iosevka-serif . (:family
                          "Iosevka Custom"
                          :default-height
                          166
                          :weight
                          regular))
        (iosevka . (:family
                    "Iosevka"
                    :default-height
                    166
                    :weight
                    regular))
        (hack . (:family
                 "Hack"
                 :default-height
                 150
                 :weight
                 regular))
        (ibm-plex . (:family
                     "IBM Plex Mono"
                     :default-height
                     150
                     :weight
                     regular))
        (cascadia . (:family
                     "Cascadia Code"
                     :default-height
                     150
                     :weight
                     regular))
        (terminus . (:family
                     "Terminus"
                     :default-height
                     170
                     :weight
                     regular))
        (jetbrains-mono . (:family
                           "JetBrains Mono"
                           :default-height
                           150
                           :weight
                           regular))))
#+end_src

The currently selected font (key of =kenran/font-alist=).  Setting this
value only changes the default; it is reset when switching fonts.

#+begin_src elisp
(setq kenran/current-monospace-font 'iosevka)
#+end_src

For =org-mode= I like using a serif font.  This is it.

#+begin_src elisp
(defconst kenran/serif-font "Noto Serif")
#+end_src

The function I use to switch between the various fonts I like.  It
applies the attributes of its value in =kenran/font-alist=.

#+begin_src elisp
(defun kenran/switch-font (font)
  "Apply the attributes stored for FONT in `kenran/font-alist'."
  (interactive
   (list (intern
          (completing-read
           "Font: "
           (mapcar #'car
                   (assoc-delete-all kenran/current-monospace-font
                                     (copy-alist kenran/font-alist)))))))
  (let* ((attrs (alist-get font kenran/font-alist))
         (family (plist-get attrs :family))
         (height (plist-get attrs :default-height)))
    (setq kenran/current-monospace-font font)
    (setq kenran/default-font-height height)
    (set-face-attribute
     'default nil
     :font family
     :weight (plist-get attrs :weight)
     :height (plist-get attrs :default-height))
    (set-face-attribute
     'fixed-pitch nil
     :font family
     :height 1.0)
    (set-face-attribute
     'variable-pitch nil
     :font kenran/serif-font
     :height 1.0)))
#+end_src

Finally, set all the face attributes, and register a hook that makes
sure that these also work when using the Emacs daemon together with
=emacsclient=.

#+begin_src elisp
(kenran/switch-font kenran/current-monospace-font)
(add-hook 'server-after-make-frame-hook
          (defun kenran/switch-to-current-font ()
            (kenran/switch-font kenran/current-monospace-font)
            (remove-hook 'server-after-make-frame-hook
                         #'kenran/switch-to-current-font)))
#+end_src

** Ligature support

Try out native ligature support via Harfbuzz composition tables
(doesn't work with every font, but works for instance with Fira Code
and Iosevka).  See
https://github.com/tonsky/FiraCode/wiki/Emacs-instructions#using-composition-char-table

#+begin_src elisp
(let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
               (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
               (36 . ".\\(?:>\\)")
               (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
               (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
               (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
               (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
               (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
               (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
               (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
               (48 . ".\\(?:x[a-zA-Z]\\)")
               (58 . ".\\(?:::\\|[:=]\\)")
               (59 . ".\\(?:;;\\|;\\)")
               (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
               (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
               (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
               (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
               (91 . ".\\(?:]\\)")
               (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
               (94 . ".\\(?:=\\)")
               (119 . ".\\(?:ww\\)")
               (123 . ".\\(?:-\\)")
               (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
               (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)"))))
  (dolist (char-regexp alist)
    (set-char-table-range composition-function-table (car char-regexp)
                          `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+end_src

** Color theme
*** Utilities

A command to switch themes interactively.  Emacs's =load-theme= applies
all the loaded themes on top of each other; I like to only have one
theme active at all times, so I use =disable-theme= on all themes in
=custom-enabled-themes= before enabling the target theme.

#+begin_src elisp
(defvar kenran/switch-theme-hook nil
  "Functions to be called after switching the current (default)
font.")

(defun kenran/switch-theme-hook ()
  "Run `kenran/switch-theme-hook'."
  (run-hook-with-args 'kenran/switch-theme-hook))

(defun kenran/switch-theme (name)
  "Switch themes interactively.  Similar to `load-theme' but also
disables all other enabled themes."
  (interactive
   (list (intern
          (completing-read
           "Theme: "
           (mapcar #'symbol-name
                   (-difference (custom-available-themes)
                                custom-enabled-themes))))))
  (progn
    (mapc #'disable-theme
          custom-enabled-themes)
    (load-theme name t)
    (kenran/switch-theme-hook)
    (unless (kenran/is-initial-daemon-frame-p)
      ;; If it's the initial "daemon frame" then hooks in
      ;; `server-after-make-frame-hook' will be executed, including
      ;; one that calls `kenran/set-evil-state-cursor-colors'.
      (kenran/set-evil-state-cursors t))))
#+end_src

When developing a theme, like I did with my custom one, it's handy to
be able to reload it on the fly.

#+begin_src elisp
(defun kenran/reload-theme ()
  "Reload the currently active theme."
  (interactive)
  (let ((active-theme (car custom-enabled-themes)))
    (kenran/switch-theme active-theme)))
#+end_src

*** Other themes I like

Since I cannot ever decide which theme I like best, there are a few
themes loaded here.

https://protesilaos.com/modus-themes/

#+begin_src elisp
(use-package modus-themes
  :defer t)
#+end_src

https://github.com/hlissner/emacs-doom-themes

#+begin_src elisp
(use-package doom-themes
  :defer t)
#+end_src

https://github.com/purcell/color-theme-sanityinc-tomorrow

#+begin_src elisp
(use-package color-theme-sanityinc-tomorrow
  :defer t)
#+end_src

https://github.com/rexim/gruber-darker-theme

#+begin_src elisp
(use-package gruber-darker-theme
  :defer t)
#+end_src

I usually use my own custom theme.

#+begin_src elisp
(kenran/switch-theme 'kenran)
#+end_src

** Render color names/codes with as their respective color

It's an ELPA package, so no need/use to put it in the nix-managed
Emacs packages.

#+begin_src elisp
(use-package rainbow-mode
  :defer t)
#+end_src

* Basic options
** Startup

FIXME: Move some of the following to =early-init.el= instead.  See
Prot's configuration for inspiration and give credit.

I wish to know how fast my Emacs is starting.  I'm not sure how to
make use of all that =use-package= has to offer in that regard yet, but
I want to at least know when I've made things worse.

#+begin_src elisp
(add-hook
 'emacs-startup-hook
 (lambda ()
   (message
    "Emacs startup took %s with %d garbage collections"
    (format
     "%.2f seconds"
     (float-time (time-subtract after-init-time before-init-time)))
    gcs-done)))
#+end_src

Disable the graphical UI things like the tool and menu bars, the
splash screen, and others.

#+begin_src elisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(setq inhibit-splash-screen t)
#+end_src

Ignore the =X= resources.  Now Emacs doesn't use the terminal
background/foreground colors.

#+begin_src elisp
(setq inhibit-x-resources t)
#+end_src

** Focus popup buffers

Then I can close them with =q= immediately when I don't need them.  Most
often it's only for a quick lookup, like help buffers:

#+begin_src elisp
(setq help-window-select t)
#+end_src

Or =apropos= buffers:

#+begin_src elisp
(add-hook 'apropos-mode-hook
          (defun kenran/focus-apropos-buffer ()
            (pop-to-buffer (current-buffer))))
#+end_src

** Resize proportionally after deleting windows

#+begin_src elisp
(setq window-combination-resize t)
#+end_src

** Less annoying yes/no questions

The following setting enables answering those yes/no questions with
just =y= or =n=.

#+begin_src elisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode.  Note:
this doesn't work correctly yet, as =(command-modes 'some-command)=
seems to return the modes in an unexpected format.

#+begin_src elisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

I like to use a hybrid mode for displaying line numbers.  That is,
line numbers are shown in a relative way, but the current line
displays as its absolute line number.  But when switching to normal
mode, line numbers should all be absolute.  That's what these two
functions are used for.

#+begin_src elisp
(defun kenran/switch-to-absolute-line-numbers ()
  "Enable absolute line numbers."
  (interactive)
  (when display-line-numbers-mode
    (setq display-line-numbers t)))

(defun kenran/switch-to-hybrid-line-numbers ()
  "Enable relative line numbers, but with the current line
showing its absolute line number."
  (interactive)
  (when display-line-numbers-mode
    (setq display-line-numbers 'relative)
    (setq display-line-numbers-current-absolute t)))
#+end_src

To display line numbers, the aptly named =display-line-numbers= package
is used.  It's enabled by default in all programming modes.

#+begin_src elisp
(use-package display-line-numbers
  :config
  (setq display-line-numbers-type 'relative)
  (setq display-line-numbers-current-absolute t)
  :hook ((prog-mode . display-line-numbers-mode)
         (conf-mode . display-line-numbers-mode)
         (evil-insert-state-entry . kenran/switch-to-absolute-line-numbers)
         (evil-insert-state-exit . kenran/switch-to-hybrid-line-numbers)))
#+end_src

Show column numbers in the modeline.

#+begin_src elisp
(column-number-mode)
#+end_src

Toggle line numbers interactively.  I've tried simply binding
=display-line-numbers-mode=, but I had to use it twice for the /first/
toggle.  This is more stable so far.

#+begin_src elisp
(defun kenran/toggle-line-numbers ()
  "Toggle `display-line-numbers-mode'.  Meant to be used in a
keybinding."
  (interactive)
  (display-line-numbers-mode 'toggle))
#+end_src

** Insert a newline at the end of files

#+begin_src elisp
(setq require-final-newline t)
(setq mode-require-final-newline t)
#+end_src

** Suppress warning from native compilation

When using Emacs =HEAD= (with the merged =native-comp= branch) a lot of
warnings show up during startup and when changing modes.  We could
increase the minimum severity for logs to be shown by setting
=warning-minimum-level= to =:error,= or just disable the warnings for
native compilation entirely like this:

#+begin_src elisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** Spaces over tabs

#+begin_src elisp
(setq-default indent-tabs-mode nil)
#+end_src

** File name searches should be case-insensitive

#+begin_src elisp
(setq read-file-name-completion-ignore-case t)
#+end_src

* Vim emulation

** Leader keys

Having a dedicated leader key (=SPC= in my case) is one of the most
important things to me as it opens up a lot of possibilities for
creating custom keymaps.  The keybindings naturally do not clash with
the default Emacs-style bindings many packages introduce.  I will use
this to try and create more vim-inspired mnemonic keybindings (say, =p=
for project-specific commands, =g= for git etc.)

In general I try to keep package-specific keybindings next to the
configuration of the respective packages.  However with =use-package=
there seems to be a =:general= keyword, which probably works similar to
the =:bind= one.  I sometimes use the latter for bindings that are not
mode-sensitive.

#+begin_src elisp
(general-create-definer with-leader
  :keymaps 'override
  :states '(normal insert emacs visual motion)
  :prefix "SPC"
  :non-normal-prefix "C-SPC")
#+end_src

A local leader key is something that is usually used to access
situational commands, for instance language-specific or mode-specific
ones.  I used =,= for this in Vim; same here now.

#+begin_src elisp
(general-create-definer with-local-leader
  :prefix ",")
#+end_src

** Non-evil ("holy") modes

This is a list of modes that I do not want =evil= mode (defined below)
to be enabled in by default.  It's mostly a preference of mine to use
Emacs mode in REPL, terminal and shell buffers.

#+begin_src elisp
(setq kenran/holy-modes
      '((ediff . ediff)
        (eshell-mode . eshell)
        (mu4e . mu4e)
        (mu4e . mu4e-conversation)
        (notmuch-hello-mode . notmuch)
        (racket-repl-mode . nil)
        (racket-stepper-mode . nil)
        (shell-mode . nil)
        (sly-mrepl-mode . nil)
        (term-mode . (term term ansi-term multi-term))
        (vterm-mode . vterm)
        (haskell-interactive-mode . nil)))

(setq kenran/evil-holy-modes
      (mapcar #'car kenran/holy-modes))

(setq kenran/evil-collection-exemptions
      (remove nil
              (mapcar #'cdr kenran/holy-modes)))
#+end_src

** =Evil= and supporting packages

The evil package offers a very complete vim experience inside of
Emacs.

#+begin_src elisp
(use-package evil
  :config
  (evil-mode 1)
  (dolist (mode kenran/evil-holy-modes)
    (evil-set-initial-state mode 'emacs))
  :custom
  ((evil-want-C-u-scroll t)
   (evil-want-C-u-delete nil)
   (evil-want-C-w-delete t)
   (evil-want-Y-yank-to-eol t)
   (evil-undo-system 'undo-redo)
   (evil-symbol-word-search t))
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (add-hook 'server-after-make-frame-hook
            #'kenran/set-evil-state-cursors))
#+end_src

*** Evilify nearly everything (=evil-collection=)

This package makes it possible to enable =evil= in lots of (mostly
minor) modes.  This usually includes some sort of streamlined
keybinding scheme, where the vim movement keys =h=, =j=, =k=, =l=, and often
=C-j= and =C-k= are used for navigation.

However, I've been in the situation where "something didn't quite
work" quite some times, and =evil-collection= has often been the
culprit.  Checking =evil-collection-mode-list= to see whether any
current mode was evilified with =evil-collection=, and subsequently
removing them from this list, has often fixed some problems (for
instance with =mu4e=).

#+begin_src elisp
(use-package evil-collection
  :after evil
  :config
  (dolist (x kenran/evil-collection-exemptions)
    (delete x evil-collection-mode-list))
  (evil-collection-init)
  (evil-collection-inhibit-insert-state 'notmuch-hello-mode-map)
  :custom
  ((evil-collection-company-use-tng t)
   (evil-collection-want-unimpaired-p nil)))
#+end_src

*** Surrounding things

The analogue of [[https://github.com/tpope/vim-surround][Tim Pope's vim-surround plugin]] in Emacs.  Now I can
use things like =ysiw)= to surround an inner word with non-padded normal
parentheses, =ds]= to delete surrounding brackets, or =cs[{= to change
surrounding brackets to curly braces with whitespace padding.
Selected regions can be surround with e.g. =S`=.

#+begin_src elisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode))
#+end_src

*** 2-character searching in one line

[[https://github.com/hlissner/evil-snipe][Henrik Lissner's evil-snipe]] replaces the default vim =s= binding by a
2-character incremental forward/backward search.  In addition,
=evil-snipe-override-mode= makes the =f=, =F=, =t=, and =T= searches repeatable
by pressing the respective key again to jump by one match.  It also
adds highlighting to those motions.

It's also possible to configure/increase the scope of these searches,
but for the moment I'm content with just using it on one line.

#+begin_src elisp
(use-package evil-snipe
  :after evil
  :diminish evil-snipe-local-mode
  :config
  (evil-snipe-mode 1)
  (evil-snipe-override-mode 1))
#+end_src

*** Evilify =org=

=Evil-org= enables me to use =evil= keybindings in =org-agenda=.  As a bonus
it adds some keybindings and text objects for =org= files as well.

TODO: It's surely worth spending some more time to find out what else
this brings with it, but I'm not writing enough with =org=

#+begin_src elisp
(use-package evil-org
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :diminish evil-org-mode
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src

*** Highlight vim marks

#+begin_src elisp
(use-package evil-visual-mark-mode
  :defer t
  :after evil
  :init (evil-visual-mark-mode))
#+end_src

** Keybindings

Create nice custom mappings for normal mode (and others) that are
accessed with the leader key, =SPC=.

#+begin_src elisp
(with-leader
  ;; Give SPC SPC one more chance
  "SPC" '(execute-extended-command :which-key "M-x")
  ;; Different ways to quit Emacs
  "q" '(:ignore t :which-key "quit")
  "q f" 'evil-save-and-quit
  "q k" 'save-buffers-kill-emacs
  ;; Buffer-related commands
  "b" '(:ignore t :which-key "buffer")
  "b b" 'consult-buffer
  "b q" 'kill-current-buffer
  "b i" 'ibuffer
  "b k" 'kill-buffer
  "b n" 'next-buffer
  "b p" 'previous-buffer
  ;; Toggles/switches
  "t" '(:ignore t :which-key "toggle/switch")
  "t l" '(kenran/toggle-line-numbers :which-key "line numbers")
  "t t" '(kenran/switch-theme :which-key "switch theme")
  "t r" '(kenran/reload-theme :which-key "reload theme")
  "t f" '(kenran/switch-font :which-key "switch font")
  "t w" 'global-whitespace-mode
  ;; Language-agnostic code-related commands
  "c" '(:ignore t :which-key "code")
  "c l" 'comment-line
  "c r" 'comment-or-uncomment-region
  ;; Searching
  "s" '(:ignore t :which-key "search/switch")
  "s g" 'consult-git-grep
  "s p" 'consult-ripgrep
  ;; Window management (redundant)
  "w" '(evil-window-map :which-key "windows")
  ;; Emacs config
  "e" '(:ignore t :which-key "emacs")
  "e e" '(kenran/open-init-file :which-key "edit config.org")
  "e c" '(kenran/open-other-config-file :which-key "edit other config file")
  "e t" '(kenran/open-custom-theme-file :which-key "edit custom theme")
  ;; Additional help commands
  "h" '(:ignore t :which-key "help")
  "h m" 'man)
#+end_src

*** =C-w=

Enable =C-w= for vim-like window management (when not in insert or Emacs
mode).  This means that I need to override the Emacs default binding,
which can be done via =general='s =:keymaps 'override=.

#+begin_src elisp
(general-define-key
 :states '(normal visual motion operator)
 :keymaps 'override
 "C-w" 'evil-window-map
 "C-w C-h" 'evil-window-left
 "C-w C-k" 'evil-window-up
 "C-w C-j" 'evil-window-down
 "C-w C-l" 'evil-window-right
 "C-w C-d" 'evil-quit)
#+end_src

Enable =C-w= to delete backward (like in vim or bash) in insert mode,
and also when Emacs is reading user input in the minibuffer.

#+begin_src elisp
(general-define-key
 :keymaps 'minibuffer-local-map
 "C-w" 'evil-delete-backward-word)

(general-define-key
 :states '(emacs)
 "C-w" 'evil-delete-backward-word)
#+end_src

* Incremental narrowing

I started with =helm= in [[https://www.spacemacs.org/][spacemacs]], then later switched to [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
where after a while I tried out =ivy= and loved it.  Configuring Emacs
from scratch was when I decided to try out some of the newer, more
lightweight Emacs packages like [[https://github.com/raxod502/selectrum][selectrum]] and [[https://github.com/minad/vertico][vertico]].  Those
integrate very well with default Emacs functionality, so a lot of
things can utilize them "implicitly".  I've stuck with =vertico= and
I've been happy with it ever since.

#+begin_src elisp
(use-package vertico
  :init
  (vertico-mode +1)
  :custom
  (vertico-cycle t)
  :bind
  (:map vertico-map
        ("C-w" . evil-delete-backward-word)))
#+end_src

=savehist-mode= keeps a history of commands and inputs I've done in a
context-sensitive way, and then shows those at the top when presented
with possible results from =vertico=.

#+begin_src elisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][orderless]] is a /completion style/ that fits in very well with =vertico=
(or =selectrum=, for that matter).  Parts of a search string may match
according to several matching styles.  We want to be able to specify
which matching style to use by appending a suffix so a search string.
Therefore we define style dispatchers and use them to customize
=orderless-style-dispatchers=.

Prepending an equals sign to a search term will search for literal
matches of the preceding string.

#+begin_src elisp
(defun kenran/literal-if-= (pattern _index _total)
  (when (string-prefix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 1))))
#+end_src

A prepended bang discards everything that matches the preceding
literal string.

#+begin_src elisp
(defun kenran/without-if-! (pattern _index _total)
  (when (string-prefix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

The tilde sign gives me a way to have "fuzzy" search, if needed.

#+begin_src elisp
(defun kenran/flex-if-~ (pattern _index _total)
  (when (string-prefix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 1))))
#+end_src

#+begin_src elisp
(use-package orderless
  :custom (completion-styles '(orderless))
  (orderless-style-dispatchers
   '(kenran/literal-if-=
     kenran/without-if-!
     kenran/flex-if-~)))
#+end_src

** Consult

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite
some time, though not in any extent close to full.  This defines some
basic bindings mostly taken from an example in its readme.

#+begin_src elisp
(use-package consult
  :bind (;; C-x bindings
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ;; C-h bindings (help)
         ("C-h a" . consult-apropos)
         ;; M-g bindings (goto)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ;; M-s bindings (search)
         ("M-s f" . consult-find)
         ("M-s L" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines))
  :custom
  (consult-project-root-function
   (lambda ()
     (when-let (project (project-current))
       (project-root project)))))
;; TODO other isearch integration?
;; TODO :init narrowing, preview delay
#+end_src

** Minibuffer actions

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet.  It seems to be amazing, though!
What I mostly use it for at the moment is its =embark-act= command in
conjunction with =embark-export=.  With this I often pull the results of
some =grep= command into a separate buffer, where I can then utilize
=wgrep= to bulk-modify the original buffers.

#+begin_src elisp
(use-package embark
  :bind (("C-," . embark-act)
         ("C-h B" . embark-bindings))
  :init
  (setq prefix-help-command #'embark-prefix-help-command))
#+end_src

Integrate =embark= with =consult=.

#+begin_src elisp
(use-package embark-consult
  :after (embark consult)
  :demand t
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

* Auto-completion popups

[[https://company-mode.github.io/][company-mode]] provides textual auto-completions in nearly every
context.  There are lots of backends that can be used for
context-sensitiv completion, but I don't make use of those really
(yet).

#+begin_src elisp
(use-package company
  :hook ((after-init . global-company-mode))
  :diminish company-mode
  :init
  ;; Without this orderless would be used by default for company
  ;; completions.  It doesn't fit there as well though.
  (define-advice company-capf
      (:around (orig-fun &rest args) set-completion-styles)
    (let ((completion-styles '(basic partial-completion)))
      (apply orig-fun args)))
  :custom
  ((company-idle-delay 0)
   (company-selection-wrap-around t)
   (company-minimum-prefix-length 4))
  :bind
  (:map company-active-map
        ("C-w" . evil-delete-backward-word)))
#+end_src

This is a workaround for using =company= together with =whitespace-mode=.
Seeing the whitespace marks in the popup is quite annoying, but this
makes it manageable.  See
https://github.com/company-mode/company-mode/issues/1231.

#+begin_src elisp
(defun company--replacement-with-ws-face (str)
  (if (and (or global-whitespace-mode whitespace-mode)
           (memq 'space-mark whitespace-active-style)
           (memq 'face whitespace-active-style)
           (memq 'spaces whitespace-active-style))
      (let ((face `(:foreground ,(face-attribute 'whitespace-space :foreground))))
        (replace-regexp-in-string
         " "
         (lambda (s)
           (setq s (copy-sequence s))
           (add-face-text-property 0 (length s) face nil s)
           s)
         str))
    str))

(advice-add #'company--replacement-string
            :filter-return
            #'company--replacement-with-ws-face)
#+end_src

* E-Mail configuration

There are some different ways to "do e-mail in Emacs".  Over the last
two years I've tried out =notmuch=, =gnus=, and =mu4e=. Some thoughts on
each of those:

** Notmuch

The Emacs integration for =notmuch= is great; it has the most intuitive
and appealing UI from each of the options.  =Notmuch= works by
referencing incoming e-mail in a separate database only, not ever
touching or modifying it.  I really like this idea, and in practice it
also felt great due to the quick und customizable searches.  The usual
approach is to use a tag-based system of categorizing your e-mail, but
simply having lots of stored queries is a little bit more flexible.

But =notmuch= only handles this single aspect; this means that one needs
to find solutions to the following:

- Getting mail
- Initial tagging
- Sending mail
- Synchronization between machines

Due to the declarative e-mail account configuration from =home-manager=
the first part is very simple, and I could also easily switch between
different tools like =isync= or =offlineimap=.

The initial tagging can be done with a shell script using the
well-documented =notmuch= CLI, or via =afew=.

For sending mail I use =msmtp=.

Synchronization is where it broke down for me.  I have a PC at home,
and a laptop at work, and I'd like those two machines to have
identical state with respect to e-mail at all times.  I've tried using
=muchsync= on my personal server to be the "source of truth".  This
means that only the server downloads e-mail via IMAP, and the machines
are simply its /clients/; they use =muchsync= to download mail from the
server.

This sounds great on paper but it presents a problem with sent mail,
which I'd also like to sync back via IMAP to my accounts.  The client
machine sends this and puts it into a special =sent= directory, which is
then synchronized/uploaded to the server via =muchsync=.  I've had
problems with mails appearing twice, or appearing not at all on the
respective "other" machine.

If I only used one machine, =notmuch= would definitely be my preference,
but debugging this situation was very tedious and I just didn't have
the energy or time to do it.

** Gnus

I've not given =gnus= the trial it deserves.  Reading newsgroups and
mailing lists is something I can image using =gnus= for in the future.
Using it for e-mail, though, would require another synchronization
process of the =gnus= state.

I could utilize =syncthing=, which I use for synchronization of my =org=
files, to do this as well, but I've given it a couple of tries and
couldn't do it.  An experiment for another time, for sure.

** Mu for Emacs

[[https://www.djcbsoftware.nl/code/mu/][Mu]] is what I'm currently using, and =mu4e= is its Emacs frontend.  It's
not as customizable as =notmuch=, but part of its charme is that I don't
need to sync anything between my machines, at the cost of =mu= touching
my e-mail (adding custom headers I believe).  I don't mind this at
all, and I can use =isync= and =msmtp= to receive and send mail on any
host.

For writing e-mails =mu4e= uses =message-mode= like the other tools.  This
checks the =user-full-name= variable to fill in my name.

#+begin_src elisp
(setq user-full-name "Johannes Maier")
#+end_src

The actual =mu4e= configuration is one huge =use-package= block, but most
of it is due to its concept of /contexts/.  Usually there's one context
for each of my e-mail addresses, and switching between them I may set
some context-specific variables, or even change the =mu4e= UI
accordingly.

Note that =mu4e= is one of those packages that would behave strangely
when using the =evil-collection= integration.

#+begin_src elisp
(use-package mu4e
  :ensure nil
  :defer t
  :commands (mu4e)
  :config
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-completing-read-function #'completing-read)
  ;; I don't sync drafts to either of the accounts
  (setq mu4e-confirm-quit nil)
  (setq mu4e-change-filenames-when-moving t)
  (setq mu4e-drafts-folder "/drafts")
  (setq mu4e-attachment-dir "~/Downloads/")
  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "mailbox"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/mailbox"
                                             (mu4e-message-field msg :maildir)
                                             t)))
            :vars '((user-mail-address . "johannes.maier@mailbox.org")
                    (mu4e-compose-signature . nil)
                    (mu4e-sent-folder . "/mailbox/Sent")
                    (mu4e-trash-folder . "/mailbox/Trash")
                    (mu4e-refile-folder . (lambda (msg)
                                            (let* ((date (mu4e-message-field-at-point :date))
                                                   (year (decoded-time-year (decode-time date))))
                                              (concat "/mailbox/Archive/"
                                                      (number-to-string year)))))))
          ,(make-mu4e-context
            :name "ag"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/ag"
                                             (mu4e-message-field msg :maildir)
                                             t)))
            :vars `((user-mail-address . "johannes.maier@active-group.de")
                    ;; FIXME: Signature in a file?
                    (mu4e-compose-signature . ,(concat
                                                "Johannes Maier\n"
                                                "johannes.maier@active-group.de\n\n"
                                                "+49 (7071) 70896-67\n\n"
                                                "Active Group GmbH\n"
                                                "Hechinger Str. 12/1\n"
                                                "72072 Tübingen\n"
                                                "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                                                "Geschäftsführer: Dr. Michael Sperber"))
                    (mu4e-sent-folder . "/ag/Sent")
                    (mu4e-refile-folder . (lambda (msg)
                                            (let* ((date (mu4e-message-field-at-point :date))
                                                   (year (decoded-time-year (decode-time date))))
                                              (concat "/ag/Archives/"
                                                      (number-to-string year)))))
                    (mu4e-trash-folder . "/ag/Trash")))))
  (setq mu4e-bookmarks '((:name "Active-Group inbox" :query "maildir:/ag/Inbox" :key ?a)
                         (:name "Mailbox inbox" :query "maildir:/mailbox/Inbox" :key ?m)
                         (:name "Unread messages" :query "flag:unread AND NOT flag:trashed" :key ?u)
                         (:name "Sent" :query "maildir:/ag/Sent OR maildir:/mailbox/Sent" :key ?s)))
  (setf (alist-get 'trash mu4e-marks)
        (list :char '("d" . "▼")
              :prompt "dtrash"
              :dyn-target (lambda (target msg)
                            (mu4e-get-trash-folder msg))
              :action (lambda (docid msg target)
                        (mu4e~proc-move docid (mu4e~mark-check-target target)) "-N")))
  (setq mu4e-headers-fields '((:human-date . 12)
                              (:flags . 6)
                              (:maildir . 15)
                              (:mailing-list . 10)
                              (:from . 22)
                              (:subject)))
  (setq mu4e-context-policy 'pick-first)
  (setq mu4e-compose-policy 'ask)
  ;; Getting mail via mbsync
  (setq mu4e-get-mail-command "mbsync -a")
  ;; Composing emails
  (setq message-send-mail-function #'message-send-mail-with-sendmail)
  (setq send-mail-function #'message-send-mail-with-sendmail)
  (setq message-sendmail-envelope-from 'header)
  (setq mail-envelope-from 'header)
  (setq mail-specify-envelope-from 'header)
  (setq message-kill-buffer-on-exit t)
  ;; Visuals
  (setq mu4e-headers-thread-single-orphan-prefix '("─> " . "─▶"))
  (setq mu4e-headers-thread-orphan-prefix '("┬> " . "┬▶ "))
  (setq mu4e-headers-thread-child-prefix '("├> " . "├▶"))
  (setq mu4e-headers-thread-connection-prefix '("│ " . "│ "))
  (setq mu4e-headers-thread-duplicate-prefix '("= " . "≡ "))
  (setq mu4e-headers-thread-first-child-prefix '("├> " . "├▶"))
  (setq mu4e-headers-thread-last-child-prefix '("└> " . "╰▶")))
#+end_src

Bind e-mail management to the global hotkey =SPC m=.

#+begin_src elisp
(with-leader
  "m" '(mu4e :which-key "mail"))
#+end_src
  
* Package-specific configuration
** Hide minor modes from the modeline

The =diminish= package enables us to hide minor modes from the modeline.
It's especially useful for certain modes that are globally enabled
anyway.  =Use-package= has built-in support for this available with the
=:diminish= keyword.

#+begin_src elisp
(use-package diminish)
#+end_src

** Mode-specific code snippets

#+begin_src elisp
(use-package yasnippet
  :init (yas-global-mode 1)
  :diminish yas-minor-mode)
#+end_src

** Terminal emulator in Emacs

=vterm= is a terminal emulator for Emacs, more feature-rich than the
built-in =term=.  This is very useful for quickly spawning a terminal,
for instance in the at the top-level directory of a project.

#+begin_src elisp
(use-package vterm
  :defer t
  :config
  (setq vterm-shell "fish")
  (general-define-key
   :keymaps 'vterm-mode-map
   :states 'emacs
   "C-w" 'vterm-send-C-w))
#+end_src

** EditorConfig

I want to be able to simply clone and work in projects and adapt to
their respective styles of indentation, newlines at the end of files,
and the like.  [[https://editorconfig.org/][EditorConfig]] comes with a specified file format to
describe these things, possible even on per-file basis; all one needs
to use these is support of one's editor.  Many editors have
out-of-the-box EditorConfig support nowadays.  For Emacs, there's the
official [[https://github.com/editorconfig/editorconfig-emacs][editorconfig-emacs]] package.

#+begin_src elisp
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+end_src

** Ini files

I'm not 100 percent happy with this package, as paragraphs seem to be
acting strange.  Deleting a paragraph via =dap= for instance often
deletes the following one, too, plus sometimes the previous section
header.

#+begin_src elisp
(use-package ini-mode
  :defer t)
#+end_src

** JavaScript

#+begin_src elisp
(use-package js
  :defer t
  :config
  (setq js-indent-level 2))
#+end_src

** Purescript

#+begin_src elisp
(use-package psc-ide
  :hook (purescript-mode . psc-ide-mode)
  :config
  (setq psc-ide-rebuild-on-save t))

(use-package purescript-mode
  :hook (purescript-mode . turn-on-purescript-indentation))
#+end_src

** Nix

#+begin_src elisp
(use-package nix-mode
  :mode "\\.nix\\'"
  :hook (before-save . nix-format-before-save))
#+end_src

** Markdown

#+begin_src elisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc")
  :hook ((markdown-mode gfm-mode) . auto-fill-mode))
#+end_src

** Org mode

I want my =org= files to have indentation corresponding to the header
level.

#+begin_src elisp
(use-package org-indent
  :ensure nil
  :diminish org-indent-mode)
#+end_src

I want my headers to stand out by being really big.  I also like using
=variable-pitch-mode=, which makes it so only code, verbatim, and some
other things are written with my current monospace / fixed-width font,
and the rest uses a serif font more suitable for longer texts.  But
customizing these faces with =set-face-attribute= has the usual problems
with the initial daemon frame, and doesn't hold up when switching
fonts or themes.  That's why I've put those changes into the following
functions which I can call whenever these sorts of changes happen,
either through hooks or manual trigger.

Note that some themes, like =modus-{vivendi,operandi}=, might set the
=:inherit= attribute on a face, in which case a naive
~(set-face-attribute face nil :inherit 'fixed-pitch)~ overrides the
theme settings.  To circumvent this I've written the following
function that appends a single new value to the current =:inherit=
attribute value of a face.

#+begin_src elisp
(defun inherit-fixed-pitch (face)
  "Append `fixed-pitch' to the `:inherit' attribute of FACE."
  (let* ((current (face-attribute face :inherit))
         (new (cond
               ((eq 'unspecified current) 'fixed-pitch)
               ((listp current) (cons 'fixed-pitch current))
               (t `(fixed-pitch ,current)))))
    (set-face-attribute face nil :inherit new)))

(defun kenran/org-font-setup ()
  "Set the face attributes for code, verbatim, and other markup
elements.  Also increase org header size."
  (interactive)
  (inherit-fixed-pitch 'org-block)
  (inherit-fixed-pitch 'org-block-begin-line)
  (inherit-fixed-pitch 'org-block-end-line)
  (inherit-fixed-pitch 'org-document-info-keyword)
  (inherit-fixed-pitch 'org-document-info)
  (inherit-fixed-pitch 'org-code)
  (inherit-fixed-pitch 'org-table)
  (inherit-fixed-pitch 'org-verbatim)
  (inherit-fixed-pitch 'org-checkbox)
  (inherit-fixed-pitch 'org-meta-line)
  (inherit-fixed-pitch 'org-special-keyword)
  (inherit-fixed-pitch 'org-indent)
  (inherit-fixed-pitch 'org-link)
  (set-face-attribute 'org-document-title nil :height 1.8 :weight 'bold)
  (dolist (face '((org-level-1 . 1.6)
                  (org-level-2 . 1.4)
                  (org-level-3 . 1.2)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.0)
                  (org-level-6 . 1.0)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    (set-face-attribute (car face) nil
                        :font kenran/serif-font
                        :height (cdr face)
                        :weight 'bold)))

(add-hook 'kenran/switch-theme-hook #'kenran/org-font-setup)
#+end_src

When writing text with =org=, =auto-fill-mode= should be enabled to
automatically break overly long lines into smaller pieces when typing.
One may still use =M-q= to re-fill paragraphs when editing text.  After
loading =org=, a custom font setup might run to adjust the headers.

#+begin_src elisp
(use-package org
  :hook
  ((org-mode . auto-fill-mode)
   (org-mode . variable-pitch-mode)
   (org-trigger . save-buffer))
  :custom
  ((org-startup-indented t)
   (org-startup-folded 'content)
   (org-directory "~/org")
   (org-log-done t)
   (org-special-ctrl-a/e t)
   ;; If this has a value greater than 0, every RET press
   ;; keeps indenting the source block further and further.
   (org-edit-src-content-indentation 0)
   (org-default-notes-file "~/org/notes.org")
   (org-agenda-files '("~/org/inbox.org"
                       "~/org/gtd.org"
                       "~/org/someday.org"))
   (org-agenda-restore-windows-after-quit t)
   (org-refile-targets `(("~/org/gtd.org" :maxlevel . 3)
                         ("~/org/someday.org" :level . 1)))
   (org-capture-templates '(("t" "Todo" entry
                             (file+headline "~/org/inbox.org" "Tasks")
                             "* TODO %i%?")
                            ("n" "Note" entry
                             (file+headline "~/org/notes.org" "Notes")
                             "* %?\n%a\nNote taken on %U")))
   (org-capture-bookmark nil)
   (org-bookmark-names-plist nil)
   (org-todo-keywords '((sequence
                         "TODO(t)"
                         "WAITING(w)"
                         "|"
                         "DONE(d)"
                         "CANCELLED(c)")))
   (org-html-htmlize-output-type 'css))
  :config
  (kenran/org-font-setup)
  (setq-default org-hide-emphasis-markers t)
  (advice-add 'org-refile
              :after (lambda (&rest _) (org-save-all-org-buffers))))
#+end_src

*** Keybindings

Add some globally useful =org= keybindings under =SPC o=, like for
capturing, storing links etc.

#+begin_src elisp
(with-leader
  "o" '(:which-key "org-mode" :ignore t)
  "o a" 'org-agenda
  "o c" 'org-capture
  "o l" 'org-store-link
  "o f" 'org-cycle-agenda-files
  "o s" 'org-save-all-org-buffers)
#+end_src

*** Beautiful bullet points

#+begin_src elisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode)
  :custom (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

Also render unordered list bullet points as dots instead of =-= or =+=.

#+begin_src elisp
(font-lock-add-keywords
 'org-mode
 '(("^ *\\([-]\\) "
    (0 (prog1 ()
         (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

*** Org as a Zettelkasten implementation

This is a very basic setup for =org-roam=.  I don't use the Zettelkasten
approach yet, but might in the future.  My synchronization setup with
=syncthing= should handle this well.

#+begin_src elisp
(use-package org-roam
  :ensure t
  :init
  (setq org-roam-v2-ack t)
  ;; Didn't work for the initial setup when set in :custom.
  (setq org-roam-directory (file-truename "~/org/roam/"))
  :custom
  (org-roam-db-location (expand-file-name
                         (concat (system-name) "-roam" ".db")
                         org-roam-directory))
  :config
  (org-roam-setup))
#+end_src

*** Short presentations with org

#+begin_src elisp
(use-package org-present
  :hook ((org-present-mode . (lambda ()
                               (org-present-big)
                               (org-display-inline-images)
                               (org-present-hide-cursor)
                               (org-present-read-only)))
         (org-present-mode-quit . (lambda ()
                                    (org-present-small)
                                    (org-remove-inline-images)
                                    (org-present-show-cursor)
                                    (org-present-read-write)))))
#+end_src

*** Enable syntax highlighting when exporting to HTML

#+begin_src elisp
(use-package htmlize
  :defer t
  :after ox)
#+end_src

** Haskell

Provide an interactive mode for writing Haskell.  I can work with a
REPL, get feedback and compilation errors shown in the code, and so
on.

#+begin_src elisp
(use-package haskell-mode
  :diminish interactive-haskell-mode
  :custom
  (haskell-process-type 'cabal-repl)
  (haskell-interactive-popup-errors nil)
  :hook (haskell-mode . interactive-haskell-mode))
#+end_src

A couple of ELisp functions that help me to make quick changes to
Haskell files (adding pragmas, language extensions, GHC options,
imports).

#+begin_src elisp
(defun kenran/make-pragma (pragma content)
  "Create a pragma line of type `pragma' containing `content'."
  (concat "{-# " pragma " " content " #-}\n"))

(defun kenran/haskell-add-language-extension (ext-name)
  "Add an extension from the list of available language extensions
to the top of the file."
  (interactive
   (list
    (completing-read
     "Extension: "
     haskell-ghc-supported-extensions)))
  (let ((pragma (kenran/make-pragma "LANGUAGE" ext-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun kenran/haskell-add-ghc-option (opt-name)
  "Add a GHC option from the list of options to the top of the
file."
  (interactive
   (list
    (completing-read
     "GHC option: "
     haskell-ghc-supported-options)))
  (let ((pragma (kenran/make-pragma "OPTIONS_GHC" opt-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun kenran/read-non-empty-string (prompt)
  "Read a string from the minibuffer.  When the result is the empty
string, return nil instead."
  (let ((str (read-string prompt)))
    (unless (string-empty-p str)
      str)))

(defun kenran/haskell-add-import (module &optional qualified? alias)
  "Add an import to the import list.  Prompts for qualified import
and alias."
  (interactive
   (let* ((module (read-string "Module: "))
          (qualified? (y-or-n-p (concat "Import " module " qualified?")))
          (alias (when qualified?
                   (kenran/read-non-empty-string "Alias [or leave empty]: "))))
     (list module qualified? alias)))
  (let ((import-line
         (concat "import "
                 (when qualified? "qualified ")
                 module
                 (when alias (concat " as " alias))
                 "\n")))
    (save-excursion
      (haskell-navigate-imports-go)
      (insert import-line))))
#+end_src

Define some keybindings that are local to the =interactive-haskell-mode=
using the local leader key.

#+begin_src elisp
(with-local-leader
  :states 'normal
  :keymaps 'interactive-haskell-mode-map
  "e" '(:ignore t :which-key "errors")
  "e f" '(haskell-goto-first-error :which-key "first")
  "e n" '(haskell-goto-next-error :which-key "next")
  "e p" '(haskell-goto-prev-error :which-key "previous")
  "i" '(:ignore t :which-key "imports")
  "i i" '(haskell-navigate-imports-go :which-key "navigate to imports")
  "i r" '(haskell-navigate-imports-return :which-key "return from imports")
  "i a" '(kenran/haskell-add-import :which-key "add import")
  "p" '(:ignore t :which-key "pragmas")
  "p l" '(kenran/haskell-add-language-extension :which-key "add language extension")
  "p o" '(kenran/haskell-add-ghc-option :which-key "add GHC option")
  "h" '(:ignore t :which-key "haskell-process")
  "h r" '(haskell-process-restart :which-key "restart")
  "h k" 'haskell-session-kill)
#+end_src
  
** Dhall

#+begin_src elisp
(use-package dhall-mode
  :mode "\\.dhall\\'"
  :config
  (setq dhall-type-check-inactivity-timeout 2))
#+end_src

** Docker

#+begin_src elisp
(use-package dockerfile-mode
  :defer t)
#+end_src

** YAML

#+begin_src elisp
(use-package yaml-mode
  :defer t)
#+end_src

** Clojure

The key to using Clojure effectively with Emacs seems to be [[https://github.com/clojure-emacs/cider][CIDER]].

#+begin_src elisp
(use-package clojure-mode
  :defer t)

(use-package cider
  :after clojure-mode
  :defer t)
#+end_src

** CSV

#+begin_src elisp
(use-package csv-mode
  :defer t)
#+end_src

** PlantUML

#+begin_src elisp
(use-package plantuml-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist
               '("\\.\\(plantuml\\|puml\\)\\'" . plantuml-mode))
  :config
  (setq plantuml-default-exec-mode 'executable))
#+end_src

** Common Lisp

[[https://github.com/joaotavora/sly][SLY]] seems to be a bit more actively developed and modern than [[https://slime.common-lisp.dev/][SLIME]].

#+begin_src elisp
(use-package sly
  :defer t
  :config
  (setq inferior-lisp-program "sbcl"))
#+end_src

=sly-asdf= gives integration with Common Lisp's package manager, [[https://asdf.common-lisp.dev/][ASDF]].

#+begin_src elisp
(use-package sly-asdf
  :defer t)
#+end_src

** Racket

#+begin_src elisp
(use-package racket-mode
  :defer t
  :hook ((racket-mode . racket-xp-mode)
         (racket-mode . racket-unicode-input-method-enable)
         (racket-repl-mode . racket-unicode-input-method-enable)))
#+end_src

** Java

I don't use Java, but Bob Nystrom's excellent and free book [[https://craftinginterpreters.com/][Crafting
Interpreters]] uses it for the first part.  It's actually quite OK to
write Java with =meghanada,= but it takes a long time to download all
its dependencies.

#+begin_src elisp
(use-package meghanada
  :defer t
  :init
  (add-hook 'java-mode-hook
            (lambda ()
              (meghanada-mode t)
              (flycheck-mode +1)
              (setq c-basic-offset 2)
              (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))))
#+end_src

** Python

#+begin_src elisp
(use-package anaconda-mode
  :defer t
  :hook (python-mode . anaconda-mode))

(use-package pyimport
  :defer t)
#+end_src

** Nim

#+begin_src elisp
(use-package nim-mode
  :defer t)
#+end_src

** F#

#+begin_src elisp
(use-package fsharp-mode
  :defer t
  :config
  (setq fsharp-indent-offset 2)
  (setq fsharp-continuation-offset 2)
  (setq inferior-fsharp-program "dotnet fsi --readline-"))
#+end_src

** LSP integration

I've used =lsp-mode= in the past and while it's nice, I feel like it's
more in line with the rest of this configuration to try out something
more lightweight and closer to vanilla Emacs.  This is where [[https://github.com/joaotavora/eglot][eglot]]
comes into play.

#+begin_src elisp
(use-package eglot
  :defer t)
#+end_src

** Better Emacs help and documentation

This gives us better and more readable help pages.  We also replace
some built-in =C-h= keybings with =helpful-*= functions.  FIXME: helpful
is broken as of February 2022; recheck frequently to see whether the
bug https://github.com/Wilfred/helpful/issues/282 is fixed.

#+begin_src elisp
(use-package helpful
  :after evil
  :bind (;; ("C-h f" . helpful-callable)
         ;; ("C-h v" . helpful-variable)
         ;; ("C-h k" . helpful-key)
         )
  :config
  (evil-set-initial-state 'helpful-mode 'motion))
#+end_src

** Project management

I've used [[https://github.com/bbatsov/projectile][projectile]] for a while.  It's great, but I found myself not
using most of its features.  Now that the built-in =project.el= has been
coming along great, I'm giving it a try.  I'm very happy with it so
far.

The following are utility functions that mostly rely on being in the
top-level directory of a known project.  =project.el= is making this
possible in a straightforward way.

#+begin_src elisp
(defun kenran/add-nix-envrc-file ()
  "If it doesn't already exist create a .envrc file containing 'use
nix' in the current directory."
  (interactive)
  (let ((envrc (expand-file-name ".envrc")))
    (if (file-exists-p envrc)
        (message "Envrc file already exists")
      (write-region "use nix" nil envrc))))

(defun kenran/project-vterm ()
  "Open a `vterm' session in the project root of the current
project.  Prompt if no project can be found."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (vterm)))

(defun kenran/project-edit-dir-local-variable (mode variable value)
  "Edit directory-local variables in the root directory of the
current project."
  (interactive
   ;; Taken from `add-dir-local-variable', as I don't know of a better
   ;; way to simply wrap that command.
   (let (variable)
     (require 'files-x)
     (list
      (read-file-local-variable-mode)
      (setq variable (read-file-local-variable "Add or edit directory-local variable"))
      (read-file-local-variable-value variable))))
  (let ((default-directory (project-root (project-current t))))
    (modify-dir-local-variable mode variable value 'add-or-replace)))
#+end_src

One tricky thing was making it possible to bind the keymap
=project-prefix-map= to a key.  One needs to make it callable via =fset=.

#+begin_src elisp
(use-package project
  :config
  (fset 'project-prefix-map project-prefix-map)
  (setq project-switch-commands
        '((project-find-file "Find file")
          (consult-ripgrep "Grep" ?g)
          (magit-status "Git status" ?v)
          (project-dired "Dired")
          (project-eshell "Eshell")
          (kenran/project-vterm "Vterm" ?t)))
  :bind (:map project-prefix-map
              ("t" . kenran/project-vterm)
              ("d" . project-dired)
              ("D" . kenran/project-edit-dir-local-variable)))

(with-leader
  "p" '(project-prefix-map :which-key "project"))
#+end_src

** Magit

#+begin_src elisp
(use-package magit
  :hook (git-commit-mode . evil-insert-state)
  :custom
  ;; No autosave for open buffers, as that might trigger hooks and
  ;; such.
  (magit-save-repository-buffers nil)
  (magit-diff-refine-hunk t)
  :config
  ;; I frequently pull with the autostash option.
  (transient-append-suffix 'magit-pull "-r"
    '("-a" "Autostash" "--autostash"))
  ;; ESC as alternative to C-g for going 'back' one transient level.
  (define-key transient-map [escape] #'transient-quit-one))
#+end_src

*** Show todos/fixmes/... in status buffers

=magit-todos= shows lists of the keywords of =hl-todo-mode= in
=magit-status= buffers, as well as in a dedicated list of todos
accessible with =magit-todos-list=.  Note: The items have to be followed
by a colon (more specifically, check out =magit-todos-keyword-suffix=).

#+begin_src elisp
(use-package magit-todos
  :after (magit hl-todo)
  :config
  (magit-todos-mode)
  (setq magit-todos-rg-extra-args '("-M 120")))
#+end_src

*** Interactively browse =git= history

#+begin_src elisp
(use-package git-timemachine
  :defer t)
#+end_src

*** Keybindings

=Magit=-specific keybindings are useful in a global scope, thus they may
be accessed under =SPC g=.

#+begin_src elisp
(with-leader
  "g" '(:ignore t :which-key "git")
  "g i" '(magit-gitignore :which-key "ignore")
  "g I" '(magit-init :which-key "init")
  "g s" '(magit-project-status :which-key "status")
  "g S" '(magit-status-here :which-key "status here")
  "g l" '(magit-log :which-key "log")
  "g f" '(magit-pull-from-upstream :which-key "pull")
  "g p" '(magit-push :which-key "pull")
  "g d" '(magit-dispatch :which-key "show dispatch popup")
  "g t" '(magit-todos-list :which-key "todos"))
#+end_src

*** VC annotations on the side

#+begin_src elisp
(use-package git-gutter
  :diminish git-gutter-mode
  :config
  (global-git-gutter-mode t))

(with-leader
  "g g" '(:ignore t :which-key "gutter")
  "g g n" 'git-gutter:next-hunk
  "g g p" 'git-gutter:previous-hunk)
#+end_src

** Auto-closing parentheses and other delimiters

Smartparens as a global minor mode works well for all programming
languages.  For lispy languages I probably want another solution and
tried several, but I'm not happy yet.

#+begin_src elisp
(use-package smartparens
  :diminish smartparens-mode
  :config
  (sp-pair "'" nil :actions nil)
  (sp-pair "`" nil :actions nil)
  (setq sp-highlight-pair-overlay nil)
  :init
  (smartparens-global-mode t)
  (show-smartparens-global-mode t))

(with-leader
  "c f" 'sp-indent-defun)
#+end_src

** Lispyville

#+begin_src elisp
(use-package lispyville
  :hook
  ((emacs-lisp-mode
    lisp-mode
    clojure-mode
    clojurec-mode
    clojurescript-mode
    common-lisp-mode
    racket-mode
    racket-repl-mode
    sly-mrepl-mode)
   . lispyville-mode)
  :config
  (with-eval-after-load 'lispyville
    (lispyville-set-key-theme
     '(operators
       c-w
       c-u
       prettify
       slurp/barf-cp
       text-objects
       additional-insert))))
#+end_src

** Highlight "todo", "fixme" and other keywords everywhere.

#+begin_src elisp
(use-package hl-todo
  :init
  (add-hook 'after-init-hook 'global-hl-todo-mode))
#+end_src

** Display commands bound to keys in the minibuffer

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src elisp
(use-package which-key
  :defer t
  :custom
  (which-key-idle-delay 0.3)
  :diminish which-key-mode
  :init
  (add-hook 'after-init-hook 'which-key-mode))
#+end_src

** Beautiful font icons

Attach beautiful symbols to, for instance, file names in a =dired= or
=ibuffer= buffer.

#+begin_src elisp
(use-package all-the-icons)

(use-package all-the-icons-dired
  :defer t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

(use-package all-the-icons-ibuffer
  :defer t
  :init
  (all-the-icons-ibuffer-mode 1))
#+end_src

** Annotate minibuffer completions

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in =C-h v=, file sizes
and permissions in =C-x C-f=, and much more.

#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode)
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit 'keep-selected))))
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle)))
#+end_src

** Make Emacs =direnv=-sensitive

Steve Purcell's [[https://github.com/purcell/envrc][envrc]] package is an alternative to [[https://github.com/wbolster/emacs-direnv][emacs-direnv]].  The
latter has a long-standing issue where it sometimes loads too late,
that is, /after/ packages like =lsp-mode= would need it.  =envrc= has worked
flawlessly so far.  Note: this should probably be one of the last
modes to load, as the hook function is then placed before the other
modes to ensure =direnv= integration is working as expected.

#+begin_src elisp
(use-package envrc
  :defer t
  :init (envrc-global-mode))
#+end_src

** Fast grepping via =ripgrep=

I use [[https://github.com/BurntSushi/ripgrep][ripgrep]] on the command line a lot.  This packages makes it
comfortably usable from within Emacs.

#+begin_src elisp
(use-package ripgrep
  :defer t)
#+end_src

** Interactive window switching

#+begin_src elisp
(use-package ace-window
  :defer t
  :init
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r))
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5))
#+end_src

*** Keybindings

=C-l= is a normal Emacs hotkey that I don't need or use because of =evil=,
and in the modes that I've disabled =evil= for I don't use it either.
It thus seems like a good choice to have as a fallback for window
management, as especially in terminal or shell modes I like being able
to use =C-w= like in a terminal or in vim.  I used to bind
='evil-window-map= to =C-l=, but perhaps it's also a good key to have
='ace-window= on as in most cases it's what I'd use anyway.

#+begin_src elisp
(general-define-key
 :states '(normal visual motion operator insert emacs)
 :keymaps 'override
 "C-l" 'ace-window)
#+end_src

** Hydra

TODO

#+begin_src elisp
(use-package hydra)
#+end_src

** Global font scaling

#+begin_src elisp
(use-package default-text-scale
  :defer t
  :after hydra
  :config
  (setq default-text-scale-amount 5))

(defhydra hydra-global-zoom (:hint nil :timeout 3)
  "
  Change the font size globally.\n
  _g_: increase
  _l_: decrease\n
  "
  ("g" default-text-scale-increase)
  ("l" default-text-scale-decrease)
  ("r" (lambda ()
         (interactive)
         (setq default-text-scale--complement 0)
         (face-spec-set 'default `((t (:height ,kenran/default-font-height))))
         (set-face-attribute 'default nil
                             :height kenran/default-font-height))
   "reset" :color blue)
  ("q" nil "exit"))

(with-leader
  "s s" '(hydra-global-zoom/body :which-key "font zoom"))
#+end_src

** Built-in packages
*** Display whitespace

Make whitespace symbols visible.

#+begin_src elisp
(use-package whitespace
  :config
  (setq whitespace-style
        '(face spaces tabs trailing lines-tail space-before-tab
          indentation empty space-after-tab space-mark tab-mark
          missing-newline-at-eof))
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode)))
#+end_src

*** Render manpages in Emacs

#+begin_src elisp
(use-package man
  :defer t
  :config
  ;; As soon as it is ready open the manpage in a separate, focused
  ;; window.
  (setq Man-notify-method 'aggressive))
#+end_src

*** Diminish only

#+begin_src elisp
(use-package face-remap
  :ensure nil
  :diminish buffer-face-mode)

(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode)
#+end_src

*** Don't trim ELisp evaluation results

#+begin_src elisp
(use-package simple
  :ensure nil
  :diminish auto-fill-function
  :config
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil))
#+end_src

*** ElDoc

#+begin_src elisp
(use-package eldoc
  :ensure nil
  :diminish eldoc-mode
  :config
  (advice-add 'eldoc-doc-buffer
              :after
              (defun kenran/focus-eldoc-buffer ()
                (message (buffer-name (current-buffer)))
                (pop-to-buffer eldoc--doc-buffer))))
#+end_src

*** Directory editor

#+begin_src elisp
(use-package dired
  :ensure nil
  :defer t
  :config
  (setq dired-kill-when-opening-new-dired-buffer t)
  (setq dired-create-destination-dirs 'ask)
  :custom
  ;; Sort directories to the top
  (dired-listing-switches "-la --group-directories-first"))
#+end_src

Beautify =dired= a bit.

#+begin_src elisp
(use-package diredfl
  :defer t
  :after dired
  :hook (dired-mode . diredfl-mode))
#+end_src

** Edit =grep= results over multiple buffers

#+begin_src elisp
(use-package wgrep
  :defer t
  :custom
  ((wgrep-auto-save-buffer t)
   (wgrep-change-readonly-file nil)
   (wgrep-too-many-file-length 15)))
#+end_src

** Improve garbage collector behavior

#+begin_src elisp
(use-package gcmh
  :diminish gcmh-mode
  :init
  (gcmh-mode 1))
#+end_src
