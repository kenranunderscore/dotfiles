#+TITLE: My GNU Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: show2levels indent

* Package management

I'm usually specifying the Emacs I'm using via [[https://github.com/nixos/nixpkgs][nixpkgs]] / my
[[https://github.com/nix-community/home-manager][home-manager]] setup, it's still useful to have MELPA accessible
directly in case something is broken in =nixpkgs=.  This seems to happen
rather often with packages from ELPA especially.

#+begin_src elisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+end_src

Install [[https://github.com/jwiegley/use-package][use-package]].  The =nixpkgs= version of Emacs on my systems
already contains most packages, including =use-package= itself, but when
self-compiling Emacs or on Windows I rely on =use-package= for the
installation of most/all the packages.

#+begin_src elisp
(unless (package-installed-p 'use-package)
  (package-install package))
#+end_src

Due the aforementioned setup I used to specify =:ensure nil= in my
=use-package= calls.  Now that I've run into lots of problems especially
with ELPA packages I want to have a fallback method.

#+begin_src elisp
(setq use-package-always-ensure t)
#+end_src

* Keybinding management

The [[https://github.com/noctuid/general][general]] package allows me to define keybindings in a more
straightforward and declarative way.  This is especially useful for
its =evil-mode= integration, where I have to bind keys according to the
current mode.

#+begin_src elisp
(use-package general)
#+end_src

Some additional and modified basic Emacs keybindings go here (evil-
and mode-specific ones can be found in the evil section or the one for
the respective mode).

#+begin_src elisp
(general-define-key
 :states '(normal visual motion emacs operator)
 "C-h F" 'describe-face
 "C-h M" 'describe-keymap
 "C-h V" 'set-variable)
#+end_src

* Loading additional ELisp configuration files

#+begin_src elisp
(defmacro kenran/load-config-file (file)
  "Load FILE relative to the .emacs.d directory."
  `(load (locate-user-emacs-file ,file)
         'no-error))
#+end_src

I do not want customizations done via =customize= to end up in this
file.  Use a separate file instead and load that one on startup.

#+begin_src elisp
(let ((my-custom-file (locate-user-emacs-file "custom.el")))
  (setq custom-file my-custom-file)
  (load custom-file 'no-error))
#+end_src

A quick way to get to my =init.el= file.  FIXME: This should be changed
when the switch to the literate config is complete.

#+begin_src elisp
(defun kenran/open-init-file ()
  "Open my init.el file."
  (interactive)
  (find-file (file-truename (locate-user-emacs-file "init.el"))))
#+end_src

This is where my custom ELisp files reside.

#+begin_src elisp
(setq kenran/lisp-dir (concat user-emacs-directory "lisp/"))
#+end_src

And this is where I put custom themes.

#+begin_src elisp
(setq custom-theme-directory (concat kenran/lisp-dir "themes/"))
#+end_src

Without loading the =f= package the following function won't work any
longer.  It must have broken at some point when I switched to Emacs
29, or some other package must have loaded it before I ever tried
opening any of my configuration files.

#+begin_src elisp
(require 'f)

(defun kenran/open-other-config-file (file)
  "Open FILE of the config files in the lisp directory."
  (interactive
   (list
    (completing-read
     "Config file: "
     (mapcar #'f-filename
             (f-files kenran/lisp-dir)))))
  (find-file (file-truename (concat kenran/lisp-dir file))))
#+end_src

A similar thing for opening custom theme files quickly.

#+begin_src elisp
(defun kenran/open-custom-theme-file (file)
  "Open FILE of the themes in `custom-theme-directory'."
  (interactive
   (list
    (completing-read
     "Theme: "
     (mapcar #'f-filename
             (f-files custom-theme-directory)))))
  (find-file (file-truename (concat custom-theme-directory file))))
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.
FIXME: port to literate config

#+begin_src elisp
(kenran/load-config-file "lisp/visuals.el")
#+end_src

* Basic options
** Startup

FIXME: Move some of the following to =early-init.el= instead.  See
Prot's configuration for inspiration and give credit.

I wish to know how fast my Emacs is starting.  I'm not sure how to
make use of all that =use-package= has to offer in that regard yet, but
I want to at least know when I've made things worse.

#+begin_src elisp
(add-hook
 'emacs-startup-hook
 (lambda ()
   (message
    "Emacs startup took %s with %d garbage collections"
    (format
     "%.2f seconds"
     (float-time (time-subtract after-init-time before-init-time)))
    gcs-done)))
#+end_src

Disable the graphical UI things like the tool and menu bars, the
splash screen, and others.

#+begin_src elisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(setq inhibit-splash-screen t)
#+end_src

Ignore the =X= resources.  Now Emacs doesn't use the terminal
background/foreground colors.

#+begin_src elisp
(setq inhibit-x-resources t)
#+end_src

** Focus popup buffers

Then I can close them with =q= immediately when I don't need them.  Most
often it's only for a quick lookup, like help buffers:

#+begin_src elisp
(setq help-window-select t)
#+end_src

Or =apropos= buffers:

#+begin_src elisp
(add-hook 'apropos-mode-hook
          (defun kenran/focus-apropos-buffer ()
            (pop-to-buffer (current-buffer))))
#+end_src

** Resize proportionally after deleting windows

#+begin_src elisp
(setq window-combination-resize t)
#+end_src

** Less annoying yes/no questions

The following setting enables answering those yes/no questions with
just =y= or =n=.

#+begin_src elisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode.  Note:
this doesn't work correctly yet, as =(command-modes 'some-command)=
seems to return the modes in an unexpected format.

#+begin_src elisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

I like to use a hybrid mode for displaying line numbers.  That is,
line numbers are shown in a relative way, but the current line
displays as its absolute line number.  But when switching to normal
mode, line numbers should all be absolute.  That's what these two
functions are used for.

#+begin_src elisp
(defun kenran/switch-to-absolute-line-numbers ()
  "Enable absolute line numbers."
  (interactive)
  (setq display-line-numbers t))

(defun kenran/switch-to-hybrid-line-numbers ()
  "Enable relative line numbers, but with the current line
showing its absolute line number."
  (interactive)
  (setq display-line-numbers 'relative)
  (setq display-line-numbers-current-absolute t))
#+end_src

To display line numbers, the aptly named =display-line-numbers= package
is used.  It's enabled by default in all programming modes.

#+begin_src elisp
(use-package display-line-numbers
  :config
  (setq display-line-numbers-type 'relative)
  (setq display-line-numbers-current-absolute t)
  :hook ((prog-mode . display-line-numbers-mode)
         (conf-mode . display-line-numbers-mode)
         (evil-insert-state-entry . kenran/switch-to-absolute-line-numbers)
         (evil-insert-state-exit . kenran/switch-to-hybrid-line-numbers)))
#+end_src

Show column numbers in the modeline.

#+begin_src elisp
(column-number-mode)
#+end_src

** Insert a newline at the end of files

#+begin_src elisp
(setq require-final-newline t)
(setq mode-require-final-newline t)
#+end_src

** Suppress warning from native compilation

When using Emacs =HEAD= (with the merged =native-comp= branch) a lot of
warnings show up during startup and when changing modes.  We could
increase the minimum severity for logs to be shown by setting
=warning-minimum-level= to =:error,= or just disable the warnings for
native compilation entirely like this:

#+begin_src elisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** Spaces over tabs

#+begin_src elisp
(setq-default indent-tabs-mode nil)
#+end_src

** File name searches should be case-insensitive

#+begin_src elisp
(setq read-file-name-completion-ignore-case t)
#+end_src

* Vim emulation

** Leader keys

Having a dedicated leader key (=SPC= in my case) is one of the most
important things to me as it opens up a lot of possibilities for
creating custom keymaps.  The keybindings naturally do not clash with
the default Emacs-style bindings many packages introduce.  I will use
this to try and create more vim-inspired mnemonic keybindings (say, =p=
for project-specific commands, =g= for git etc.)

In general I try to keep package-specific keybindings next to the
configuration of the respective packages.  However with =use-package=
there seems to be a =:general= keyword, which probably works similar to
the =:bind= one.  I sometimes use the latter for bindings that are not
mode-sensitive.

#+begin_src elisp
(general-create-definer with-leader
  :keymaps 'override
  :states '(normal insert emacs visual motion)
  :prefix "SPC"
  :non-normal-prefix "C-SPC")
#+end_src

A local leader key is something that is usually used to access
situational commands, for instance language-specific or mode-specific
ones.  I used =,= for this in Vim; same here now.

#+begin_src elisp
(general-create-definer with-local-leader
  :prefix ",")
#+end_src

** Non-evil ("holy") modes

This is a list of modes that I do not want =evil= mode (defined below)
to be enabled in by default.  It's mostly a preference of mine to use
Emacs mode in REPL, terminal and shell buffers.

#+begin_src elisp
(setq kenran/holy-modes
      '((ediff . ediff)
        (eshell-mode . eshell)
        (mu4e . mu4e)
        (mu4e . mu4e-conversation)
        (notmuch-hello-mode . notmuch)
        (racket-repl-mode . nil)
        (racket-stepper-mode . nil)
        (shell-mode . nil)
        (sly-mrepl-mode . nil)
        (term-mode . (term term ansi-term multi-term))
        (vterm-mode . vterm)
        (haskell-interactive-mode . nil)))

(setq kenran/evil-holy-modes
      (mapcar #'car kenran/holy-modes))

(setq kenran/evil-collection-exemptions
      (remove nil
              (mapcar #'cdr kenran/holy-modes)))
#+end_src

** =Evil= and supporting packages

The evil package offers a very complete vim experience inside of
Emacs.

#+begin_src elisp
(use-package evil
  :config
  (evil-mode 1)
  (dolist (mode kenran/evil-holy-modes)
    (evil-set-initial-state mode 'emacs))
  :custom
  ((evil-want-C-u-scroll t)
   (evil-want-C-u-delete nil)
   (evil-want-C-w-delete t)
   (evil-want-Y-yank-to-eol t)
   (evil-undo-system 'undo-redo)
   (evil-symbol-word-search t))
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (add-hook 'server-after-make-frame-hook
            #'kenran/set-evil-state-cursors))
#+end_src

*** Evilify nearly everything (=evil-collection=)

This package makes it possible to enable =evil= in lots of (mostly
minor) modes.  This usually includes some sort of streamlined
keybinding scheme, where the vim movement keys =h=, =j=, =k=, =l=, and often
=C-j= and =C-k= are used for navigation.

However, I've been in the situation where "something didn't quite
work" quite some times, and =evil-collection= has often been the
culprit.  Checking =evil-collection-mode-list= to see whether any
current mode was evilified with =evil-collection=, and subsequently
removing them from this list, has often fixed some problems (for
instance with =mu4e=).

#+begin_src elisp
(use-package evil-collection
  :after evil
  :config
  (dolist (x kenran/evil-collection-exemptions)
    (delete x evil-collection-mode-list))
  (evil-collection-init)
  (evil-collection-inhibit-insert-state 'notmuch-hello-mode-map)
  :custom
  ((evil-collection-company-use-tng t)
   (evil-collection-want-unimpaired-p nil)))
#+end_src

*** Surrounding things

The analogue of [[https://github.com/tpope/vim-surround][Tim Pope's vim-surround plugin]] in Emacs.  Now I can
use things like =ysiw)= to surround an inner word with non-padded normal
parentheses, =ds]= to delete surrounding brackets, or =cs[{= to change
surrounding brackets to curly braces with whitespace padding.
Selected regions can be surround with e.g. =S`=.

#+begin_src elisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode))
#+end_src

*** 2-character searching in one line

[[https://github.com/hlissner/evil-snipe][Henrik Lissner's evil-snipe]] replaces the default vim =s= binding by a
2-character incremental forward/backward search.  In addition,
=evil-snipe-override-mode= makes the =f=, =F=, =t=, and =T= searches repeatable
by pressing the respective key again to jump by one match.  It also
adds highlighting to those motions.

It's also possible to configure/increase the scope of these searches,
but for the moment I'm content with just using it on one line.

#+begin_src elisp
(use-package evil-snipe
  :after evil
  :diminish evil-snipe-local-mode
  :config
  (evil-snipe-mode 1)
  (evil-snipe-override-mode 1))
#+end_src

*** Evilify =org=

=Evil-org= enables me to use =evil= keybindings in =org-agenda=.  As a bonus
it adds some keybindings and text objects for =org= files as well.

TODO: It's surely worth spending some more time to find out what else
this brings with it, but I'm not writing enough with =org=

#+begin_src elisp
(use-package evil-org
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src

*** Highlight vim marks

#+begin_src elisp
(use-package evil-visual-mark-mode
  :defer t
  :after evil
  :init (evil-visual-mark-mode))
#+end_src

** Keybindings

Create nice custom mappings for normal mode (and others) that are
accessed with the leader key, =SPC=.

#+begin_src elisp
(with-leader
  ;; Give SPC SPC one more chance
  "SPC" '(execute-extended-command :which-key "M-x")
  ;; Different ways to quit Emacs
  "q" '(:ignore t :which-key "quit")
  "q f" 'evil-save-and-quit
  "q k" 'save-buffers-kill-emacs
  ;; Buffer-related commands
  "b" '(:ignore t :which-key "buffer")
  "b b" 'consult-buffer
  "b q" 'kill-current-buffer
  "b i" 'ibuffer
  "b k" 'kill-buffer
  "b n" 'next-buffer
  "b p" 'previous-buffer
  ;; Toggles/switches
  "t" '(:ignore t :which-key "toggle/switch")
  "t l" '(display-line-numbers-mode :which-key "line numbers")
  "t t" '(kenran/switch-theme :which-key "switch theme")
  "t r" '(kenran/reload-theme :which-key "reload theme")
  "t f" '(kenran/switch-font :which-key "switch font")
  "t w" 'global-whitespace-mode
  ;; Language-agnostic code-related commands
  "c" '(:ignore t :which-key "code")
  "c l" 'comment-line
  "c r" 'comment-or-uncomment-region
  ;; Searching
  "s" '(:ignore t :which-key "search/switch")
  "s g" 'consult-git-grep
  "s p" 'consult-ripgrep
  ;; Window management (redundant)
  "w" '(evil-window-map :which-key "windows")
  ;; Emacs config
  "e" '(:ignore t :which-key "emacs")
  "e e" '(kenran/open-init-file :which-key "edit init.el")
  "e c" '(kenran/open-other-config-file :which-key "edit other config file")
  "e t" '(kenran/open-custom-theme-file :which-key "edit custom theme")
  ;; Additional help commands
  "h" '(:ignore t :which-key "help")
  "h m" 'man)
#+end_src

*** =C-w=

Enable =C-w= for vim-like window management (when not in insert or Emacs
mode).  This means that I need to override the Emacs default binding,
which can be done via =general='s =:keymaps 'override=.

#+begin_src elisp
(general-define-key
 :states '(normal visual motion operator)
 :keymaps 'override
 "C-w" 'evil-window-map
 "C-w C-h" 'evil-window-left
 "C-w C-k" 'evil-window-up
 "C-w C-j" 'evil-window-down
 "C-w C-l" 'evil-window-right
 "C-w C-d" 'evil-quit)
#+end_src

Enable =C-w= to delete backward (like in vim or bash) in insert mode,
and also when Emacs is reading user input in the minibuffer.

#+begin_src elisp
(general-define-key
 :keymaps 'minibuffer-local-map
 "C-w" 'evil-delete-backward-word)

(general-define-key
 :states '(emacs)
 "C-w" 'evil-delete-backward-word)
#+end_src

* Incremental narrowing

I started with =helm= in [[https://www.spacemacs.org/][spacemacs]], then later switched to [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
where after a while I tried out =ivy= and loved it.  Configuring Emacs
from scratch was when I decided to try out some of the newer, more
lightweight Emacs packages like [[https://github.com/raxod502/selectrum][selectrum]] and [[https://github.com/minad/vertico][vertico]].  Those
integrate very well with default Emacs functionality, so a lot of
things can utilize them "implicitly".  I've stuck with =vertico= and
I've been happy with it ever since.

#+begin_src elisp
(use-package vertico
  :init
  (vertico-mode +1)
  :custom
  (vertico-cycle t)
  :bind
  (:map vertico-map
        ("C-w" . evil-delete-backward-word)))
#+end_src

=savehist-mode= keeps a history of commands and inputs I've done in a
context-sensitive way, and then shows those at the top when presented
with possible results from =vertico=.

#+begin_src elisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][orderless]] is a /completion style/ that fits in very well with =vertico=
(or =selectrum=, for that matter).  Parts of a search string may match
according to several matching styles.  We want to be able to specify
which matching style to use by appending a suffix so a search string.
Therefore we define style dispatchers and use them to customize
=orderless-style-dispatchers=.

Prepending an equals sign to a search term will search for literal
matches of the preceding string.

#+begin_src elisp
(defun kenran/literal-if-= (pattern _index _total)
  (when (string-prefix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 1))))
#+end_src

A prepended bang discards everything that matches the preceding
literal string.

#+begin_src elisp
(defun kenran/without-if-! (pattern _index _total)
  (when (string-prefix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

The tilde sign gives me a way to have "fuzzy" search, if needed.

#+begin_src elisp
(defun kenran/flex-if-~ (pattern _index _total)
  (when (string-prefix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 1))))
#+end_src

#+begin_src elisp
(use-package orderless
  :custom (completion-styles '(orderless))
  (orderless-style-dispatchers
   '(kenran/literal-if-=
     kenran/without-if-!
     kenran/flex-if-~)))
#+end_src

** Consult

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite
some time, though not in any extent close to full.  This defines some
basic bindings mostly taken from an example in its readme.

#+begin_src elisp
(use-package consult
  :bind (;; C-x bindings
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ;; C-h bindings (help)
         ("C-h a" . consult-apropos)
         ;; M-g bindings (goto)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ;; M-s bindings (search)
         ("M-s f" . consult-find)
         ("M-s L" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines))
  :custom
  (consult-project-root-function
   (lambda ()
     (when-let (project (project-current))
       (project-root project)))))
;; TODO other isearch integration?
;; TODO :init narrowing, preview delay
#+end_src

** Minibuffer actions

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet.  It seems to be amazing, though!
What I mostly use it for at the moment is its =embark-act= command in
conjunction with =embark-export=.  With this I often pull the results of
some =grep= command into a separate buffer, where I can then utilize
=wgrep= to bulk-modify the original buffers.

#+begin_src elisp
(use-package embark
  :bind (("C-," . embark-act)
         ("C-h B" . embark-bindings))
  :init
  (setq prefix-help-command #'embark-prefix-help-command))
#+end_src

Integrate =embark= with =consult=.

#+begin_src elisp
(use-package embark-consult
  :after (embark consult)
  :demand t
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

* Auto-completion popups

[[https://company-mode.github.io/][company-mode]] provides textual auto-completions in nearly every
context.  There are lots of backends that can be used for
context-sensitiv completion, but I don't make use of those really
(yet).

#+begin_src elisp
(use-package company
  :hook ((after-init . global-company-mode))
  :diminish company-mode
  :init
  ;; Without this orderless would be used by default for company
  ;; completions.  It doesn't fit there as well though.
  (define-advice company-capf
      (:around (orig-fun &rest args) set-completion-styles)
    (let ((completion-styles '(basic partial-completion)))
      (apply orig-fun args)))
  :custom
  ((company-idle-delay 0)
   (company-selection-wrap-around t)
   (company-minimum-prefix-length 4))
  :bind
  (:map company-active-map
        ("C-w" . evil-delete-backward-word)))
#+end_src

This is a workaround for using =company= together with =whitespace-mode=.
Seeing the whitespace marks in the popup is quite annoying, but this
makes it manageable.  See
https://github.com/company-mode/company-mode/issues/1231.

#+begin_src elisp
(defun company--replacement-with-ws-face (str)
  (if (and (or global-whitespace-mode whitespace-mode)
           (memq 'space-mark whitespace-active-style)
           (memq 'face whitespace-active-style)
           (memq 'spaces whitespace-active-style))
      (let ((face `(:foreground ,(face-attribute 'whitespace-space :foreground))))
        (replace-regexp-in-string
         " "
         (lambda (s)
           (setq s (copy-sequence s))
           (add-face-text-property 0 (length s) face nil s)
           s)
         str))
    str))

(advice-add #'company--replacement-string
            :filter-return
            #'company--replacement-with-ws-face)
#+end_src
* E-Mail configuration

#+begin_src elisp
(kenran/load-config-file "lisp/email.el")
#+end_src

* Package-specific configuration
** Hide minor modes from the modeline

The =diminish= package enables us to hide minor modes from the modeline.
It's especially useful for certain modes that are globally enabled
anyway.  =Use-package= has built-in support for this available with the
=:diminish= keyword.

#+begin_src elisp
(use-package diminish)
#+end_src

** Mode-specific code snippets

#+begin_src elisp
(use-package yasnippet
  :init (yas-global-mode 1)
  :diminish yas-minor-mode)
#+end_src

** Terminal emulator in Emacs

=vterm= is a terminal emulator for Emacs, more feature-rich than the
built-in =term=.  This is very useful for quickly spawning a terminal,
for instance in the at the top-level directory of a project.

#+begin_src elisp
(use-package vterm
  :defer t
  :config
  (setq vterm-shell "fish")
  (general-define-key
   :keymaps 'vterm-mode-map
   :states 'emacs
   "C-w" 'vterm-send-C-w))
#+end_src

** Ini files

I'm not 100 percent happy with this package, as paragraphs seem to be
acting strange.  Deleting a paragraph via =dap= for instance often
deletes the following one, too, plus sometimes the previous section
header.

#+begin_src elisp
(use-package ini-mode
  :defer t)
#+end_src

** JavaScript

#+begin_src elisp
(use-package js
  :defer t
  :config
  (setq js-indent-level 2))
#+end_src

** Purescript

#+begin_src elisp
(use-package psc-ide
  :hook (purescript-mode . psc-ide-mode)
  :config
  (setq psc-ide-rebuild-on-save t))

(use-package purescript-mode
  :hook (purescript-mode . turn-on-purescript-indentation))
#+end_src

** Nix

#+begin_src elisp
(use-package nix-mode
  :mode "\\.nix\\'"
  :hook (before-save . nix-format-before-save))
#+end_src

** Markdown

#+begin_src elisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc")
  :hook ((markdown-mode gfm-mode) . auto-fill-mode))
#+end_src

** Org mode

I use =org= for lots of things now, but have only recently started doing
so, hence my configuration is very much a work in progress.

FIXME: document and integrate

#+begin_src elisp
(kenran/load-config-file "lisp/org.el")
#+end_src

** Haskell

FIXME: document and integrate

#+begin_src elisp
(kenran/load-config-file "lisp/haskell.el")
#+end_src

** Dhall

#+begin_src elisp
(use-package dhall-mode
  :mode "\\.dhall\\'"
  :config
  (setq dhall-type-check-inactivity-timeout 2))
#+end_src

** Docker

#+begin_src elisp
(use-package dockerfile-mode
  :defer t)
#+end_src

** YAML

#+begin_src elisp
(use-package yaml-mode
  :defer t)
#+end_src

** Clojure

The key to using Clojure effectively with Emacs seems to be [[https://github.com/clojure-emacs/cider][CIDER]].

#+begin_src elisp
(use-package clojure-mode
  :defer t)

(use-package cider
  :after clojure-mode
  :defer t)
#+end_src

** CSV

#+begin_src elisp
(use-package csv-mode
  :defer t)
#+end_src

** PlantUML

#+begin_src elisp
(use-package plantuml-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist
               '("\\.\\(plantuml\\|puml\\)\\'" . plantuml-mode))
  :config
  (setq plantuml-default-exec-mode 'executable))
#+end_src

** Common Lisp

[[https://github.com/joaotavora/sly][SLY]] seems to be a bit more actively developed and modern than [[https://slime.common-lisp.dev/][SLIME]].

#+begin_src elisp
(use-package sly
  :defer t
  :config
  (setq inferior-lisp-program "sbcl"))
#+end_src

=sly-asdf= gives integration with Common Lisp's package manager, [[https://asdf.common-lisp.dev/][ASDF]].

#+begin_src elisp
(use-package sly-asdf
  :defer t)
#+end_src

** Racket

#+begin_src elisp
(use-package racket-mode
  :defer t
  :hook ((racket-mode . racket-xp-mode)
         (racket-mode . racket-unicode-input-method-enable)
         (racket-repl-mode . racket-unicode-input-method-enable)))
#+end_src

** Java

I don't use Java, but Bob Nystrom's excellent and free book [[https://craftinginterpreters.com/][Crafting
Interpreters]] uses it for the first part.  It's actually quite OK to
write Java with =meghanada,= but it takes a long time to download all
its dependencies.

#+begin_src elisp
(use-package meghanada
  :defer t
  :init
  (add-hook 'java-mode-hook
            (lambda ()
              (meghanada-mode t)
              (flycheck-mode +1)
              (setq c-basic-offset 2)
              (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))))
#+end_src

** Python

#+begin_src elisp
(use-package anaconda-mode
  :defer t
  :hook (python-mode . anaconda-mode))

(use-package pyimport
  :defer t)
#+end_src

** Nim

#+begin_src elisp
(use-package nim-mode
  :defer t)
#+end_src

** F#

#+begin_src elisp
(use-package fsharp-mode
  :defer t
  :config
  (setq fsharp-indent-offset 2)
  (setq fsharp-continuation-offset 2)
  (setq inferior-fsharp-program "dotnet fsi --readline-"))
#+end_src

** LSP integration

I've used =lsp-mode= in the past and while it's nice, I feel like it's
more in line with the rest of this configuration to try out something
more lightweight and closer to vanilla Emacs.  This is where [[https://github.com/joaotavora/eglot][eglot]]
comes into play.

#+begin_src elisp
(use-package eglot
  :defer t)
#+end_src

** Better Emacs help and documentation

This gives us better and more readable help pages.  We also replace
some built-in =C-h= keybings with =helpful-*= functions.  FIXME: helpful
is broken as of February 2022; recheck frequently to see whether the
bug https://github.com/Wilfred/helpful/issues/282 is fixed.

#+begin_src elisp
(use-package helpful
  :after evil
  :bind (;; ("C-h f" . helpful-callable)
         ;; ("C-h v" . helpful-variable)
         ;; ("C-h k" . helpful-key)
         )
  :config
  (evil-set-initial-state 'helpful-mode 'motion))
#+end_src

** Project management

I've used [[https://github.com/bbatsov/projectile][projectile]] for a while.  It's great, but I found myself not
using most of its features.  Now that the built-in =project.el= has been
coming along great, I'm giving it a try.  I'm very happy with it so
far.

The following are utility functions that mostly rely on being in the
top-level directory of a known project.  =project.el= is making this
possible in a straightforward way.

#+begin_src elisp
(defun kenran/add-nix-envrc-file ()
  "If it doesn't already exist create a .envrc file containing 'use
nix' in the current directory."
  (interactive)
  (let ((envrc (expand-file-name ".envrc")))
    (if (file-exists-p envrc)
        (message "Envrc file already exists")
      (write-region "use nix" nil envrc))))

(defun kenran/project-vterm ()
  "Open a `vterm' session in the project root of the current
project.  Prompt if no project can be found."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (vterm)))

(defun kenran/project-edit-dir-local-variable (mode variable value)
  "Edit directory-local variables in the root directory of the
current project."
  (interactive
   ;; Taken from `add-dir-local-variable', as I don't know of a better
   ;; way to simply wrap that command.
   (let (variable)
     (require 'files-x)
     (list
      (read-file-local-variable-mode)
      (setq variable (read-file-local-variable "Add or edit directory-local variable"))
      (read-file-local-variable-value variable))))
  (let ((default-directory (project-root (project-current t))))
    (modify-dir-local-variable mode variable value 'add-or-replace)))
#+end_src

One tricky thing was making it possible to bind the keymap
=project-prefix-map= to a key.  One needs to make it callable via =fset=.

#+begin_src elisp
(use-package project
  :config
  (fset 'project-prefix-map project-prefix-map)
  (setq project-switch-commands
        '((project-find-file "Find file")
          (consult-ripgrep "Grep" ?g)
          (magit-status "Git status" ?v)
          (project-dired "Dired")
          (project-eshell "Eshell")
          (kenran/project-vterm "Vterm" ?t)))
  :bind (:map project-prefix-map
              ("t" . kenran/project-vterm)
              ("d" . project-dired)
              ("D" . kenran/project-edit-dir-local-variable)))

(with-leader
  "p" '(project-prefix-map :which-key "project"))
#+end_src

** Magit

#+begin_src elisp
(use-package magit
  :hook (git-commit-mode . evil-insert-state)
  :custom
  ;; No autosave for open buffers, as that might trigger hooks and
  ;; such.
  (magit-save-repository-buffers nil)
  (magit-diff-refine-hunk t)
  :config
  ;; I frequently pull with the autostash option.
  (transient-append-suffix 'magit-pull "-r"
    '("-a" "Autostash" "--autostash"))
  ;; ESC as alternative to C-g for going 'back' one transient level.
  (define-key transient-map [escape] #'transient-quit-one))
#+end_src

*** Show todos/fixmes/... in status buffers

=magit-todos= shows lists of the keywords of =hl-todo-mode= in
=magit-status= buffers, as well as in a dedicated list of todos
accessible with =magit-todos-list=.  Note: The items have to be followed
by a colon (more specifically, check out =magit-todos-keyword-suffix=).

#+begin_src elisp
(use-package magit-todos
  :after (magit hl-todo)
  :config
  (magit-todos-mode)
  (setq magit-todos-rg-extra-args '("-M 120")))
#+end_src

*** Interactively browse =git= history

#+begin_src elisp
(use-package git-timemachine
  :defer t)
#+end_src

*** Keybindings

=Magit=-specific keybindings are useful in a global scope, thus they may
be accessed under =SPC g=.

#+begin_src elisp
(with-leader
  "g" '(:ignore t :which-key "git")
  "g i" '(magit-gitignore :which-key "ignore")
  "g I" '(magit-init :which-key "init")
  "g s" '(magit-project-status :which-key "status")
  "g S" '(magit-status-here :which-key "status here")
  "g l" '(magit-log :which-key "log")
  "g f" '(magit-pull-from-upstream :which-key "pull")
  "g p" '(magit-push :which-key "pull")
  "g d" '(magit-diff :which-key "diff")
  "g t" '(magit-todos-list :which-key "todos"))
#+end_src

*** VC annotations on the side

#+begin_src elisp
(use-package git-gutter
  :diminish git-gutter-mode
  :config
  (global-git-gutter-mode t))

(with-leader
  "g g" '(:ignore t :which-key "gutter")
  "g g n" 'git-gutter:next-hunk
  "g g p" 'git-gutter:previous-hunk)
#+end_src

** Auto-closing parentheses and other delimiters

Smartparens as a global minor mode works well for all programming
languages.  For lispy languages I probably want another solution and
tried several, but I'm not happy yet.

#+begin_src elisp
(use-package smartparens
  :diminish smartparens-mode
  :config
  (sp-pair "'" nil :actions nil)
  (sp-pair "`" nil :actions nil)
  (setq sp-highlight-pair-overlay nil)
  :init
  (smartparens-global-mode t)
  (show-smartparens-global-mode t))

(with-leader
  "c f" 'sp-indent-defun)
#+end_src

** Lispyville

#+begin_src elisp
(use-package lispyville
  :hook
  ((emacs-lisp-mode
    lisp-mode
    clojure-mode
    clojurec-mode
    clojurescript-mode
    common-lisp-mode
    racket-mode
    racket-repl-mode
    sly-mrepl-mode)
   . lispyville-mode)
  :config
  (with-eval-after-load 'lispyville
    (lispyville-set-key-theme
     '(operators
       c-w
       c-u
       prettify
       slurp/barf-cp
       text-objects
       additional-insert))))
#+end_src

** Highlight "todo", "fixme" and other keywords everywhere.

#+begin_src elisp
(use-package hl-todo
  :init
  (add-hook 'after-init-hook 'global-hl-todo-mode))
#+end_src

** Display commands bound to keys in the minibuffer

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src elisp
(use-package which-key
  :defer t
  :custom
  (which-key-idle-delay 0.3)
  :diminish which-key-mode
  :init
  (add-hook 'after-init-hook 'which-key-mode))
#+end_src

** Beautiful font icons

Attach beautiful symbols to, for instance, file names in a =dired= or
=ibuffer= buffer.

#+begin_src elisp
(use-package all-the-icons)

(use-package all-the-icons-dired
  :defer t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

(use-package all-the-icons-ibuffer
  :defer t
  :init
  (all-the-icons-ibuffer-mode 1))
#+end_src

** Annotate minibuffer completions

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in =C-h v=, file sizes
and permissions in =C-x C-f=, and much more.

#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode)
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit 'keep-selected))))
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle)))
#+end_src

** Make Emacs =direnv=-sensitive

Steve Purcell's [[https://github.com/purcell/envrc][envrc]] package is an alternative to [[https://github.com/wbolster/emacs-direnv][emacs-direnv]].  The
latter has a long-standing issue where it sometimes loads too late,
that is, /after/ packages like =lsp-mode= would need it.  =envrc= has worked
flawlessly so far.  Note: this should probably be one of the last
modes to load, as the hook function is then placed before the other
modes to ensure =direnv= integration is working as expected.

#+begin_src elisp
(use-package envrc
  :defer t
  :init (envrc-global-mode))
#+end_src

** Fast grepping via =ripgrep=

I use [[https://github.com/BurntSushi/ripgrep][ripgrep]] on the command line a lot.  This packages makes it
comfortably usable from within Emacs.

#+begin_src elisp
(use-package ripgrep
  :defer t)
#+end_src

** Interactive window switching

#+begin_src elisp
(use-package ace-window
  :defer t
  :init
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r))
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5))
#+end_src

*** Keybindings

=C-l= is a normal Emacs hotkey that I don't need or use because of =evil=,
and in the modes that I've disabled =evil= for I don't use it either.
It thus seems like a good choice to have as a fallback for window
management, as especially in terminal or shell modes I like being able
to use =C-w= like in a terminal or in vim.  I used to bind
='evil-window-map= to =C-l=, but perhaps it's also a good key to have
='ace-window= on as in most cases it's what I'd use anyway.

#+begin_src elisp
(general-define-key
 :states '(normal visual motion operator insert emacs)
 :keymaps 'override
 "C-l" 'ace-window)
#+end_src

** Hydra

TODO

#+begin_src elisp
(use-package hydra)
#+end_src

** Global font scaling

#+begin_src elisp
(use-package default-text-scale
  :defer t
  :after hydra
  :config
  (setq default-text-scale-amount 5))

(defhydra hydra-global-zoom (:hint nil :timeout 3)
  "
  Change the font size globally.\n
  _g_: increase
  _l_: decrease\n
  "
  ("g" default-text-scale-increase)
  ("l" default-text-scale-decrease)
  ("r" (lambda ()
         (interactive)
         (setq default-text-scale--complement 0)
         (face-spec-set 'default `((t (:height ,kenran/default-font-height))))
         (set-face-attribute 'default nil
                             :height kenran/default-font-height))
   "reset" :color blue)
  ("q" nil "exit"))

(with-leader
  "s s" '(hydra-global-zoom/body :which-key "font zoom"))
#+end_src

** Built-in packages
*** Display whitespace

Make whitespace symbols visible.

#+begin_src elisp
(use-package whitespace
  :config
  (setq whitespace-style
        '(face spaces tabs trailing lines-tail space-before-tab
          indentation empty space-after-tab space-mark tab-mark
          missing-newline-at-eof))
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode)))
#+end_src

*** Render manpages in Emacs

#+begin_src elisp
(use-package man
  :defer t
  :config
  ;; As soon as it is ready open the manpage in a separate, focused
  ;; window.
  (setq Man-notify-method 'aggressive))
#+end_src

*** Diminish only

#+begin_src elisp
(use-package face-remap
  :ensure nil
  :diminish buffer-face-mode)

(use-package autorevert
  :ensure nil
  :diminish auto-revert-mode)
#+end_src

*** Don't trim ELisp evaluation results

#+begin_src elisp
(use-package simple
  :ensure nil
  :diminish auto-fill-function
  :config
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil))
#+end_src

*** ElDoc

#+begin_src elisp
(use-package eldoc
  :ensure nil
  :diminish eldoc-mode
  :config
  (advice-add 'eldoc-doc-buffer
              :after
              (defun kenran/focus-eldoc-buffer ()
                (message (buffer-name (current-buffer)))
                (pop-to-buffer eldoc--doc-buffer))))
#+end_src

*** Directory editor

#+begin_src elisp
(use-package dired
  :ensure nil
  :defer t
  :config
  (setq dired-kill-when-opening-new-dired-buffer t)
  (setq dired-create-destination-dirs 'ask)
  :custom
  ;; Sort directories to the top
  (dired-listing-switches "-la --group-directories-first"))
#+end_src

Beautify =dired= a bit.

#+begin_src elisp
(use-package diredfl
  :defer t
  :after dired
  :hook (dired-mode . diredfl-mode))
#+end_src

** Edit =grep= results over multiple buffers

#+begin_src elisp
(use-package wgrep
  :defer t
  :custom
  ((wgrep-auto-save-buffer t)
   (wgrep-change-readonly-file nil)
   (wgrep-too-many-file-length 15)))
#+end_src

** Improve garbage collector behavior

#+begin_src elisp
(use-package gcmh
  :diminish gcmh-mode
  :init
  (gcmh-mode 1))
#+end_src
