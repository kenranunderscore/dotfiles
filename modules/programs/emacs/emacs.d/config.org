#+TITLE: My GNU Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: show2levels indent

* Package management

I'm specifying the Emacs I'm using via [[https://github.com/nixos/nixpkgs][nixpkgs]] / my [[https://github.com/nix-community/home-manager][home-manager]]
setup, but for package management I'm currently test driving
[[https://github.com/radian-software/straight.el][straight.el]].  Having the packages come from =nixpkgs= (marked as
=external= in =list-packages=) is nice, but requires a =nixos-rebuild= and
restarting Emacs after making some changes.  =straight.el= should make
the process of quickly trying out packages much simpler, and
afterwards they're neither gone nor silently "leaking" (i.e.,
automatically loaded even though I don't use them anymore) into Emacs.

The script below is taken right from =straight.el='s readme.

#+begin_src elisp
(defvar bootstrap-version)

(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Install [[https://github.com/jwiegley/use-package][use-package]].  The =nixpkgs= version of Emacs on my systems
already contains most packages, including =use-package= itself, but when
self-compiling Emacs or on Windows I rely on =use-package= for the
installation of most/all the packages.

#+begin_src elisp
(straight-use-package 'use-package)
#+end_src

Now make every =use-package= block below behave as if I had specified
=:straight t= by default.  Note that this requires me to handle
configuration of built-in packages explicitly, usually by adding
=:straight (:type built-in)=.

#+begin_src elisp
(setq straight-use-package-by-default t)
#+end_src

* Keybinding management

The [[https://github.com/noctuid/general][general]] package allows me to define keybindings in a more
straightforward and declarative way.  This is especially useful for
its =evil-mode= integration, where I have to bind keys according to the
current mode.

#+begin_src elisp
(use-package general)
#+end_src

Some additional and modified basic Emacs keybindings go here (evil-
and mode-specific ones can be found in the evil section or the one for
the respective mode).

#+begin_src elisp
(general-define-key
 :states '(normal visual motion emacs operator)
 "C-h F" 'describe-face
 "C-h M" 'describe-keymap
 "C-h V" 'set-variable)
#+end_src

* Loading additional ELisp configuration files

#+begin_src elisp
(defmacro kenran/load-config-file (file)
  "Load FILE relative to the .emacs.d directory."
  `(load (locate-user-emacs-file ,file)
         'no-error))
#+end_src

I do not want customizations done via =customize= to end up in this
file.  Use a separate file instead and load that one on startup.

#+begin_src elisp
(let ((my-custom-file (locate-user-emacs-file "custom.el")))
  (setq custom-file my-custom-file)
  (load custom-file 'no-error))
#+end_src

A quick way to get to my =init.el= file.  FIXME: This should be changed
when the switch to the literate config is complete.

#+begin_src elisp
(defun kenran/open-init-file ()
  "Open my config.org file."
  (interactive)
  (find-file (file-truename (locate-user-emacs-file "config.org"))))
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.

One thing to pay attention to is that nearly all those operations on
"visuals" work slightly differently when starting Emacs as
=emacsclient=, for instance via

#+begin_src shell :tangle no
emacsclient -a ''
#+end_src

Setting some things at this point often results in the changes not
being applied correctly.  I think it's due to them happening in a
technical, visible Emacs frame.  See also
=kenran/is-initial-daemon-frame= below.

** Cursor

The default cursor is black, which interferes with mostly using a dark
theme.  Brighten it up a bit.

#+begin_src elisp
(set-mouse-color "white")
(add-hook 'server-after-make-frame-hook
          (lambda () (set-mouse-color "white")))
#+end_src

Enable a forever-blinking cursor.  I used to disable this mode but I
found myself searching for the cursor a couple of times lately.

#+begin_src elisp
(setq blink-cursor-delay 0.5)
(setq blink-cursor-blinks -1)
(blink-cursor-mode 1)
#+end_src

Don't show a cursor in inactive windows.  The default, hollow cursor
in inactive windows changes colors when switching evil modes as well;
that's kind of annoying.

#+begin_src elisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

Set the cursor to my preferred style, a box, and some very visible
colors for normal and insert mode.

#+begin_src elisp
(setq kenran/has-set-cursor-colors nil)
(defun kenran/set-evil-state-cursors (&optional force)
  "Set the cursor to a box, and use a different color for insert
and emacs mode.  The default color should be the one that the
current theme uses as background for the 'cursor face.  If FORCE
is true, then always set the colors anew."
  (when (or force (not kenran/has-set-cursor-colors))
    (setq kenran/has-set-cursor-colors t)
    (let* ((color "red")
           (default-cursor `(,color box))
           (insert-cursor `("chartreuse1" box)))
      (setq evil-operator-state-cursor default-cursor)
      (setq evil-normal-state-cursor default-cursor)
      (setq evil-replace-state-cursor default-cursor)
      (setq evil-visual-state-cursor default-cursor)
      (setq evil-motion-state-cursor default-cursor)
      (setq evil-emacs-state-cursor insert-cursor)
      (setq evil-insert-state-cursor insert-cursor)
      (remove-hook 'server-after-make-frame-hook
                   #'kenran/set-evil-state-cursors))))
#+end_src

** Check whether the current frame is the initial daemon frame

#+begin_src elisp
(defun kenran/is-initial-daemon-frame-p ()
  "Check whether the selected frame is the one that seems to be
automatically created when the daemon starts.  If this is the
selected frame we don't want to do certain things, like modifying
faces."
  (string= (frame-parameter (selected-frame) 'name) "F1"))
#+end_src

** Fonts

An alist of my preferred font families, together with a plist of
certain attributes that need to be applied when switching to the
respective font.

#+begin_src elisp
(setq kenran/font-alist
      '((pragmata-pro . (:family
                         "Pragmata Pro Mono Liga"
                         :default-height
                         170
                         :weight
                         regular))
        (iosevka . (:family
                    "Iosevka"
                    :default-height
                    166
                    :weight
                    regular))
        (dejavu . (:family
                   "DejaVu Sans Mono"
                   :default-height
                   150
                   :weight
                   regular))
        (ibm-plex . (:family
                     "IBM Plex Mono"
                     :default-height
                     150
                     :weight
                     regular))
        (cascadia . (:family
                     "Cascadia Code"
                     :default-height
                     150
                     :weight
                     regular))
        (source-code-pro . (:family
                            "Source Code Pro"
                            :default-height
                            150
                            :weight
                            regular))
        (fira-code . (:family
                      "Fira Code"
                      :default-height
                      150
                      :weight
                      regular))
        (terminus . (:family
                     "Terminus"
                     :default-height
                     170
                     :weight
                     regular))
        (jetbrains-mono . (:family
                           "JetBrains Mono"
                           :default-height
                           150
                           :weight
                           regular))
        (input-mono . (:family
                       "Input Mono"
                       :default-height
                       150
                       :weight
                       regular))
        (courier-prime . (:family
                          "Courier Prime"
                          :default-height
                          150
                          :weight
                          regular))
        (sf-mono . (:family
                    "SFMono"
                    :default-height
                    150
                    :weight
                    regular))
        (fantasque-sans-mono . (:family
                                "Fantasque Sans Mono"
                                :default-height
                                170
                                :weight
                                regular))))
#+end_src

The currently selected font (key of =kenran/font-alist=).  Setting this
value only changes the default; it is reset when switching fonts.

#+begin_src elisp
(setq kenran/current-monospace-font 'jetbrains-mono)
#+end_src

For =org-mode= I like using a serif font.  This is it.

#+begin_src elisp
(defconst kenran/serif-font "Noto Sans")
#+end_src

The function I use to switch between the various fonts I like.  It
applies the attributes of its value in =kenran/font-alist=.

#+begin_src elisp
(defun kenran/switch-font (font)
  "Apply the attributes stored for FONT in `kenran/font-alist'."
  (interactive
   (list (intern
          (completing-read
           "Font: "
           (mapcar #'car
                   (assoc-delete-all kenran/current-monospace-font
                                     (copy-alist kenran/font-alist)))))))
  (let* ((attrs (alist-get font kenran/font-alist))
         (family (plist-get attrs :family))
         (height (plist-get attrs :default-height)))
    (setq kenran/current-monospace-font font)
    (setq kenran/default-font-height height)
    (set-face-attribute
     'default nil
     :font family
     :weight (plist-get attrs :weight)
     :height (plist-get attrs :default-height))
    (set-face-attribute
     'fixed-pitch nil
     :font family
     :height 1.0)
    (set-face-attribute
     'variable-pitch nil
     :font kenran/serif-font
     :height 1.0)
    (set-face-attribute
     'fixed-pitch-serif nil
     :font family
     :inherit 'fixed-pitch
     :height 1.0)))
#+end_src

Finally, set all the face attributes, and register a hook that makes
sure that these also work when using the Emacs daemon together with
=emacsclient=.

#+begin_src elisp
(kenran/switch-font kenran/current-monospace-font)
(add-hook 'server-after-make-frame-hook
          (defun kenran/switch-to-current-font ()
            (kenran/switch-font kenran/current-monospace-font)
            (remove-hook 'server-after-make-frame-hook
                         #'kenran/switch-to-current-font)))
#+end_src

** Color theme
*** Utilities

A command to switch themes interactively.  Emacs's =load-theme= applies
all the loaded themes on top of each other; I like to only have one
theme active at all times, so I use =disable-theme= on all themes in
=custom-enabled-themes= before enabling the target theme.

#+begin_src elisp
(defvar kenran/switch-theme-hook nil
  "Functions to be called after switching the current (default)
font.")

(defun kenran/switch-theme-hook ()
  "Run `kenran/switch-theme-hook'."
  (run-hook-with-args 'kenran/switch-theme-hook))

(defun kenran/switch-theme (name)
  "Switch themes interactively.  Similar to `load-theme' but also
disables all other enabled themes."
  (interactive
   (list (intern
          (completing-read
           "Theme: "
           (mapcar #'symbol-name
                   (-difference (custom-available-themes)
                                custom-enabled-themes))))))
  (progn
    (mapc #'disable-theme
          custom-enabled-themes)
    (load-theme name t)
    (kenran/switch-theme-hook)
    (unless (kenran/is-initial-daemon-frame-p)
      ;; If it's the initial "daemon frame" then hooks in
      ;; `server-after-make-frame-hook' will be executed, including
      ;; one that calls `kenran/set-evil-state-cursor-colors'.
      (kenran/set-evil-state-cursors t))))
#+end_src

When developing a theme, like I did with my custom one, it's handy to
be able to reload it on the fly.

#+begin_src elisp
(defun kenran/reload-theme ()
  "Reload the currently active theme."
  (interactive)
  (let ((active-theme (car custom-enabled-themes)))
    (kenran/switch-theme active-theme)))
#+end_src

*** My favorite Emacs themes

Since I cannot ever decide which theme I like best, there are a few
themes, or theme collections, loaded here.

**** Custom theme: =naga=

I usually use [[https://github.com/kenranunderscore/emacs-naga-theme][my own /naga/ theme]].  It is currently in the process of
being made ready to be put on MELPA.

While that is still going on I'm using a "mutable" path, assuming I've
cloned my project repository to a fixed location.  This allows for
quick iteration.

#+begin_src elisp
(add-to-list 'custom-theme-load-path "~/projects/emacs-naga-theme")
#+end_src

Enable =naga=:

#+begin_src elisp
(kenran/switch-theme 'naga)
#+end_src

**** Modus themes

[[https://protesilaos.com/emacs/modus-themes][This package]] by Protesilaos Stavrou is my first choice of "external"
themes.  I find myself going back to =modus-vivendi= in the evening,
even though I keep saying that I don't like that high of a contrast.

These two themes are very customizable and come with the most
comprehensive and extensive documentation (same as with basically
anything that Prot makes available).

#+begin_src elisp
(use-package modus-themes
  :defer t
  :config
  (setq modus-themes-subtle-line-numbers t)
  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs nil)
  (setq modus-themes-syntax '(green-strings alt-syntax))
  (setq modus-themes-prompts '(background bold))
  (setq modus-themes-mode-line nil)
  (setq modus-themes-completions
        '((matches . (intense background))
          (selection . (intense accented))
          (popup . (intense accented))))
  (setq modus-themes-fringes nil)
  (setq modus-themes-paren-match '(bold intense))
  (setq modus-themes-region '(accented bg-only))
  ;; TODO: org agenda, mail citations
  (setq modus-themes-org-blocks nil))
#+end_src

**** Doom themes

[[https://github.com/hlissner/doom-emacs][This package]] used to be my go-to source of different themes.  It's a
megapack, started by the creator of [[https://github.com/hlissner/doom-emacs][Doom Emacs]], Henrik Lissner, but
over time it grew into an extensive collection of different themes.

It also comes with a DSL to create custom "doom themes", that is, one
specifies a relatively small number of faces / colors and the results
are propagated to most faces of all the common packages.  Without
using (something like) this, it's quite a bit of work to style lots of
packages, as one might imagine.

#+begin_src elisp
(use-package doom-themes
  :defer t)
#+end_src

https://github.com/purcell/color-theme-sanityinc-tomorrow

**** Tomorrow

Steve Purcell (author of many Emacs packages) has ported the
well-known =tomorrow= themes [[https://github.com/purcell/color-theme-sanityinc-tomorrow][to Emacs]].  I haven't used them much, but I
really like the =sanityinc-tomorrow-bright= variant for its higher
contrast, overall darker look, and beautiful accent colors.

#+begin_src elisp
(use-package color-theme-sanityinc-tomorrow
  :defer t)
#+end_src

** Render color names/codes with as their respective color

It's an ELPA package, so no need/use to put it in the nix-managed
Emacs packages.

#+begin_src elisp
(use-package rainbow-mode
  :defer t)
#+end_src

* Basic options
** Startup

FIXME: Move some of the following to =early-init.el= instead.  See
Prot's configuration for inspiration and give credit.

I wish to know how fast my Emacs is starting.  I'm not sure how to
make use of all that =use-package= has to offer in that regard yet, but
I want to at least know when I've made things worse.

#+begin_src elisp
(add-hook
 'emacs-startup-hook
 (lambda ()
   (message
    "Emacs startup took %s with %d garbage collections"
    (format
     "%.2f seconds"
     (float-time (time-subtract after-init-time before-init-time)))
    gcs-done)))
#+end_src

Disable the graphical UI things like the tool and menu bars, the
splash screen, and others.

#+begin_src elisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(setq inhibit-splash-screen t)
#+end_src

Ignore the =X= resources.  Now Emacs doesn't use the terminal
background/foreground colors.

#+begin_src elisp
(setq inhibit-x-resources t)
#+end_src

** Focus popup buffers

Then I can close them with =q= immediately when I don't need them.  Most
often it's only for a quick lookup, like help buffers:

#+begin_src elisp
(setq help-window-select t)
#+end_src

Or =apropos= buffers:

#+begin_src elisp
(add-hook 'apropos-mode-hook
          (defun kenran/focus-apropos-buffer ()
            (pop-to-buffer (current-buffer))))
#+end_src

** Resize proportionally after deleting windows

#+begin_src elisp
(setq window-combination-resize t)
#+end_src

** Less annoying yes/no questions

The following setting enables answering those yes/no questions with
just =y= or =n=.

#+begin_src elisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode.  Note:
this doesn't work correctly yet, as =(command-modes 'some-command)=
seems to return the modes in an unexpected format.

#+begin_src elisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

I like to use a hybrid mode for displaying line numbers.  That is,
line numbers are shown in a relative way, but the current line
displays as its absolute line number.  But when switching to normal
mode, line numbers should all be absolute.  That's what these two
functions are used for.

#+begin_src elisp
(defun kenran/switch-to-absolute-line-numbers ()
  "Enable absolute line numbers."
  (interactive)
  (when display-line-numbers-mode
    (setq display-line-numbers t)))

(defun kenran/switch-to-hybrid-line-numbers ()
  "Enable relative line numbers, but with the current line
showing its absolute line number."
  (interactive)
  (when display-line-numbers-mode
    (setq display-line-numbers 'relative)
    (setq display-line-numbers-current-absolute t)))
#+end_src

To display line numbers, the aptly named =display-line-numbers= package
is used.  It's enabled by default in all programming modes.

#+begin_src elisp
(use-package display-line-numbers
  :config
  (setq display-line-numbers-type 'relative)
  (setq display-line-numbers-current-absolute t)
  :hook ((prog-mode . display-line-numbers-mode)
         (conf-mode . display-line-numbers-mode)
         (evil-insert-state-entry . kenran/switch-to-absolute-line-numbers)
         (evil-insert-state-exit . kenran/switch-to-hybrid-line-numbers)))
#+end_src

Show column numbers in the modeline.

#+begin_src elisp
(column-number-mode)
#+end_src

Toggle line numbers interactively.  I've tried simply binding
=display-line-numbers-mode=, but I had to use it twice for the /first/
toggle.  This is more stable so far.

#+begin_src elisp
(defun kenran/toggle-line-numbers ()
  "Toggle `display-line-numbers-mode'.  Meant to be used in a
keybinding."
  (interactive)
  (display-line-numbers-mode 'toggle))
#+end_src

** Insert a newline at the end of files

#+begin_src elisp
(setq require-final-newline t)
(setq mode-require-final-newline t)
#+end_src

** Suppress warning from native compilation

When using Emacs =HEAD= (with the merged =native-comp= branch) a lot of
warnings show up during startup and when changing modes.  We could
increase the minimum severity for logs to be shown by setting
=warning-minimum-level= to =:error,= or just disable the warnings for
native compilation entirely like this:

#+begin_src elisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** Spaces over tabs

#+begin_src elisp
(setq-default indent-tabs-mode nil)
#+end_src

** If I have to use tabs, at least make them smaller

Looking at you, [[https://go.dev/][Go]].

#+begin_src elisp
(setq-default tab-width 4)
#+end_src

** File name searches should be case-insensitive

#+begin_src elisp
(setq read-file-name-completion-ignore-case t)
#+end_src

** Hide minor modes from the modeline

The =diminish= package enables us to hide minor modes from the modeline.
It's especially useful for certain modes that are globally enabled
anyway.  =Use-package= has built-in support for this available with the
=:diminish= keyword.

#+begin_src elisp
(use-package diminish)
#+end_src

* Vim emulation

** Leader keys

Having a dedicated leader key (=SPC= in my case) is one of the most
important things to me as it opens up a lot of possibilities for
creating custom keymaps.  The keybindings naturally do not clash with
the default Emacs-style bindings many packages introduce.  I will use
this to try and create more vim-inspired mnemonic keybindings (say, =p=
for project-specific commands, =g= for git etc.)

In general I try to keep package-specific keybindings next to the
configuration of the respective packages.  However with =use-package=
there seems to be a =:general= keyword, which probably works similar to
the =:bind= one.  I sometimes use the latter for bindings that are not
mode-sensitive.

#+begin_src elisp
(general-create-definer with-leader
  :keymaps 'override
  :states '(normal insert emacs visual motion)
  :prefix "SPC"
  :non-normal-prefix "C-SPC")
#+end_src

A local leader key is something that is usually used to access
situational commands, for instance language-specific or mode-specific
ones.  I used =,= for this in Vim; same here now.

#+begin_src elisp
(general-create-definer with-local-leader
  :prefix ",")
#+end_src

** Non-evil ("holy") modes

This is a list of modes that I do not want =evil= mode (defined below)
to be enabled in by default.  It's mostly a preference of mine to use
Emacs mode in REPL, terminal and shell buffers.

#+begin_src elisp
(setq kenran/holy-modes
      '((ediff . ediff)
        (eshell-mode . eshell)
        (mu4e . mu4e)
        (mu4e . mu4e-conversation)
        (notmuch-hello-mode . notmuch)
        (racket-repl-mode . nil)
        (racket-stepper-mode . nil)
        (shell-mode . nil)
        (sly-mrepl-mode . nil)
        (term-mode . (term term ansi-term multi-term))
        (vterm-mode . vterm)
        (haskell-interactive-mode . nil)
        (nil . lispy)))

(setq kenran/evil-holy-modes
      (remove nil
              (mapcar #'car kenran/holy-modes)))

(setq kenran/evil-collection-exemptions
      (remove nil
              (mapcar #'cdr kenran/holy-modes)))
#+end_src

** =Evil= and supporting packages

The evil package offers a very complete vim experience inside of
Emacs.

#+begin_src elisp
(use-package evil
  :config
  (evil-mode 1)
  (dolist (mode kenran/evil-holy-modes)
    (evil-set-initial-state mode 'emacs))
  :custom
  ((evil-want-C-u-scroll t)
   (evil-want-C-u-delete nil)
   (evil-want-C-w-delete t)
   (evil-want-Y-yank-to-eol t)
   (evil-undo-system 'undo-redo)
   (evil-symbol-word-search t)
   (evil-jumps-cross-buffers nil))
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (add-hook 'server-after-make-frame-hook
            #'kenran/set-evil-state-cursors))
#+end_src

*** Evilify nearly everything (=evil-collection=)

This package makes it possible to enable =evil= in lots of (mostly
minor) modes.  This usually includes some sort of streamlined
keybinding scheme, where the vim movement keys =h=, =j=, =k=, =l=, and often
=C-j= and =C-k= are used for navigation.

However, I've been in the situation where "something didn't quite
work" quite some times, and =evil-collection= has often been the
culprit.  Checking =evil-collection-mode-list= to see whether any
current mode was evilified with =evil-collection=, and subsequently
removing them from this list, has often fixed some problems (for
instance with =mu4e=).

#+begin_src elisp
(use-package evil-collection
  :after evil
  :config
  (dolist (x kenran/evil-collection-exemptions)
    (delete x evil-collection-mode-list))
  (evil-collection-init)
  (evil-collection-inhibit-insert-state 'notmuch-hello-mode-map)
  :custom
  (evil-collection-want-unimpaired-p nil))
#+end_src

*** Surrounding things

The analogue of [[https://github.com/tpope/vim-surround][Tim Pope's vim-surround plugin]] in Emacs.  Now I can
use things like =ysiw)= to surround an inner word with non-padded normal
parentheses, =ds]= to delete surrounding brackets, or =cs[{= to change
surrounding brackets to curly braces with whitespace padding.
Selected regions can be surround with e.g. =S`=.

#+begin_src elisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode))
#+end_src

*** 2-character searching in one line

[[https://github.com/hlissner/evil-snipe][Henrik Lissner's evil-snipe]] replaces the default vim =s= binding by a
2-character incremental forward/backward search.  In addition,
=evil-snipe-override-mode= makes the =f=, =F=, =t=, and =T= searches repeatable
by pressing the respective key again to jump by one match.  It also
adds highlighting to those motions.

It's also possible to configure/increase the scope of these searches,
but for the moment I'm content with just using it on one line.

#+begin_src elisp
(use-package evil-snipe
  :after evil
  :diminish evil-snipe-local-mode
  :config
  (evil-snipe-mode 1)
  (evil-snipe-override-mode 1))
#+end_src

*** Evilify =org=

=Evil-org= enables me to use =evil= keybindings in =org-agenda=.  As a bonus
it adds some keybindings and text objects for =org= files as well.

TODO: It's surely worth spending some more time to find out what else
this brings with it, but I'm not writing enough with =org=

#+begin_src elisp
(use-package evil-org
  :after (evil org)
  :hook (org-mode . evil-org-mode)
  :diminish evil-org-mode
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+end_src

*** Highlight vim marks

#+begin_src elisp
(use-package evil-visual-mark-mode
  :defer t
  :after evil
  :init (evil-visual-mark-mode))
#+end_src

** Keybindings

Create nice custom mappings for normal mode (and others) that are
accessed with the leader key, =SPC=.

#+begin_src elisp
(with-leader
  ;; Give SPC SPC one more chance
  "SPC" '(execute-extended-command :which-key "M-x")
  ;; Different ways to quit Emacs
  "q" '(:ignore t :which-key "quit")
  "q f" 'evil-save-and-quit
  "q k" 'save-buffers-kill-emacs
  ;; Buffer-related commands
  "b" '(:ignore t :which-key "buffer")
  "b b" 'consult-buffer
  "b q" 'kill-current-buffer
  "b i" 'ibuffer
  "b k" 'kill-buffer
  "b n" 'next-buffer
  "b p" 'previous-buffer
  ;; Toggles/switches
  "t" '(:ignore t :which-key "toggle/switch")
  "t l" '(kenran/toggle-line-numbers :which-key "line numbers")
  "t t" '(kenran/switch-theme :which-key "switch theme")
  "t r" '(kenran/reload-theme :which-key "reload theme")
  "t f" '(kenran/switch-font :which-key "switch font")
  "t w" 'global-whitespace-mode
  ;; Language-agnostic code-related commands
  "c" '(:ignore t :which-key "code")
  "c l" 'comment-line
  "c r" 'comment-or-uncomment-region
  ;; Searching
  "s" '(:ignore t :which-key "search/switch")
  "s g" 'consult-git-grep
  "s p" 'consult-ripgrep
  ;; Window management (redundant)
  "w" '(evil-window-map :which-key "windows")
  ;; Emacs config
  "e" '(:ignore t :which-key "emacs")
  "e e" '(kenran/open-init-file :which-key "edit config.org")
  ;; Additional help commands
  "h" '(:ignore t :which-key "help")
  "h m" 'man)
#+end_src

*** =C-w=

Enable =C-w= for vim-like window management (when not in insert or Emacs
mode).  This means that I need to override the Emacs default binding,
which can be done via =general='s =:keymaps 'override=.

#+begin_src elisp
(general-define-key
 :states '(normal visual motion operator)
 :keymaps 'override
 "C-w" 'evil-window-map
 "C-w C-h" 'evil-window-left
 "C-w C-k" 'evil-window-up
 "C-w C-j" 'evil-window-down
 "C-w C-l" 'evil-window-right
 "C-w C-d" 'evil-quit)
#+end_src

Enable =C-w= to delete backward (like in vim or bash) in insert mode,
and also when Emacs is reading user input in the minibuffer.

#+begin_src elisp
(general-define-key
 :keymaps 'minibuffer-local-map
 "C-w" 'evil-delete-backward-word)

(general-define-key
 :states '(emacs)
 "C-w" 'evil-delete-backward-word)
#+end_src

* Built-in packages with extensions
** Display whitespace

Make whitespace symbols visible.

#+begin_src elisp
(use-package whitespace
  :config
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode
              org-mode))
  (setq whitespace-style
        '(face newline newline-mark missing-newline-at-eof
               trailing empty tabs tab-mark))
  (setq whitespace-display-mappings
        '((newline-mark 10
                        [9166 10])
          (tab-mark 9
                    [187 9]
                    [92 9])))
  (global-whitespace-mode 1))
#+end_src

** Render manpages in Emacs

#+begin_src elisp
(use-package man
  :defer t
  :config
  ;; As soon as it is ready open the manpage in a separate, focused
  ;; window.
  (setq Man-notify-method 'aggressive))
#+end_src

** Diminish only

#+begin_src elisp
(use-package face-remap
  :diminish buffer-face-mode)

(use-package autorevert
  :diminish auto-revert-mode)
#+end_src

** Don't trim ELisp evaluation results

#+begin_src elisp
(use-package simple
  :straight (:type built-in)
  :diminish auto-fill-function
  :config
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil))
#+end_src

** ElDoc

#+begin_src elisp
(use-package eldoc
  :diminish eldoc-mode
  :config
  (advice-add 'eldoc-doc-buffer
              :after
              (defun kenran/focus-eldoc-buffer ()
                (message (buffer-name (current-buffer)))
                (pop-to-buffer eldoc--doc-buffer))))
#+end_src

** Directory editor

#+begin_src elisp
(use-package dired
  :straight (:type built-in)
  :defer t
  :config
  (setq dired-kill-when-opening-new-dired-buffer t)
  (setq dired-create-destination-dirs 'ask)
  :custom
  ;; Sort directories to the top
  (dired-listing-switches "-la --group-directories-first"))
#+end_src

Beautify =dired= a bit.

#+begin_src elisp
(use-package diredfl
  :defer t
  :after dired
  :hook (dired-mode . diredfl-mode))
#+end_src

=Dired-narrow= is a package containing functionality to enter a filter
to narrow down the contents of a =dired= buffer interactively.  The
filter could be either some fixed string, with normal or fuzzy
matching, or a regural expression.  Bind those three functions to the
local leader key to have easier access, as =dired= already has lots of
keys bound.

#+begin_src elisp
(use-package dired-narrow
  :defer t
  :after dired)

(with-local-leader
  :states 'normal
  :keymaps 'dired-mode-map
  "n" '(:ignore t :which-key "dired-narrow")
  "n n" 'dired-narrow
  "n f" 'dired-narrow-fuzzy
  "n r" 'dired-narrow-regexp)
#+end_src

** Ediff

=Ediff= is a great way to diff and/or merge files or buffers.  By
default it creates a new frame containing a "control buffer" used to
navigate the diff and manipulate the output.  Unfortunately for the
longest time this behaved weirdly for me: whenever I'd tab to the
frame containing the diff, do something, then tab back, the next
navigational command from the control frame would work but drop me
back in the diff frame.  It's possible to use
=ediff-setup-windows-plain= as setup function, which makes =ediff=
single-frame, circumventing the problem.

#+begin_src elisp
(use-package ediff-wind
  :straight (:type built-in)
  :config
  (setq ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

** Auto-closing parens, braces and other pairs

I used to use =smartparens= to automatically insert closing parentheses
and other pairs in non-lispy modes.  One thing I was missing from
Neovim, though, was the newlines and indentation that it inserted
automatically when pressing =RET= with point between braces.

The built-in =electric-pair-mode= does just that (by default).

#+begin_src elisp
(use-package emacs
  :straight (:type built-in)
  :init
  (electric-pair-mode)
  :config
  (setq electric-pair-open-newline-between-pairs t))
#+end_src

** Undo changes to window arrangements

Sometimes I accidentally mess up my window layout.  =Winner-mode= comes
with the =winner-undo= command (bound by default to =C-<left>=) that
reverts such changes.

#+begin_src elisp
(use-package emacs
  :straight (:type built-in)
  :init (winner-mode))
#+end_src

* Incremental narrowing

I started with =helm= in [[https://www.spacemacs.org/][spacemacs]], then later switched to [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
where after a while I tried out =ivy= and loved it.  Configuring Emacs
from scratch was when I decided to try out some of the newer, more
lightweight Emacs packages like [[https://github.com/raxod502/selectrum][selectrum]] and [[https://github.com/minad/vertico][vertico]].  Those
integrate very well with default Emacs functionality, so a lot of
things can utilize them "implicitly".  I've stuck with =vertico= and
I've been happy with it ever since.

#+begin_src elisp
(use-package vertico
  :straight (vertico :files (:defaults "extensions/*.el"))
  :init
  (vertico-mode +1)
  :custom
  (vertico-cycle t)
  (vertico-resize t)
  :bind
  (:map vertico-map
        ("C-w" . evil-delete-backward-word)))
#+end_src

=Vertico-reverse= is an extension of =vertico= that shows the
completion candidates above the prompt.  This has the nice effect of
the prompt always being in the same location, so that I don't have to
change where I look.

#+begin_src elisp
(use-package vertico-reverse
  :straight nil
  :init
  (vertico-reverse-mode +1))
#+end_src

Directory navigation in =C-x d= or =C-x C-f= is something else that I
liked in Doom Emacs, as Doom had a notion of "directory name", that
is, =DEL= would delete one level in the directory hierarchy, including
the slash symbol.  The following extension to =vertico= does just that.

#+begin_src elisp
(use-package vertico-directory
  :straight nil
  :after vertico
  :bind (:map vertico-map
              ("DEL" . vertico-directory-delete-char)
              ("C-w" . vertico-directory-delete-word)
              ("RET" . vertico-directory-enter)))
#+end_src

=savehist-mode= keeps a history of commands and inputs I've done in a
context-sensitive way, and then shows those at the top when presented
with possible results from =vertico=.

#+begin_src elisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][orderless]] is a /completion style/ that fits in very well with =vertico=
(or =selectrum=, for that matter).  Parts of a search string may match
according to several matching styles.  We want to be able to specify
which matching style to use by appending a suffix so a search string.
Therefore we define style dispatchers and use them to customize
=orderless-style-dispatchers=.

Prepending an equals sign to a search term will search for literal
matches of the preceding string.

#+begin_src elisp
(defun kenran/literal-if-= (pattern _index _total)
  (when (string-prefix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 1))))
#+end_src

A prepended bang discards everything that matches the preceding
literal string.

#+begin_src elisp
(defun kenran/without-if-! (pattern _index _total)
  (when (string-prefix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

The tilde sign gives me a way to have "fuzzy" search, if needed.

#+begin_src elisp
(defun kenran/flex-if-~ (pattern _index _total)
  (when (string-prefix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 1))))
#+end_src

#+begin_src elisp
(use-package orderless
  :custom (completion-styles '(orderless))
  (orderless-style-dispatchers
   '(kenran/literal-if-=
     kenran/without-if-!
     kenran/flex-if-~)))
#+end_src

** Consult

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite
some time, though not in any extent close to full.  This defines some
basic bindings mostly taken from an example in its readme.

#+begin_src elisp
(use-package consult
  :bind (;; C-x bindings
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ;; C-h bindings (help)
         ("C-h a" . consult-apropos)
         ;; M-g bindings (goto)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ;; M-s bindings (search)
         ("M-s f" . consult-find)
         ("M-s L" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines))
  :custom
  (consult-project-root-function
   (lambda ()
     (when-let (project (project-current))
       (project-root project)))))
;; TODO other isearch integration?
;; TODO :init narrowing, preview delay
#+end_src

** Minibuffer actions

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet.  It seems to be amazing, though!
What I mostly use it for at the moment is its =embark-act= command in
conjunction with =embark-export=.  With this I often pull the results of
some =grep= command into a separate buffer, where I can then utilize
=wgrep= to bulk-modify the original buffers.

#+begin_src elisp
(use-package embark
  :bind (("C-," . embark-act)
         ("C-h B" . embark-bindings))
  :init
  (setq prefix-help-command #'embark-prefix-help-command))
#+end_src

Integrate =embark= with =consult=.

#+begin_src elisp
(use-package embark-consult
  :after (embark consult)
  :demand t
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

* Org mode

I want my headers to stand out by being really big.  I also like using
=variable-pitch-mode=, which makes it so only code, verbatim, and some
other things are written with my current monospace / fixed-width font,
and the rest uses a serif font more suitable for longer texts.  But
customizing these faces with =set-face-attribute= has the usual problems
with the initial daemon frame, and doesn't hold up when switching
fonts or themes.  That's why I've put those changes into the following
functions which I can call whenever these sorts of changes happen,
either through hooks or manual trigger.

Note that some themes, like =modus-{vivendi,operandi}=, might set the
=:inherit= attribute on a face, in which case a naive
~(set-face-attribute face nil :inherit 'fixed-pitch)~ overrides the
theme settings.  To circumvent this I've written the following
function that appends a single new value to the current =:inherit=
attribute value of a face.

#+begin_src elisp
(defun kenran/inherit-fixed-pitch (face)
  "Append `fixed-pitch' to the `:inherit' attribute of FACE."
  (let* ((current (face-attribute face :inherit))
         (new (cond
               ((eq 'unspecified current)
                'fixed-pitch)
               ((listp current)
                (if (member 'fixed-pitch current)
                    current
                  (cons 'fixed-pitch current)))
               ((not (eq 'fixed-pitch current))
                (list 'fixed-pitch current)))))
    (set-face-attribute face nil :inherit new)))

(defun kenran/org-font-setup ()
  "Set the face attributes for code, verbatim, and other markup
elements.  Also increase org header size."
  (interactive)
  (kenran/inherit-fixed-pitch 'org-block)
  (kenran/inherit-fixed-pitch 'org-block-begin-line)
  (kenran/inherit-fixed-pitch 'org-block-end-line)
  (kenran/inherit-fixed-pitch 'org-document-info-keyword)
  (kenran/inherit-fixed-pitch 'org-document-info)
  (kenran/inherit-fixed-pitch 'org-code)
  (kenran/inherit-fixed-pitch 'org-table)
  (kenran/inherit-fixed-pitch 'org-verbatim)
  (kenran/inherit-fixed-pitch 'org-checkbox)
  (kenran/inherit-fixed-pitch 'org-meta-line)
  (kenran/inherit-fixed-pitch 'org-special-keyword)
  ;; (kenran/inherit-fixed-pitch 'org-indent)
  (kenran/inherit-fixed-pitch 'org-link)
  (kenran/inherit-fixed-pitch 'org-todo)
  (kenran/inherit-fixed-pitch 'org-done)
  (kenran/inherit-fixed-pitch 'org-drawer)
  (kenran/inherit-fixed-pitch 'org-property-value)
  (set-face-attribute 'org-document-title nil :height 1.4 :weight 'bold)
  (dolist (face '((org-level-1 . 1.0)
                  (org-level-2 . 1.0)
                  (org-level-3 . 1.0)
                  (org-level-4 . 1.0)
                  (org-level-5 . 1.0)
                  (org-level-6 . 1.0)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    ;; (set-face-attribute (car face) nil
    ;;                     :font kenran/serif-font
    ;;                     :height (cdr face)
    ;;                     :weight 'bold)
    ))

(add-hook 'kenran/switch-theme-hook #'kenran/org-font-setup)
#+end_src

When writing text with =org=, =auto-fill-mode= should be enabled to
automatically break overly long lines into smaller pieces when typing.
One may still use =M-q= to re-fill paragraphs when editing text.  After
loading =org=, a custom font setup might run to adjust the headers.

#+begin_src elisp
(use-package org
  ;; Use the built-in version of org (which is quite up-to-date as I'm
  ;; always using emacs HEAD).  This circumvents problems with
  ;; 'org-compat of the older version having been loaded.
  :straight (:type built-in)
  :hook
  ((org-mode . auto-fill-mode)
   ;; (org-mode . variable-pitch-mode)
   (org-trigger . save-buffer))
  :diminish org-indent-mode
  :custom
  ((org-startup-indented t)
   (org-startup-folded 'content)
   (org-directory "~/org")
   (org-log-done t)
   (org-special-ctrl-a/e t)
   ;; If this has a value greater than 0, every RET press
   ;; keeps indenting the source block further and further.
   (org-edit-src-content-indentation 0)
   (org-default-notes-file "~/org/notes.org")
   (org-agenda-files '("~/org/inbox.org"
                       "~/org/gtd.org"
                       "~/org/someday.org"))
   (org-agenda-restore-windows-after-quit t)
   (org-refile-targets `(("~/org/gtd.org" :maxlevel . 3)
                         ("~/org/someday.org" :level . 1)))
   (org-capture-templates '(("t" "Todo" entry
                             (file+headline "~/org/inbox.org" "Tasks")
                             "* TODO %i%?")
                            ("n" "Note" entry
                             (file+headline "~/org/notes.org" "Notes")
                             "* %?\n%a\nNote taken on %U")))
   (org-capture-bookmark nil)
   (org-bookmark-names-plist nil)
   (org-todo-keywords '((sequence
                         "TODO(t)"
                         "WAITING(w)"
                         "|"
                         "DONE(d)"
                         "CANCELLED(c)")))
   (org-html-htmlize-output-type 'css))
  :config
  (kenran/org-font-setup)
  (setq-default org-hide-emphasis-markers t)
  (advice-add 'org-refile
              :after (lambda (&rest _) (org-save-all-org-buffers)))
  :bind (:map org-mode-map
              ("M-n" . org-next-visible-heading)
              ("M-p" . org-previous-visible-heading)))
#+end_src

** Keybindings

Add some globally useful =org= keybindings under =SPC o=, like for
capturing, storing links etc.

#+begin_src elisp
(with-leader
  "o" '(:which-key "org-mode" :ignore t)
  "o a" 'org-agenda
  "o c" 'org-capture
  "o l" 'org-store-link
  "o f" 'org-cycle-agenda-files
  "o s" 'org-save-all-org-buffers
  "o p" '((lambda () (interactive) (org-publish-all t)) :which-key "publish all")
  "o t" '(:which-key "toggle" :ignore t))
#+end_src

** Beautiful bullet points

#+begin_src elisp
(use-package org-bullets
  ;; :hook (org-mode . org-bullets-mode)
  :custom (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

Also render unordered list bullet points as dots instead of =-= or =+=.

#+begin_src elisp
(font-lock-add-keywords
 'org-mode
 '(("^ *\\([-]\\) "
    (0 (prog1 ()
         (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

** Show emphasis markers depending on point

In my =org= configuration I'm setting =org-hide-emphasis-markers= to =t=,
thus hiding certain markup elements around text.  Unfortunately it
seem to be currently impossible to switch this interactively, or I
just don't know how, which prevents me from simply adding a keybinding
to toggle it.

Thankfully a new package has appeared recently: [[https://github.com/awth13/org-appear][org-appear]]. It reacts
to the position of point to automatically show surrounding markup.

Since I'm using =evil-mode= I set the =org-appear-trigger= to ='manual=, and
add hooks that show/hide the markers to entering/leaving insert mode.
This might turn out to be a hindrance after all, since bindings like
=ciw= become a bit weird to work with.  I might end up actually using
the ='always= option value after all.

#+begin_src elisp
(use-package org-appear
  :hook ((org-mode . org-appear-mode))
  :config
  (setq org-appear-autolinks t)
  (setq org-appear-autosubmarkers t)
  (setq org-appear-autoentities t)
  (setq org-appear-autokeywords t)
  (setq org-appear-trigger 'always))
#+end_src

** Org as a Zettelkasten implementation

This is a very basic setup for =org-roam=.  I don't use the Zettelkasten
approach yet, but might in the future.  My synchronization setup with
=syncthing= should handle this well.

#+begin_src elisp
(use-package org-roam
  :defer t
  :after org
  :init
  (setq org-roam-v2-ack t)
  ;; Didn't work for the initial setup when set in :custom.
  (setq org-roam-directory (file-truename "~/org/roam/"))
  :custom
  (org-roam-db-location (expand-file-name
                         (concat (system-name) "-roam" ".db")
                         org-roam-directory))
  :config
  (org-roam-setup))
#+end_src

*** Keybindings for =org-roam=

#+begin_src elisp
(with-leader
  "o r" '(:which-key "roam" :ignore t)
  "o r c" 'org-roam-capture
  "o r f" 'org-roam-node-find
  "o r i" 'org-roam-node-insert)
#+end_src

** Short presentations with org

#+begin_src elisp
(use-package org-present
  :hook ((org-present-mode . (lambda ()
                               (org-present-big)
                               (org-display-inline-images)
                               (org-present-hide-cursor)
                               (org-present-read-only)))
         (org-present-mode-quit . (lambda ()
                                    (org-present-small)
                                    (org-remove-inline-images)
                                    (org-present-show-cursor)
                                    (org-present-read-write)))))
#+end_src

** Enable syntax highlighting when exporting to HTML

#+begin_src elisp
(use-package htmlize
  :defer t
  :after ox)
#+end_src

* On-the-fly syntax checking (and other things): Flymake

#+begin_src elisp
(use-package flymake
  :straight (:type built-in)
  :config
  (setq flymake-suppress-zero-counters t)
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-no-changes-timeout 1.0))
#+end_src

** Static analysis of shell scripts

[[https://github.com/koalaman/shellcheck][ShellCheck]] is a great little program providing feedback when writing
shell scripts.  The Emacs package [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]] integrates
ShellCheck with Flymake.  We have to trigger =flymake-shellcheck-load=
when loading shell scripts, and also enable Flymake itself, both done
via hooks to =sh-mode=.

#+begin_src elisp
(use-package flymake-shellcheck
  :commands (flymake-shellcheck-load)
  :hook ((sh-mode . flymake-shellcheck-load)
         (sh-mode . flymake-mode)))
#+end_src

* Auto-completion popups via =corfu=

This is another one of Daniel Mendler's (aka =minad='s) absolutely great
Emacs packages!  I've replaced =company= with =corfu= in the past, but
back then it did not have the automatic mode (=corfu-auto=) yet.
Without automatic completion it was a little more tedious to use in
modes where =TAB= changes the level of indentation, like in
=haskell-mode= for instance.

Now that this feature exists it's time to give the package another
try.  The first impression was very positive, as =corfu= is using a
child frame for the completion popup and thus does not clash with
=whitespace-mode= the way =company= does.

#+begin_src elisp
(use-package corfu
  :init (global-corfu-mode)
  :config
  (setq corfu-cycle t)
  (setq corfu-auto t)
  (setq corfu-auto-delay 0.1)
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)))
#+end_src

** More completion-at-point backends via =cape=

#+begin_src elisp
(use-package cape
  :init
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))
#+end_src

* E-Mail configuration

There are some different ways to "do e-mail in Emacs".  Over the last
two years I've tried out =notmuch=, =gnus=, and =mu4e=. Some thoughts on
each of those:

** Notmuch

The Emacs integration for =notmuch= is great; it has the most intuitive
and appealing UI from each of the options.  =Notmuch= works by
referencing incoming e-mail in a separate database only, not ever
touching or modifying it.  I really like this idea, and in practice it
also felt great due to the quick und customizable searches.  The usual
approach is to use a tag-based system of categorizing your e-mail, but
simply having lots of stored queries is a little bit more flexible.

But =notmuch= only handles this single aspect; this means that one needs
to find solutions to the following:

- Getting mail
- Initial tagging
- Sending mail
- Synchronization between machines

Due to the declarative e-mail account configuration from =home-manager=
the first part is very simple, and I could also easily switch between
different tools like =isync= or =offlineimap=.

The initial tagging can be done with a shell script using the
well-documented =notmuch= CLI, or via =afew=.

For sending mail I use =msmtp=.

Synchronization is where it broke down for me.  I have a PC at home,
and a laptop at work, and I'd like those two machines to have
identical state with respect to e-mail at all times.  I've tried using
=muchsync= on my personal server to be the "source of truth".  This
means that only the server downloads e-mail via IMAP, and the machines
are simply its /clients/; they use =muchsync= to download mail from the
server.

This sounds great on paper but it presents a problem with sent mail,
which I'd also like to sync back via IMAP to my accounts.  The client
machine sends this and puts it into a special =sent= directory, which is
then synchronized/uploaded to the server via =muchsync=.  I've had
problems with mails appearing twice, or appearing not at all on the
respective "other" machine.

If I only used one machine, =notmuch= would definitely be my preference,
but debugging this situation was very tedious and I just didn't have
the energy or time to do it.

** Gnus

I've not given =gnus= the trial it deserves.  Reading newsgroups and
mailing lists is something I can image using =gnus= for in the future.
Using it for e-mail, though, would require another synchronization
process of the =gnus= state.

I could utilize =syncthing=, which I use for synchronization of my =org=
files, to do this as well, but I've given it a couple of tries and
couldn't do it.  An experiment for another time, for sure.

** Mu for Emacs

[[https://www.djcbsoftware.nl/code/mu/][Mu]] is what I'm currently using, and =mu4e= is its Emacs frontend.  It's
not as customizable as =notmuch=, but part of its charme is that I don't
need to sync anything between my machines, at the cost of =mu= touching
my e-mail (adding custom headers I believe).  I don't mind this at
all, and I can use =isync= and =msmtp= to receive and send mail on any
host.

For writing e-mails =mu4e= uses =message-mode= like the other tools.  This
checks the =user-full-name= variable to fill in my name.

#+begin_src elisp
(setq user-full-name "Johannes Maier")
#+end_src

The actual =mu4e= configuration is one huge =use-package= block, but most
of it is due to its concept of /contexts/.  Usually there's one context
for each of my e-mail addresses, and switching between them I may set
some context-specific variables, or even change the =mu4e= UI
accordingly.

Note that =mu4e= is one of those packages that would behave strangely
when using the =evil-collection= integration.

#+begin_src elisp
  (use-package mu4e
    :straight
    (:local-repo "~/.nix-profile/share/emacs/site-lisp/mu4e"
     :type built-in)
    :defer t
    :commands (mu4e)
    :config
    (setq mail-user-agent 'mu4e-user-agent)
    (setq mu4e-completing-read-function #'completing-read)
    ;; I don't sync drafts to either of the accounts
    (setq mu4e-confirm-quit nil)
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-drafts-folder "/drafts")
    (setq mu4e-attachment-dir "~/Downloads/")
    (setq mu4e-contexts
          `(,(make-mu4e-context
              :name "mailbox"
              :match-func (lambda (msg)
                            (when msg
                              (string-prefix-p "/mailbox"
                                               (mu4e-message-field msg :maildir)
                                               t)))
              :vars '((user-mail-address . "johannes.maier@mailbox.org")
                      (mu4e-compose-signature . nil)
                      (mu4e-sent-folder . "/mailbox/Sent")
                      (mu4e-trash-folder . "/mailbox/Trash")
                      (mu4e-refile-folder . (lambda (msg)
                                              (let* ((date (mu4e-message-field-at-point :date))
                                                     (year (decoded-time-year (decode-time date))))
                                                (concat "/mailbox/Archive/"
                                                        (number-to-string year)))))))
            ,(make-mu4e-context
              :name "ag"
              :match-func (lambda (msg)
                            (when msg
                              (string-prefix-p "/ag"
                                               (mu4e-message-field msg :maildir)
                                               t)))
              :vars `((user-mail-address . "johannes.maier@active-group.de")
                      ;; FIXME: Signature in a file?
                      (mu4e-compose-signature . ,(concat
                                                  "Johannes Maier\n"
                                                  "johannes.maier@active-group.de\n\n"
                                                  "+49 (7071) 70896-67\n\n"
                                                  "Active Group GmbH\n"
                                                  "Hechinger Str. 12/1\n"
                                                  "72072 Tübingen\n"
                                                  "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                                                  "Geschäftsführer: Dr. Michael Sperber"))
                      (mu4e-sent-folder . "/ag/Sent")
                      (mu4e-refile-folder . (lambda (msg)
                                              (let* ((date (mu4e-message-field-at-point :date))
                                                     (year (decoded-time-year (decode-time date))))
                                                (concat "/ag/Archives/"
                                                        (number-to-string year)))))
                      (mu4e-trash-folder . "/ag/Trash")))))
    (setq mu4e-bookmarks '((:name "Active-Group inbox" :query "maildir:/ag/Inbox" :key ?a)
                           (:name "Mailbox inbox" :query "maildir:/mailbox/Inbox" :key ?m)
                           (:name "Unread messages" :query "flag:unread AND NOT flag:trashed" :key ?u)
                           (:name "Sent" :query "maildir:/ag/Sent OR maildir:/mailbox/Sent" :key ?s)))
    (setf (alist-get 'trash mu4e-marks)
          (list :char '("d" . "▼")
                :prompt "dtrash"
                :dyn-target (lambda (target msg)
                              (mu4e-get-trash-folder msg))
                :action (lambda (docid msg target)
                          (mu4e~proc-move docid (mu4e~mark-check-target target)) "-N")))
    (setq mu4e-headers-fields '((:human-date . 12)
                                (:flags . 6)
                                (:maildir . 15)
                                (:mailing-list . 10)
                                (:from . 22)
                                (:subject)))
    (setq mu4e-context-policy 'pick-first)
    (setq mu4e-compose-policy 'ask)
    ;; Getting mail via mbsync
    (setq mu4e-get-mail-command "mbsync -a")
    ;; Composing emails
    (setq message-send-mail-function #'message-send-mail-with-sendmail)
    (setq send-mail-function #'message-send-mail-with-sendmail)
    (setq message-sendmail-envelope-from 'header)
    (setq mail-envelope-from 'header)
    (setq mail-specify-envelope-from 'header)
    (setq message-kill-buffer-on-exit t)
    ;; Visuals
    (setq mu4e-headers-thread-single-orphan-prefix '("─> " . "─▶"))
    (setq mu4e-headers-thread-orphan-prefix '("┬> " . "┬▶ "))
    (setq mu4e-headers-thread-child-prefix '("├> " . "├▶"))
    (setq mu4e-headers-thread-connection-prefix '("│ " . "│ "))
    (setq mu4e-headers-thread-duplicate-prefix '("= " . "≡ "))
    (setq mu4e-headers-thread-first-child-prefix '("├> " . "├▶"))
    (setq mu4e-headers-thread-last-child-prefix '("└> " . "╰▶")))
#+end_src

Bind e-mail management to the global hotkey =SPC m=.

#+begin_src elisp
(with-leader
  "m" '(mu4e :which-key "mail"))
#+end_src
  
* Package-specific configuration
** Mode-specific code snippets

#+begin_src elisp
(use-package yasnippet
  :init (yas-global-mode 1)
  :diminish yas-minor-mode)
#+end_src

** Unified interface for creating code formatters

Another generally useful package by Steve Purcell is [[https://github.com/purcell/emacs-reformatter][reformatter.el]].
It enables easy definition of commands to format buffers, as well as
minor modes that, when active, automatically apply these commands on
save.

#+begin_src elisp
(use-package reformatter
  :defer t)
#+end_src

** Terminal emulator in Emacs

=vterm= is a terminal emulator for Emacs, more feature-rich than the
built-in =term=.  This is very useful for quickly spawning a terminal,
for instance in the top-level directory of a project.

#+begin_src elisp
(use-package vterm
  :straight nil
  :commands (vterm)
  :defer t
  :config
  (setq vterm-shell "zsh")
  (general-define-key
   :keymaps 'vterm-mode-map
   :states 'emacs
   "C-w" 'vterm-send-C-w))
#+end_src

** Zig

[[https://ziglang.org/][Zig]] is a relatively new systems programming language that I could see
me learning more in-depth in the near future.  It's a smaller language
than, say, Rust, and less safe; but I like its explicit nature and
great defaults.  The community is very welcoming so far, as well!

#+begin_src elisp
(use-package zig-mode
  :defer t)
#+end_src

** OCaml

[[https://github.com/ocaml/tuareg][tuareg]] is the standard mode for OCaml editing, providing syntax
highlighting, REPL support, etc., similar to what =haskell-mode= does
for Haskell.

#+begin_src elisp
(use-package tuareg
  :hook (tuareg-mode . (lambda () (setq mode-name "🐫")))
  :config
  (setq tuareg-indent-align-with-first-arg nil)
  (setq tuareg-match-patterns-aligned t))
#+end_src

To get some IDE features for OCaml in Emacs I use [[https://github.com/ocaml/merlin][merlin]].

#+begin_src elisp
(use-package merlin
  :hook ((tuareg-mode . merlin-mode)))
#+end_src

[[https://github.com/Khady/merlin-eldoc][merlin-eldoc]] integrates =merlin= with =eldoc-mode=, automatically
documenting things at point.

#+begin_src elisp
(use-package merlin-eldoc
  :after merlin
  :hook (tuareg-mode . merlin-eldoc-setup)
  :config
  (setq merlin-eldoc-max-lines 8)
  (setq merlin-eldoc-type-verbosity 'min)
  (setq merlin-eldoc-function-arguments t)
  (setq merlin-eldoc-doc t))
#+end_src

** Fish

I'm often using the [[https://fishshell.com/][fish]] shell.  It comes with its own,
POSIX-incompatible language, but I mainly use it for =fish='s
configuration (though most of that is done via =nix=, anyway).  It's
nice to have syntax highlighting, though.

#+begin_src elisp
(use-package fish-mode
  :defer t)
#+end_src

** EditorConfig

I want to be able to simply clone and work in projects and adapt to
their respective styles of indentation, newlines at the end of files,
and the like.  [[https://editorconfig.org/][EditorConfig]] comes with a specified file format to
describe these things, possible even on per-file basis; all one needs
to use these is support of one's editor.  Many editors have
out-of-the-box EditorConfig support nowadays.  For Emacs, there's the
official [[https://github.com/editorconfig/editorconfig-emacs][editorconfig-emacs]] package.

#+begin_src elisp
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+end_src

** Ini files

I'm not 100 percent happy with this package, as paragraphs seem to be
acting strange.  Deleting a paragraph via =dap= for instance often
deletes the following one, too, plus sometimes the previous section
header.

#+begin_src elisp
(use-package ini-mode
  :defer t)
#+end_src

** JavaScript

#+begin_src elisp
(use-package js
  :defer t
  :config
  (setq js-indent-level 2))
#+end_src

** Purescript

#+begin_src elisp
(use-package psc-ide
  :hook (purescript-mode . psc-ide-mode)
  :config
  (setq psc-ide-rebuild-on-save t))

(use-package purescript-mode
  :hook (purescript-mode . turn-on-purescript-indentation))
#+end_src

** Nix

#+begin_src elisp
(reformatter-define kenran/nix-format
  :program "nixfmt"
  :args '()
  :lighter " k/nixfmt")

(use-package nix-mode
  :mode "\\.nix\\'"
  :hook (nix-mode . kenran/nix-format-on-save-mode))
#+end_src

** Markdown

#+begin_src elisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc")
  :hook ((markdown-mode gfm-mode) . auto-fill-mode))
#+end_src

** Haskell

Provide an interactive mode for writing Haskell.  I can work with a
REPL, get feedback and compilation errors shown in the code, and so
on.

#+begin_src elisp
(use-package haskell-mode
  :diminish interactive-haskell-mode
  :custom
  (haskell-process-type 'cabal-repl)
  (haskell-interactive-popup-errors nil)
  :hook (haskell-mode . interactive-haskell-mode))
#+end_src

A couple of ELisp functions that help me to make quick changes to
Haskell files (adding pragmas, language extensions, GHC options,
imports).

#+begin_src elisp
(defun kenran/make-pragma (pragma content)
  "Create a pragma line of type `pragma' containing `content'."
  (concat "{-# " pragma " " content " #-}\n"))

(defun kenran/haskell-add-language-extension (ext-name)
  "Add an extension from the list of available language extensions
to the top of the file."
  (interactive
   (list
    (completing-read
     "Extension: "
     haskell-ghc-supported-extensions)))
  (let ((pragma (kenran/make-pragma "LANGUAGE" ext-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun kenran/haskell-add-ghc-option (opt-name)
  "Add a GHC option from the list of options to the top of the
file."
  (interactive
   (list
    (completing-read
     "GHC option: "
     haskell-ghc-supported-options)))
  (let ((pragma (kenran/make-pragma "OPTIONS_GHC" opt-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun kenran/read-non-empty-string (prompt)
  "Read a string from the minibuffer.  When the result is the empty
string, return nil instead."
  (let ((str (read-string prompt)))
    (unless (string-empty-p str)
      str)))

(defun kenran/haskell-add-import (module &optional qualified? alias)
  "Add an import to the import list.  Prompts for qualified import
and alias."
  (interactive
   (let* ((module (read-string "Module: "))
          (qualified? (y-or-n-p (concat "Import " module " qualified?")))
          (alias (when qualified?
                   (kenran/read-non-empty-string "Alias [or leave empty]: "))))
     (list module qualified? alias)))
  (let ((import-line
         (concat "import "
                 (when qualified? "qualified ")
                 module
                 (when alias (concat " as " alias))
                 "\n")))
    (save-excursion
      (haskell-navigate-imports-go)
      (insert import-line))))
#+end_src

Define some keybindings that are local to the =interactive-haskell-mode=
using the local leader key.

#+begin_src elisp
(with-local-leader
  :states 'normal
  :keymaps 'interactive-haskell-mode-map
  "e" '(:ignore t :which-key "errors")
  "e f" '(haskell-goto-first-error :which-key "first")
  "e n" '(haskell-goto-next-error :which-key "next")
  "e p" '(haskell-goto-prev-error :which-key "previous")
  "i" '(:ignore t :which-key "imports")
  "i i" '(haskell-navigate-imports-go :which-key "navigate to imports")
  "i r" '(haskell-navigate-imports-return :which-key "return from imports")
  "i a" '(kenran/haskell-add-import :which-key "add import")
  "p" '(:ignore t :which-key "pragmas")
  "p l" '(kenran/haskell-add-language-extension :which-key "add language extension")
  "p o" '(kenran/haskell-add-ghc-option :which-key "add GHC option")
  "h" '(:ignore t :which-key "haskell-process")
  "h r" '(haskell-process-restart :which-key "restart")
  "h k" 'haskell-session-kill)
#+end_src
  
** Dhall

#+begin_src elisp
(use-package dhall-mode
  :mode "\\.dhall\\'"
  :config
  (setq dhall-type-check-inactivity-timeout 2))
#+end_src

** Docker

#+begin_src elisp
(use-package dockerfile-mode
  :defer t)
#+end_src

** YAML

#+begin_src elisp
(use-package yaml-mode
  :defer t)
#+end_src

** Clojure

The key to using Clojure effectively with Emacs seems to be [[https://github.com/clojure-emacs/cider][CIDER]].

#+begin_src elisp
(use-package clojure-mode
  :defer t)

(use-package cider
  :after clojure-mode
  :defer t)
#+end_src

** CSV

#+begin_src elisp
(use-package csv-mode
  :defer t)
#+end_src

** PlantUML

#+begin_src elisp
(use-package plantuml-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist
               '("\\.\\(plantuml\\|puml\\)\\'" . plantuml-mode))
  :config
  (setq plantuml-default-exec-mode 'executable))
#+end_src

** Common Lisp

[[https://github.com/joaotavora/sly][SLY]] seems to be a bit more actively developed and modern than [[https://slime.common-lisp.dev/][SLIME]].

#+begin_src elisp
(use-package sly
  :defer t
  :config
  (setq inferior-lisp-program "sbcl"))
#+end_src

=sly-asdf= gives integration with Common Lisp's package manager, [[https://asdf.common-lisp.dev/][ASDF]].

#+begin_src elisp
(use-package sly-asdf
  :defer t)
#+end_src

** Racket

#+begin_src elisp
(use-package racket-mode
  :defer t
  :hook ((racket-mode . racket-xp-mode)
         (racket-mode . racket-unicode-input-method-enable)
         (racket-repl-mode . racket-unicode-input-method-enable)))
#+end_src

** Rust

#+begin_src elisp
(use-package rust-mode
  :defer t
  :config
  (setq rust-format-on-save t))
#+end_src

** Java

I don't use Java, but Bob Nystrom's excellent and free book [[https://craftinginterpreters.com/][Crafting
Interpreters]] uses it for the first part.  It's actually quite OK to
write Java with =meghanada,= but it takes a long time to download all
its dependencies.

#+begin_src elisp
(use-package meghanada
  :defer t
  :init
  (add-hook 'java-mode-hook
            (lambda ()
              (meghanada-mode t)
              (flycheck-mode +1)
              (setq c-basic-offset 2)
              (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))))
#+end_src

** Python

#+begin_src elisp
(use-package anaconda-mode
  :defer t
  :hook (python-mode . anaconda-mode))

(use-package pyimport
  :defer t)
#+end_src

** Nim

#+begin_src elisp
(use-package nim-mode
  :defer t)
#+end_src

** F#

#+begin_src elisp
(use-package fsharp-mode
  :defer t
  :config
  (setq fsharp-indent-offset 2)
  (setq fsharp-continuation-offset 2)
  (setq inferior-fsharp-program "dotnet fsi --readline-"))
#+end_src

** LSP integration

I've used =lsp-mode= in the past and while it's nice, I feel like it's
more in line with the rest of this configuration to try out something
more lightweight and closer to vanilla Emacs.  This is where [[https://github.com/joaotavora/eglot][eglot]]
comes into play.

#+begin_src elisp
(use-package eglot
  :defer t)
#+end_src

** Better Emacs help and documentation

This gives us better and more readable help pages.  We also replace
some built-in =C-h= keybings with =helpful-*= functions.

#+begin_src elisp
(use-package helpful
  :after evil
  :bind (("C-h f" . helpful-callable)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key))
  :config
  (evil-set-initial-state 'helpful-mode 'motion))
#+end_src

** Project management

I've used [[https://github.com/bbatsov/projectile][projectile]] for a while.  It's great, but I found myself not
using most of its features.  Now that the built-in =project.el= has been
coming along great, I'm giving it a try.  I'm very happy with it so
far.

The following are utility functions that mostly rely on being in the
top-level directory of a known project.  =project.el= is making this
possible in a straightforward way.

#+begin_src elisp
(defun kenran/add-nix-envrc-file ()
  "If it doesn't already exist create a .envrc file containing 'use
nix' in the current directory."
  (interactive)
  (let ((envrc (expand-file-name ".envrc")))
    (if (file-exists-p envrc)
        (message "Envrc file already exists")
      (write-region "use nix" nil envrc))))

(defun kenran/project-vterm ()
  "Open a `vterm' session in the project root of the current
project.  Prompt if no project can be found."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (vterm)))

(defun kenran/project-edit-dir-local-variable (mode variable value)
  "Edit directory-local variables in the root directory of the
current project."
  (interactive
   ;; Taken from `add-dir-local-variable', as I don't know of a better
   ;; way to simply wrap that command.
   (let (variable)
     (require 'files-x)
     (list
      (read-file-local-variable-mode)
      (setq variable (read-file-local-variable "Add or edit directory-local variable"))
      (read-file-local-variable-value variable))))
  (let ((default-directory (project-root (project-current t))))
    (modify-dir-local-variable mode variable value 'add-or-replace)))
#+end_src

One tricky thing was making it possible to bind the keymap
=project-prefix-map= to a key.  One needs to make it callable via =fset=.

#+begin_src elisp
(use-package project
  :config
  (fset 'project-prefix-map project-prefix-map)
  (setq project-switch-commands
        '((project-find-file "Find file")
          (consult-ripgrep "Grep" ?g)
          (magit-status "Git status" ?v)
          (project-dired "Dired")
          (project-eshell "Eshell")
          (kenran/project-vterm "Vterm" ?t)))
  :bind (:map project-prefix-map
              ("t" . kenran/project-vterm)
              ("d" . project-dired)
              ("D" . kenran/project-edit-dir-local-variable)))

(with-leader
  "p" '(project-prefix-map :which-key "project"))
#+end_src

** Magit

#+begin_src elisp
(use-package magit
  :hook (git-commit-mode . evil-insert-state)
  :custom
  ;; No autosave for open buffers, as that might trigger hooks and
  ;; such.
  (magit-save-repository-buffers nil)
  (magit-diff-refine-hunk t)
  :config
  ;; I frequently pull with the autostash option.
  (transient-append-suffix 'magit-pull "-r"
    '("-a" "Autostash" "--autostash"))
  ;; ESC as alternative to C-g for going 'back' one transient level.
  (define-key transient-map [escape] #'transient-quit-one))
#+end_src

*** Show todos/fixmes/... in status buffers

=magit-todos= shows lists of the keywords of =hl-todo-mode= in
=magit-status= buffers, as well as in a dedicated list of todos
accessible with =magit-todos-list=.  Note: The items have to be followed
by a colon (more specifically, check out =magit-todos-keyword-suffix=).

#+begin_src elisp
(use-package magit-todos
  :after (magit hl-todo)
  :config
  (magit-todos-mode)
  (setq magit-todos-rg-extra-args '("-M 120")))
#+end_src

*** Interactively browse =git= history

#+begin_src elisp
(use-package git-timemachine
  :defer t)
#+end_src

*** Keybindings

=Magit=-specific keybindings are useful in a global scope, thus they may
be accessed under =SPC g=.

#+begin_src elisp
(with-leader
  "g" '(:ignore t :which-key "git")
  "g i" '(magit-gitignore :which-key "ignore")
  "g I" '(magit-init :which-key "init")
  "g s" '(magit-project-status :which-key "status")
  "g S" '(magit-status-here :which-key "status here")
  "g l" '(magit-log :which-key "log")
  "g f" '(magit-pull-from-upstream :which-key "pull")
  "g p" '(magit-push :which-key "pull")
  "g d" '(magit-dispatch :which-key "show dispatch popup")
  "g t" '(magit-todos-list :which-key "todos"))
#+end_src

*** VC annotations on the side

#+begin_src elisp
(use-package git-gutter
  :diminish git-gutter-mode
  :config
  (global-git-gutter-mode t))

(with-leader
  "g g" '(:ignore t :which-key "gutter")
  "g g n" 'git-gutter:next-hunk
  "g g p" 'git-gutter:previous-hunk)
#+end_src

*** Modes for other kinds of =git=-related files

It's useful to have a little bit of syntax highlighting in files like
=.gitignore= or =.gitattributes=.  The =git-modes= package provides just
that, and autoloads the specific modes for the respective file types.
Like its readme proposes it's also possible to reuse the
=gitignore-mode= for other things, in this case =.dockerignore= files.

#+begin_src elisp
(use-package git-modes
  :defer t
  :init
  (add-to-list 'auto-mode-alist
               (cons "/.dockerignore\\'" 'gitignore-mode)))
#+end_src

** LISP editing with Lispy and Lispyville

#+begin_src elisp
(use-package lispy
  :hook
  ((emacs-lisp-mode
    lisp-mode
    clojure-mode
    clojurec-mode
    clojurescript-mode
    common-lisp-mode
    racket-mode
    racket-repl-mode
    sly-mrepl-mode)
   . lispy-mode))
#+end_src

#+begin_src elisp
(use-package lispyville
  :hook
  (lispy-mode . lispyville-mode)
  :config
  (with-eval-after-load 'lispyville
    (lispyville-set-key-theme
     '(operators
       c-w
       c-u
       prettify
       slurp/barf-cp
       text-objects
       additional
       additional-insert))))
#+end_src

** Highlight "todo", "fixme" and other keywords everywhere.

#+begin_src elisp
(use-package hl-todo
  :init
  (add-hook 'after-init-hook 'global-hl-todo-mode))
#+end_src

** Display commands bound to keys in the minibuffer

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src elisp
(use-package which-key
  :defer t
  :custom
  (which-key-idle-delay 0.3)
  :diminish which-key-mode
  :init
  ;; See https://github.com/justbur/emacs-which-key/issues/306
  (if (daemonp)
      (add-hook 'server-after-make-frame-hook 'which-key-mode)
    (add-hook 'after-init-hook 'which-key-mode)))
#+end_src

** Beautiful font icons

Attach beautiful symbols to, for instance, file names in a =dired= or
=ibuffer= buffer.

#+begin_src elisp
(use-package all-the-icons)

(use-package all-the-icons-dired
  :defer t
  :diminish all-the-icons-dired-mode
  :init
  (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

(use-package all-the-icons-ibuffer
  :defer t
  :init
  (all-the-icons-ibuffer-mode 1))
#+end_src

** Annotate minibuffer completions

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in =C-h v=, file sizes
and permissions in =C-x C-f=, and much more.

#+begin_src elisp
(use-package marginalia
  :init
  (marginalia-mode)
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit 'keep-selected))))
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle)))
#+end_src

** Make Emacs =direnv=-sensitive

Steve Purcell's [[https://github.com/purcell/envrc][envrc]] package is an alternative to [[https://github.com/wbolster/emacs-direnv][emacs-direnv]].  The
latter has a long-standing issue where it sometimes loads too late,
that is, /after/ packages like =lsp-mode= would need it.  =envrc= has worked
flawlessly so far.  Note: this should probably be one of the last
modes to load, as the hook function is then placed before the other
modes to ensure =direnv= integration is working as expected.

#+begin_src elisp
(use-package envrc
  :defer t
  :init (envrc-global-mode))
#+end_src

** Fast grepping via =ripgrep=

I use [[https://github.com/BurntSushi/ripgrep][ripgrep]] on the command line a lot.  This packages makes it
comfortably usable from within Emacs.

#+begin_src elisp
(use-package ripgrep
  :defer t)
#+end_src

** Interactive window switching

#+begin_src elisp
(use-package ace-window
  :defer t
  :init
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r))
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5))
#+end_src

*** Keybindings

=C-l= is a normal Emacs hotkey that I don't need or use because of =evil=,
and in the modes that I've disabled =evil= for I don't use it either.
It thus seems like a good choice to have as a fallback for window
management, as especially in terminal or shell modes I like being able
to use =C-w= like in a terminal or in vim.  I used to bind
='evil-window-map= to =C-l=, but perhaps it's also a good key to have
='ace-window= on as in most cases it's what I'd use anyway.

#+begin_src elisp
(general-define-key
 :states '(normal visual motion operator insert emacs)
 :keymaps 'override
 "C-l" 'ace-window)
#+end_src

** Hydra

TODO

#+begin_src elisp
(use-package hydra)
#+end_src

** Global font scaling

#+begin_src elisp
(use-package default-text-scale
  :defer t
  :after hydra
  :config
  (setq default-text-scale-amount 10))

(defhydra hydra-global-zoom (:hint nil :timeout 3)
  "
  Change the font size globally.\n
  _g_: increase
  _l_: decrease\n
  "
  ("g" default-text-scale-increase)
  ("l" default-text-scale-decrease)
  ("r" (lambda ()
         (interactive)
         (setq default-text-scale--complement 0)
         (face-spec-set 'default `((t (:height ,kenran/default-font-height))))
         (set-face-attribute 'default nil
                             :height kenran/default-font-height))
   "reset" :color blue)
  ("s" (lambda (height)
         (interactive "nFont size: ")
         (set-face-attribute 'default nil
                             :height height))
   "set size" :color blue)
  ("q" nil "exit"))

(with-leader
  "s s" '(hydra-global-zoom/body :which-key "font zoom"))
#+end_src

** Edit =grep= results over multiple buffers

#+begin_src elisp
(use-package wgrep
  :defer t
  :custom
  ((wgrep-auto-save-buffer t)
   (wgrep-change-readonly-file nil)
   (wgrep-too-many-file-length 15)))
#+end_src

** Improve garbage collector behavior

#+begin_src elisp
(use-package gcmh
  :diminish gcmh-mode
  :init
  (gcmh-mode 1))
#+end_src
