* TODOs
** General [0/14]
- [ ] embark?
- [ ] mu4e/notmuch
- [ ] dired+
- [ ] lsp
- [ ] ripgrep
- [ ] magit-todos
- [ ] pass
- [ ] doom-modeline?
- [ ] windows/avy?
- [ ] format on save
- [ ] delayed init with new emacs version?
- [ ] snippets, for instance for org src blocks
- [ ] hydra for certain keymaps
- [ ] flycheck

** Languages [0/3]
- [ ] more org
- [ ] haskell
- [ ] data formats (json, yaml, csv, ...)

* Config
** General settings
*** Separate file for customizations

We do not want to append it to our =init.el=.

#+begin_src emacs-lisp

  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file 'no-error)

#+end_src

*** Disable any bars and the splash screen

Disable the graphical GUI things like the menu bar, the splash screen,
and others.

#+begin_src emacs-lisp

  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)

  (setq inhibit-splash-screen t)

#+end_src

*** More visible cursor

The default cursor is black, which interferes with mostly using a dark
theme. Thus we brighten it up a bit.

#+begin_src emacs-lisp

  (set-mouse-color "white")

#+end_src

*** Focus help buffers

We want point to be inside newly opening help buffers so we may
quickly close them with =q=.

#+begin_src emacs-lisp

  (setq help-window-select t)

#+end_src

*** Theme(s)

Since I cannot ever decide which theme I like best, there are a few
themes installed in my nix configuration:
- [[https://github.com/belak/base16-emacs][base16 themes for Emacs]]
- [[https://protesilaos.com/modus-themes/][Modus Vivendi by Protesilaos Stavrou]]
- [[https://gitlab.com/ideasman42/emacs-inkpot-theme][InkPot theme for Emacs]]

#+begin_src emacs-lisp

  ;; (use-package base16-theme
  ;;   :ensure nil
  ;;   :config (load-theme 'base16-atelier-forest t))

  (use-package inkpot-theme
    :ensure nil
    :config (load-theme 'inkpot t))

  ;; (use-package modus-vivendi-theme
  ;;   :ensure nil
  ;;   :config (load-theme 'modus-vivendi t))

#+end_src

*** Shorter yes/no question answers

Answering a question with =yes= instead of just =y= is just annoying.

#+begin_src emacs-lisp

  (fset 'yes-or-no-p 'y-or-n-p)

#+end_src

*** Font faces

#+begin_src emacs-lisp

  (defvar my/monospace-font "Anonymous Pro")
  (defvar my/variable-font "Cantarell")
  (set-face-attribute 'default nil :font my/monospace-font :height 140)
  (set-face-attribute 'fixed-pitch nil :font my/monospace-font :height 140)
  (set-face-attribute 'variable-pitch nil :font my/variable-font :height 150)

#+end_src

**** Line numbers in programming modes

#+begin_src emacs-lisp

(use-package display-line-numbers
  :ensure nil
  :hook ((prog-mode . display-line-numbers-mode))
         (conf-mode . display-line-numbers-mode))

#+end_src

** Package-specific configuration
*** Better help pages (helpful)

This gives us better and more readable help pages. We also replace
some built-in =C-h= keybings with =helpful-*= functions.

#+begin_src emacs-lisp

  (use-package helpful
    :ensure nil
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)))

#+end_src

*** Keybinding management (general)

The [[https://github.com/noctuid/general.el][general]] package allows us to easily define keybindings.

#+begin_src emacs-lisp

  (use-package general
    :ensure nil)

#+end_src

**** TODO find out whether I still need general without evil-mode

*** Project-wide searches, movement, etc. (projectile)

#+begin_src emacs-lisp

  (use-package projectile
    :ensure nil
    :init
    (projectile-mode +1))

#+end_src

*** Magit

/The/ Git frontend.

#+begin_src emacs-lisp

  (use-package magit
    :ensure nil)

#+end_src

**** TODO learn about magit-dispatch

*** Auto-closing parentheses and sexp motions (smartparens)

#+begin_src emacs-lisp

  (use-package smartparens
    :ensure nil
    :init
    (smartparens-global-mode 1))

#+end_src

*** Incremental narrowing/completion UI in Emacs (selectrum & orderless)

I started with =helm= in Spacemacs, then later switched to Doom Emacs
where after a while I tried out =ivy= and loved it. Now I want to try
out the new, fast, and cool [[https://github.com/raxod502/selectrum][selectrum]].

#+begin_src emacs-lisp

  (use-package selectrum
    :ensure nil
    :init
    (selectrum-mode +1))

#+end_src

[[https://github.com/oantolin/orderless][orderless]] is a completion style that fits in very well with
=selectrum=. I still have to learn how to specify/request different
types of completion in a query, like matching the first word as
initialism, the second as regexp, and so forth.

#+begin_src emacs-lisp

  (use-package orderless
    :ensure nil
    ;; TODO customize?
    :custom (completion-styles '(orderless)))

#+end_src

*** Completion framework (company)

I use [[https://company-mode.github.io/][company-mode]] for (global) auto-completion.

#+begin_src emacs-lisp

  (use-package company
    :ensure nil
    :init
    (add-hook 'after-init-hook 'global-company-mode))

#+end_src

*** Highlight TODO items and others (hl-todo-mode)

Highlight =TODO=, =FIXME=, etc. in basically every mode and buffer.

#+begin_src emacs-lisp

  (use-package hl-todo
    :ensure nil
    :init
    (add-hook 'after-init-hook 'global-hl-todo-mode))

#+end_src

**** TODO configure the possible states, probably after finishing GTD

*** Window switching
**** TODO switch-window or ace-window?

#+begin_src emacs-lisp

  (use-package switch-window
    :ensure nil)

#+end_src

*** Show the bound keys (which-key)

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src emacs-lisp

  (use-package which-key
    :ensure nil
    :init
    (add-hook 'after-init-hook 'which-key-mode))

#+end_src

*** Symbols (all-the-icons)

Attach beautiful symbols to, for instance, file names in a =dired= or
=ibuffer= buffer.

#+begin_src emacs-lisp

  (use-package all-the-icons
    :ensure nil)

  (use-package all-the-icons-dired
    :ensure nil
    :init
    (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

  (use-package all-the-icons-ibuffer
    :ensure nil
    :init
    (all-the-icons-ibuffer-mode 1))

#+end_src

*** Informative annotations (marginalia)

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in "C-h v", file
sizes and permissions in "C-x C-f", and much more.

#+begin_src emacs-lisp

  (use-package marginalia
    :init
    (marginalia-mode)
    (advice-add #'marginalia-cycle :after
                (lambda () (when (bound-and-true-p selectrum-mode)
                             (selectrum-exhibit 'keep-selected))))
    :config
    (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :bind
    (:map minibuffer-local-map
          ("M-A" . marginalia-cycle)))

#+end_src

*** Buffer-local direnv variables (envrc)

Let's try out [[https://github.com/purcell/envrc][Steve Purcell's envrc package]] as an alternative to
direnv-mode.

#+begin_src emacs-lisp

  (use-package envrc
    :ensure nil)

#+end_src

*** Language-specific modes
**** Nix (nix-mode)

Syntax highlighting, completion, and formatting of [[https://nixos.org/guides/install-nix.html][Nix]] expressions.

#+begin_src emacs-lisp

  (use-package nix-mode
    :ensure nil
    :mode "\\.nix\\'")

#+end_src

**** Markdown (markdown-mode, gfm-mode)

Enable GitHub-flavored markdown mode for =README= files, and regular
=markdown-mode= for all other markdown files.

#+begin_src emacs-lisp

  (use-package markdown-mode
    :ensure nil
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "pandoc"))

#+end_src

**** Org (org-mode)

When using variable-pitch-mode, all the faces are using the configured
font face. But inside code blocks, verbatim text, meta lines, etc. a
fixed-pitch face is what we want to be using.

#+begin_src emacs-lisp

  (defun my/setup-org-fonts ()
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch)))

#+end_src

To fix =org-indent-mode= not indenting variable-pitch fonts nicely,
we'd like to use the fixed-pitch font for that as well. Unfortunately
setting the face attribute as above didn't work as expected and it
seems necessary to do it like this.

#+begin_src emacs-lisp

  (with-eval-after-load 'org-indent
    (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch)))

#+end_src

When writing text in org-mode, auto-fill-mode should be enable to
automatically break overly long lines into smaller pieces when
typing. We may still use =M-q= to re-fill paragraph when editing text.

In code blocks, =TAB= should be usable to re-indent/-format code.

After loading org-mode, we then run our custom font setup.

#+begin_src emacs-lisp

  (use-package org
    :ensure nil
    :hook ((org-mode . org-indent-mode)
           (org-mode . variable-pitch-mode)
           (org-mode . auto-fill-mode))
    :config
    (setq org-src-tab-acts-natively t
          org-ellipsis " ▾")
    (my/setup-org-fonts))

#+end_src

The =org-bullets= packages enables us to use UTF-8 characters for the
bullet points in org headers.

#+begin_src emacs-lisp

  (use-package org-bullets
    :ensure nil
    :hook (org-mode . org-bullets-mode)
    :custom (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

Render unordered list bullet points as dots instead of minus/plus.

#+begin_src emacs-lisp

  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-+]\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

#+end_src

The first few levels of org headers should be scaled to be a bit
larger than the default text.

#+begin_src emacs-lisp

  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.15)
                  (org-level-3 . 1.1)
                  (org-level-4 . 1.05)
                  (org-level-5 . 1.0)
                  (org-level-6 . 1.0)
                  (org-level-7 . 1.0)
                  (org-level-8 . 1.0)))
    (set-face-attribute (car face) nil
                        :font my/variable-font
                        :height (cdr face)
                        :weight 'regular))

#+end_src
