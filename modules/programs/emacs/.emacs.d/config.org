* Config
** Increase GC threshold

Emacs startup can be significantly sped up by reducing the number of
garbage collections that take place during initialization. The default
=gc-cons-threshold= of 80 kilobytes is way too low for any more recent
system. Still it's beneficial to reset this temporary value back to a
lower number after initialization. That way the GC pause won't be as
long when working within Emacs.

#+begin_src emacs-lisp

(setq gc-cons-threshold (* 100 1000 1000))

#+end_src

** General settings
*** Use-package

When using byte-compiled config files, which I do, then loading
use-package before using it is required.

#+begin_src emacs-lisp

(require 'use-package)

#+end_src

Since I use [[https://github.com/nix-community/home-manager][home-manager]] to manage my dotfiles, user environment and
in particular Emacs (including packages) I have the guarantee that
those packages are coming from Nix instead of having to be
downloaded. This is why I usually specify =:ensure nil= in my
=use-package= calls.

Maybe this is bad, but I'm sticking with it for now. Hence this little
macro comes in handy:

#+begin_src emacs-lisp

(defmacro use-package! (package-name &rest args)
  "Like use-package but prepends :ensure nil."
  (declare (indent defun))
  `(use-package ,package-name
     :ensure nil
     ,@args))

#+end_src

*** Keybindings (general)

The [[https://github.com/noctuid/general.el][general]] package allows us to easily define keybindings. This is
especially useful for =evil-mode=.

#+begin_src emacs-lisp

(use-package! general)

#+end_src

*** Separate file for customizations

We do not want to append it to our =init.el=.

#+begin_src emacs-lisp

(setq custom-file (concat user-emacs-directory "custom.el"))
(load custom-file 'no-error)

#+end_src

*** Measure the startup time

I want to know how fast my emacs is starting. I'm not sure how to make
use of all that =use-package= has to offer in that regard yet, but I
want to at least see when I've made things worse.

#+begin_src emacs-lisp

(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs startup took %s with %d garbage collections"
                     (format "%.2f seconds"
                             (float-time (time-subtract after-init-time before-init-time)))
                     gcs-done)))

#+end_src

*** Disable any bars and the splash screen

Disable the graphical GUI things like the menu bar, the splash screen,
and others.

#+begin_src emacs-lisp

(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)

(setq inhibit-splash-screen t)

#+end_src

*** More visible cursor

The default cursor is black, which interferes with mostly using a dark
theme. Thus we brighten it up a bit.

#+begin_src emacs-lisp

(set-mouse-color "white")
(add-hook 'server-after-make-frame-hook (lambda () (set-mouse-color "white")))

#+end_src

*** Focus help buffers

We want point to be inside newly opening help buffers so we may
quickly close them with =q=.

#+begin_src emacs-lisp

(setq help-window-select t)

#+end_src

*** Theme(s)

Since I cannot ever decide which theme I like best, there are a few
themes, or collections thereof, installed in my nix configuration:

+ [[https://protesilaos.com/modus-themes/][Modus Vivendi by Protesilaos Stavrou]]
+ [[https://github.com/hlissner/emacs-doom-themes][doom-themes]]
+ [[https://github.com/emacs-jp/replace-colorthemes][color-theme-modern]]

#+begin_src emacs-lisp

(use-package! modus-vivendi-theme
  :config (load-theme 'modus-vivendi t))

;; (use-package! doom-themes
;;   :config (load-theme 'doom-sourcerer t))

;; (use-package! color-theme-modern
;;   :config
;;   (load-theme 'taming-mr-arneson t t)
;;   (enable-theme 'taming-mr-arneson))

#+end_src

*** Shorter yes/no question answers

Answering a question with =yes= instead of just =y= is just annoying.

#+begin_src emacs-lisp

(fset 'yes-or-no-p 'y-or-n-p)

#+end_src

*** Font faces

#+begin_src emacs-lisp

(defvar my/monospace-font "IBM Plex Mono")
(defvar my/variable-font "Cantarell")

(defun my/set-face-attributes ()
  (set-face-attribute 'default nil :font my/monospace-font :height 130)
  (set-face-attribute 'fixed-pitch nil :font my/monospace-font :height 0.8)
  (set-face-attribute 'variable-pitch nil :font my/variable-font :height 1.2))

(my/set-face-attributes)
(add-hook 'server-after-make-frame-hook #'my/set-face-attributes)

#+end_src

*** Line numbers in programming modes

#+begin_src emacs-lisp

(use-package! display-line-numbers
  :hook ((prog-mode . display-line-numbers-mode))
  (conf-mode . display-line-numbers-mode))

#+end_src

*** Insert newline at the end of files

#+begin_src emacs-lisp

(setq require-final-newline t
      mode-require-final-newline t)

#+end_src

*** Hide warnings from asynchronous native compilation

When using the =native-comp= branch that is soon to be merged into the
main Emacs branch a lot of warnings show up during startup and
changing modes. We could increase the minimum severity for logs to be
shown by setting =warning-minimum-level= to =:error= or disable the
warnings for native compilation entirely like this:

#+begin_src emacs-lisp

(setq comp-async-report-warnings-errors nil)

#+end_src

*** Use spaces for indentation by default

#+begin_src emacs-lisp

(setq-default indent-tabs-mode nil)

#+end_src

** Package-specific configuration
*** Language-specific modes
**** Nix (nix-mode)

Syntax highlighting, completion, and formatting of [[https://nixos.org/guides/install-nix.html][Nix]] expressions.

#+begin_src emacs-lisp

(use-package! nix-mode
  :mode "\\.nix\\'")

#+end_src

**** Markdown (markdown-mode, gfm-mode)

Enable GitHub-flavored markdown mode for =README= files, and regular
=markdown-mode= for all other markdown files.

#+begin_src emacs-lisp

(use-package! markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc"))

#+end_src

**** Org (org-mode)

When using variable-pitch-mode, all the faces are using the configured
font face. But inside code blocks, verbatim text, meta lines, etc. a
fixed-pitch face is what we want to be using.

#+begin_src emacs-lisp

(defun my/setup-org-fonts ()
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block-begin-line nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch)))

#+end_src

To fix =org-indent-mode= not indenting variable-pitch fonts nicely,
we'd like to use the fixed-pitch font for that as well. Unfortunately
setting the face attribute as above didn't work as expected and it
seems necessary to do it like this.

#+begin_src emacs-lisp

(use-package! org-indent
  :diminish org-indent-mode)

(with-eval-after-load 'org-indent
  (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch)))

#+end_src

When writing text in org-mode, auto-fill-mode should be enable to
automatically break overly long lines into smaller pieces when
typing. We may still use =M-q= to re-fill paragraph when editing text.

After loading org-mode, we then run our custom font setup.

#+begin_src emacs-lisp

(use-package! org
  :hook ((org-mode . variable-pitch-mode)
         (org-mode . auto-fill-mode)
         (org-trigger . save-buffer))
  :custom ((org-startup-indented t)
           (org-ellipsis " ▾")
           (org-startup-folded 'content)
           (org-directory "~/org")
           (org-log-done t)
           (org-special-ctrl-a/e t)
           ;; If this has a value greater than 0, every RET press
           ;; keeps indenting the source block further and further.
           (org-edit-src-content-indentation 0)
           (org-default-notes-file "~/org/notes.org")
           (org-agenda-files '("~/org/inbox.org"
                               "~/org/gtd.org"
                               "~/org/someday.org"))
           (org-refile-targets `(("~/org/gtd.org" :maxlevel . 3)
                                 ("~/org/someday.org" :level . 1)))
           (org-capture-templates '(("t" "Todo" entry
                                     (file+headline "~/org/inbox.org" "Tasks")
                                     "* TODO %i%?")
                                    ("n" "Note" entry
                                     (file+headline "~/org/notes.org" "Notes")
                                     "* %?\n%a\nNote taken on %U")))
           (org-todo-keywords '((sequence
                                 "TODO(t)"
                                 "WAITING(w)"
                                 "|"
                                 "DONE(d)"
                                 "CANCELLED(c)"))))
  :bind (("C-c c" . org-capture)
         ("C-c l" . org-store-link))
  :config
  (my/setup-org-fonts))

#+end_src

The =org-bullets= packages enables us to use UTF-8 characters for the
bullet points in org headers.

#+begin_src emacs-lisp

(use-package! org-bullets
  :hook (org-mode . org-bullets-mode)
  :custom (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

Render unordered list bullet points as dots instead of minus/plus.

#+begin_src emacs-lisp

(font-lock-add-keywords
 'org-mode
 '(("^ *\\([-+]\\) "
    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

#+end_src

The first few levels of org headers should be scaled to be a bit
larger than the default text.

#+begin_src emacs-lisp

(dolist (face '((org-level-1 . 1.2)
                (org-level-2 . 1.15)
                (org-level-3 . 1.1)
                (org-level-4 . 1.05)
                (org-level-5 . 1.0)
                (org-level-6 . 1.0)
                (org-level-7 . 1.0)
                (org-level-8 . 1.0)))
  (set-face-attribute (car face) nil
                      :font my/variable-font
                      :height (cdr face)
                      :weight 'regular))

#+end_src

For short presentations, [[https://github.com/rlister/org-present][org-present]] looks like it is a good option.

#+begin_src emacs-lisp

  (use-package! org-present
      :hook ((org-present-mode . (lambda ()
                                 (org-present-big)
                                 (org-display-inline-images)
                                 (org-present-hide-cursor)
                                 (org-present-read-only)))
           (org-present-mode-quit . (lambda ()
                                      (org-present-small)
                                      (org-remove-inline-images)
                                      (org-present-show-cursor)
                                      (org-present-read-write)))))

#+end_src

**** Haskell (haskell-mode)

We use the standard haskell-mode for now. Might add LSP configuration
later, but I'm not sure whether to take the lsp-mode route again or
try out eglot.

#+begin_src emacs-lisp

(use-package! haskell-mode
  :custom
  (haskell-process-type 'cabal-repl)
  :hook (haskell-mode . interactive-haskell-mode))

#+end_src

**** Dhall (dhall-mode)

#+begin_src emacs-lisp

(use-package! dhall-mode
  :mode "\\.dhall\\'")

#+end_src

**** Docker (dockerfile-mode)

#+begin_src emacs-lisp

(use-package! dockerfile-mode)

#+end_src

***** TODO check out TRAMP and docker-tramp

**** YAML (yaml-mode)

#+begin_src emacs-lisp

(use-package! yaml-mode)

#+end_src

**** Clojure (clojure-mode)

#+begin_src emacs-lisp

(use-package! clojure-mode)

#+end_src

**** CSV files (csv-mode)

#+begin_src emacs-lisp

(use-package! csv-mode)

#+end_src

**** LSP client (eglot)

I've used =lsp-mode= in the past and while it's nice, I feel like it's
more in line with the rest of this configuration to try out something
more lightweight and closer to vanilla Emacs. This is where [[https://github.com/joaotavora/eglot][eglot]]
comes into play.

#+begin_src emacs-lisp

(use-package! eglot
  :hook (haskell-mode . eglot-ensure))

#+end_src
*** Vim emulation with evil
**** Space as leader key

Having a dedicated leader key (=SPC= in my case) is one of the most
important things to me as it opens up a lot of possibilities for
creating custom keymaps. The keybindings naturally do not clash with
the default Emacs-style bindings many packages introduce. I will use
this to try and create more vim-inspired mnemonic keybindings (say,
=p= for project-specific commands, =g= for =git= etc.)

#+begin_src emacs-lisp

(general-create-definer with-leader
  :prefix "SPC")

#+end_src

**** Evil

The [[https://github.com/emacs-evil/evil][evil]] package offers a very complete vim experience inside of
Emacs.

#+begin_src emacs-lisp

(use-package! evil
  :config
  (evil-mode 1)
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil))

#+end_src

**** Integrate evil with a lot of other modes (evil-collection)

This package makes it possible to enable evil-mode (and therefore have
a more vim-ish feel) in lots of (mostly minor) modes. I'm not sure
whether I wish to use all of these (I think I don't need evil in
shells and REPLs), but I'll give them a try.

#+begin_src emacs-lisp

(use-package! evil-collection
  :after evil
  :config
  ;; Register the mode-specific bindings
  ;; (evil-collection-init 'apropos) ;; TODO
  ;; (evil-collection-init 'cider) ;; TODO
  ;; (evil-collection-init 'company) ;; TODO
  (evil-collection-init 'dired) ;; TODO
  ;; (evil-collection-init 'dired-sidebar) ;; TODO
  ;; (evil-collection-init 'ediff) ;; TODO
  (evil-collection-init 'elisp-mode) ;; TODO
  ;; (evil-collection-init 'flycheck) ;; TODO
  (evil-collection-init 'ibuffer) ;; TODO
  (evil-collection-init 'magit) ;; TODO
  ;; (evil-collection-init 'magit-todos) ;; TODO
  ;; (evil-collection-init 'pass) ;; TODO
  ;; (evil-collection-init 'ripgrep) ;; TODO
  (evil-collection-init 'which-key) ;; TODO check
  )

#+end_src

**** Evil-surround

The analogue of [[https://github.com/tpope/vim-surround][Tim Pope's vim-surround plugin]] in Emacs. Now I can use
things like:
+ =ysiw)= to surround an inner word with non-padded normal parentheses,
+ =ds]= to delete surrounding brackets, or
+ =cd[{= to change surrounding brackets to curly braces with
  whitespace padding.

#+begin_src emacs-lisp

(use-package! evil-surround
  :config
  (global-evil-surround-mode))

#+end_src

*** Emacs as email client (notmuch)

I've tried and used mu4e in the past, but always liked the idea of
notmuch better. I'll give notmuch a shot now that I have a working
syncthing setup to sync my tag database.

#+begin_src emacs-lisp

(setq user-full-name "Johannes Maier")

(use-package! notmuch
  :defer t
  :config
  (setq user-mail-address "johannes.maier@mailbox.org")
  :custom
  (message-send-mail-function 'message-send-mail-with-sendmail)
  (message-kill-buffer-on-exit t)
  (message-sendmail-envelope-from 'header)
  (mail-envelope-from 'header)
  (mail-specify-envelope-from 'header)
  (mail-user-agent 'message-user-agent)
  (notmuch-show-all-multipart/alternative-parts nil)
  (notmuch-always-prompt-for-sender t))

#+end_src

To switch identities (which I basically only use to set my work
signature based on my From address), I use gnus-alias.

#+begin_src emacs-lisp

(use-package! gnus-alias
  :config
  (setq gnus-alias-identity-alist
        `(("mailbox"
           nil
           "Johannes Maier <johannes.maier@mailbox.org>"
           nil
           nil
           nil
           nil)
          ("ag"
           nil
           "Johannes Maier <johannes.maier@active-group.de>"
           "Active Group GmbH"
           nil
           nil
           ,(concat "Johannes Maier\n"
                    "johannes.maier@active-group.de\n\n"
                    "+49 (7071) 70896-67\n\n"
                    "Active Group GmbH\n"
                    "Hechinger Str. 12/1\n"
                    "72072 Tübingen\n"
                    "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                    "Geschäftsführer: Dr. Michael Sperber"))))
  (setq gnus-alias-default-identity "mailbox")
  (setq gnus-alias-identity-rules
        '(("ag" ("any" "@active-group.de" both) "ag")))
  :init
  (add-hook 'message-setup-hook 'gnus-alias-determine-identity))

#+end_src

*** Hide modes in the mode line (diminish)

The [[https://github.com/myrjola/diminish.el][diminish]] package enables us to hide minor modes from the mode
line. It's especially useful for certain modes that are globally
enabled anyway. Use-package has built-in support for it available with
the =:diminish= keyword.

#+begin_src emacs-lisp

(use-package! diminish)

#+end_src

*** Better help pages (helpful)

This gives us better and more readable help pages. We also replace
some built-in =C-h= keybings with =helpful-*= functions.

#+begin_src emacs-lisp

(use-package! helpful
  :bind (("C-h f" . helpful-callable)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)))

#+end_src

*** Project-wide searches, movement, etc. (projectile)

#+begin_src emacs-lisp

(use-package! projectile
  :init
  (projectile-mode +1)
  :bind-keymap ("C-x p" . projectile-command-map))

#+end_src

I'll leave the original =C-x p= binding in for now, but I'm planning
to use the leader key for this as it's a bit easier to type (quickly).

#+begin_src emacs-lisp

(with-leader
  :states '(normal visual)
  "p" 'projectile-command-map)

#+end_src

*** Magit

/The/ Git frontend.

#+begin_src emacs-lisp

(use-package! magit)

#+end_src

**** Keybindings

#+begin_src emacs-lisp

(with-leader
  :states '(normal visual)
  "g g" 'magit-status)

#+end_src

**** TODO learn about magit-dispatch

*** Auto-closing parentheses and sexp motions (smartparens)

#+begin_src emacs-lisp

(use-package! smartparens
  :diminish smartparens-mode
  :config
  (sp-pair "'" nil :actions nil)
  :bind (("C-M-a" . sp-beginning-of-sexp)
         ("C-M-e" . sp-end-of-sexp)
         ("C-<down>" . sp-down-sexp)
         ("C-<up>" . sp-up-sexp)
         ("M-<down>" . sp-backward-down-sexp)
         ("M-<up>" . sp-backward-up-sexp)
         ("C-M-f" . sp-forward-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-n" . sp-next-sexp)
         ("C-M-p" . sp-previous-sexp)
         ;; TODO forward/backward symbol?
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-<left>" . sp-backward-slurp-sexp)
         ("M-<right>" . sp-forward-barf-sexp)
         ("M-<left>" . sp-backward-barf-sexp)
         ("C-M-t" . sp-transpose-sexp)
         ("C-M-k" . sp-kill-sexp)
         ("C-k" . sp-kill-hybrid-sexp)
         ("M-k" . sp-backward-kill-sexp)
         ("C-M-w" . sp-copy-sexp)
         ("C-M-d" . sp-delete-sexp)
         ;; TODO wrap with parens/brackets/braces/...
         )
  :init
  (smartparens-global-mode t)
  ;; Enable smartparens-strict-mode for all LISP modes listed in
  ;; sp-lisp-modes.
  (mapc
   (lambda (mode)
     (add-hook
      (intern (format "%s-hook" (symbol-name mode)))
      'smartparens-strict-mode))
   sp-lisp-modes))

#+end_src

*** Incremental narrowing/completion UI in Emacs (selectrum & orderless)
**** Selectrum

I started with =helm= in Spacemacs, then later switched to Doom Emacs
where after a while I tried out =ivy= and loved it. Now I want to try
out the new, fast, and cool [[https://github.com/raxod502/selectrum][selectrum]].

#+begin_src emacs-lisp

(use-package! selectrum
  :init
  (selectrum-mode +1))

#+end_src

**** Orderless

[[https://github.com/oantolin/orderless][orderless]] is a completion style that fits in very well with
=selectrum=. Parts of a search string may match according to several
matching styles. We want to be able to specify which matching style to
use by appending a suffix so a search string. Therefore we define
/style dispatchers/ and use them to customize
=orderless-style-dispatchers=.

Appending a === to a search term will search for literal matches of
the preceding string.

#+begin_src emacs-lisp

(defun my/literal-if-= (pattern _index _total)
  (when (string-suffix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 0 -1))))

#+end_src

An appended =!= discards everything that matches the preceding literal
string.

#+begin_src emacs-lisp

(defun my/without-if-! (pattern _index _total)
  (when (string-suffix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 0 -1))))

#+end_src

The =~= sign gives me a way to have "fuzzy" search, if needed.

#+begin_src emacs-lisp

(defun my/flex-if-~ (pattern _index _total)
  (when (string-suffix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 0 -1))))

#+end_src

Load the package lazily and use the custom style dispatchers.

#+begin_src emacs-lisp

(use-package! orderless
  :custom (completion-styles '(orderless))
  (orderless-style-dispatchers
   '(my/literal-if-=
     my/without-if-!
     my/flex-if-~)))

#+end_src

*** Completing-read improvements (consult)

The [[https://github.com/minad/consult][consult]] package is the analogue of counsel, which I used for quite
some time, though not in any extent close to full. This defines some
basic bindings mostly taken from an example in its readme.

#+begin_src emacs-lisp

(use-package! consult
  :after project
  :bind (;; C-x bindings
         ("C-x b" . consult-buffer)                ;; was switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; was switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; was switch-to-buffer-other-frame
         ;; C-h bindings (help)
         ("C-h a" . consult-apropos)
         ;; M-g bindings (goto)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)           ;; easier to type
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ;; M-s bindings (search)
         ("M-s f" . consult-find)
         ("M-s L" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines))
  :custom
  (consult-project-root-function
   (lambda ()
     (when-let (project (project-current))
       (project-root project)))))
;; TODO other isearch integration?
;; TODO :init narrowing, preview delay

#+end_src

**** TODO check out more of consult's commands [0/7]
+ [ ] consult-register/-load/-store ?
+ [ ] consult-history
+ [ ] consult-mode-command
+ [ ] consult-kmacro
+ [ ] consult-bookmark
+ [ ] consult-complex-command
+ [ ] consult-yank-pop

*** Completion framework (company)

I use [[https://company-mode.github.io/][company-mode]] for (global) auto-completion.

#+begin_src emacs-lisp

(use-package! company
  :diminish company-mode
  :init
  (add-hook 'after-init-hook 'global-company-mode))

#+end_src

*** Highlight TODO items and others (hl-todo-mode)

Highlight =TODO=, =FIXME=, etc. in basically every mode and buffer.

#+begin_src emacs-lisp

(use-package! hl-todo
  :init
  (add-hook 'after-init-hook 'global-hl-todo-mode))

#+end_src

**** TODO configure the possible states, probably after finishing GTD

*** Window switching
**** TODO switch-window or ace-window?

#+begin_src emacs-lisp

(use-package! switch-window)

#+end_src

*** Show the bound keys (which-key)

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src emacs-lisp

(use-package! which-key
  :custom
  (which-key-idle-delay 0.5)
  :diminish which-key-mode
  :init
  (add-hook 'after-init-hook 'which-key-mode))

#+end_src

*** Symbols (all-the-icons)

Attach beautiful symbols to, for instance, file names in a =dired= or
=ibuffer= buffer.

#+begin_src emacs-lisp

(use-package! all-the-icons)

(use-package! all-the-icons-dired
  :init
  (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

(use-package! all-the-icons-ibuffer
  :init
  (all-the-icons-ibuffer-mode 1))

#+end_src

*** Informative annotations (marginalia)

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in "C-h v", file
sizes and permissions in "C-x C-f", and much more.

#+begin_src emacs-lisp

(use-package! marginalia
  :init
  (marginalia-mode)
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit 'keep-selected))))
  :config
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle)))

#+end_src

*** Buffer-local direnv variables (envrc)

Let's try out [[https://github.com/purcell/envrc][Steve Purcell's envrc package]] as an alternative to
direnv-mode. Note: this should probably be one of the last modes to
load, as the hook function is then placed before the other modes to
ensure direnv integration is working as expected.

#+begin_src emacs-lisp

(use-package! envrc
  :init (envrc-global-mode))

#+end_src

*** Built-in packages
**** Diminish some minor modes

This is mainly here to diminish some built-in minor modes, although
it's of course possible to put some mode-specific configuration into
the =use-package= calls.

#+begin_src emacs-lisp

(use-package! face-remap
  :diminish buffer-face-mode)

(use-package! autorevert
  :diminish auto-revert-mode)

(use-package! simple
  :diminish auto-fill-function)

#+end_src

**** Dired
***** TODO dired itself
***** diredfl

[[https://github.com/purcell/diredfl][diredfl]] beautifies the dired buffers a bit by making things more
colorful.

#+begin_src emacs-lisp

(use-package! diredfl
  :hook (dired-mode . diredfl-mode))

#+end_src

*** Better, faster grepping (ripgrep)

I've gotten used to [[https://github.com/BurntSushi/ripgrep][ripgrep (rg)]] for lightning-fast recursive
searches/grepping over basically anything. This includes using the
projectile integration to quickly grep over all of a project's files.

#+begin_src emacs-lisp

(use-package! ripgrep)

#+end_src

** Reduce GC threshold again

#+begin_src emacs-lisp

(setq gc-cons-threshold (* 5 1000 1000))

#+end_src
