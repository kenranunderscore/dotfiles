#+TITLE: My GNU Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: showall

* Package management

I'm specifying the Emacs I'm using via [[https://github.com/nixos/nixpkgs][nixpkgs]] / my [[https://github.com/nix-community/home-manager][home-manager]]
setup, but for package management I'm currently using the now-built-in
=use-package= macro.  Having the packages come from =nixpkgs= (marked as
=external= in =list-packages=) is nice, but requires a =nixos-rebuild= and
restarting Emacs after making some changes.

FIXME: note on =straight=

Set up MELPA.

#+begin_src emacs-lisp
(require 'package)
(package-initialize)
(setq package-archives
      '(("gnu" . "https://elpa.gnu.org/packages/")
        ("melpa" . "https://melpa.org/packages/")))
#+end_src

And set up =use-package= itself in a way such that the =:ensure= keyword
is by default set to =t=, that is, =use-packages= ensures that the package
will be installed if it isn't already.

#+begin_src emacs-lisp
(require 'use-package)
(setq use-package-always-ensure t)
#+end_src

* Profiling the startup time

For no real reason whatsoever I like it when my Emacs starts up
quickly.  The =benchmark-init= package nicely profiles where the time
during startup went, and if a culprit is found, the "fix" is usually
to add =:defer= to a =use-package= call.

Note that this block is not tangled; I only run this when I encounter
weird behavior.

#+begin_src emacs-lisp :tangle no
(use-package benchmark-init
  :demand
  :config (benchmark-init/activate)
  :hook (after-init . benchmark-init/deactivate))
#+end_src

* Keybinding management

I used to use the [[https://github.com/noctuid/general][general]] package to define keybindings in a more
straightforward and declarative way.  But since this is especially
useful =evil-mode=, where I have to bind keys according to the current
mode, I decided to drop this as well while trying to live without
=evil= for a while.

#+begin_src emacs-lisp
(use-package emacs
  :bind
  ("C-h F" . describe-face)
  ("C-h M" . describe-keymap)
  ("C-h V" . set-variable)
  ("C-x C-o" . other-window)
  ("C-. b k" . kill-current-buffer)
  ("C-. b i" . ibuffer)
  ("C-. b p" . previous-buffer)
  ("C-. b n" . next-buffer)
  ("C-. c" . comment-or-uncomment-region))
#+end_src

* The region

While I like seeing the active region (which =transient-mark-mode=
highlights), commands still use the region anyway even if it's not
visible.  So I'll try living without this for now and see how it goes.

#+begin_src emacs-lisp
(setq-default transient-mark-mode nil)
#+end_src

One potential problem could be that I'm used to acting on the visible
region with things like =M-%=, but that's also one thing that comes from
=transient-mark-mode=.  I could instead choose to narrow to the region,
should I need this.  Let's just see how it goes...

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+end_src

* Loading additional ELisp configuration files

I do not want customizations done via =customize= to end up in this
file.  Use a separate file instead and load that one on startup.

#+begin_src emacs-lisp
(let ((my-custom-file (locate-user-emacs-file "custom.el")))
  (setq custom-file my-custom-file)
  (load custom-file 'no-error))
#+end_src

A quick way to jump to this file, and an accompanying keybinding, as I
do this /very often/.

#+begin_src emacs-lisp
(defun kenran/open-init-file ()
  "Open my config.org file."
  (interactive)
  (find-file (file-truename (locate-user-emacs-file "config.org"))))

(keymap-global-set "C-. e" 'kenran/open-init-file)
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.

One thing to pay attention to is that nearly all those operations on
"visuals" work slightly differently when starting Emacs as
=emacsclient=, for instance via

#+begin_src shell :tangle no
emacsclient -a ''
#+end_src

Setting some things at this point often results in the changes not
being applied correctly.  It's due to them happening in a technical,
invisible Emacs frame.  So you'll often see =(daemonp)= being called,
checking whether this instance of Emacs is using the daemon, then
adding some initializer function to =server-after-make-frame-hook= if it
is.

** Cursor

The default cursor is black, which interferes with mostly using a dark
theme.  Brighten it up a bit.

#+begin_src emacs-lisp
(set-mouse-color "white")
(add-hook 'server-after-make-frame-hook
          (lambda () (set-mouse-color "white")))
#+end_src

Enable a forever-blinking cursor.  I used to disable this mode but I
found myself searching for the cursor a couple of times lately.

#+begin_src emacs-lisp
(setq blink-cursor-delay 0.5)
(setq blink-cursor-blinks -1)
(blink-cursor-mode 1)
#+end_src

Don't show a cursor in inactive windows.

#+begin_src emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

** Fonts

An alist of my preferred font families, together with a plist of
certain attributes that need to be applied when switching to the
respective font.

#+begin_src emacs-lisp
(setq kenran/font-alist
      '((pragmata-pro
         . (:family
            "Pragmata Pro Mono"))
        (iosevka
         . (:family
            "Iosevka"))
        (dejavu
         . (:family
            "DejaVu Sans Mono"))
        (ibm-plex
         . (:family
            "IBM Plex Mono"))
        (cascadia
         . (:family
            "Cascadia Code"))
        (source-code-pro
         . (:family
            "Source Code Pro"))
        (fira-code
         . (:family
            "Fira Code"
            :org-height
            0.8))
        (jetbrains-mono
         . (:family
            "JetBrains Mono"
            :org-height
            0.8))
        (courier-prime
         . (:family
            "Courier Prime"
            :org-height
            0.95))
        (sf-mono
         . (:family
            "SFMono"
            :org-height
            0.85))
        (fantasque-sans-mono
         . (:family
            "Fantasque Sans Mono"))
        (lucida-console
         . (:family
            "Lucida Console"
            :default-height
            166
            :org-height
            0.8))
        (inconsolata
         . (:family
            "Inconsolata"
            :default-height
            170
            :org-height
            0.9))
        (borg
         . (:family
            "Borg Sans Mono"
            :org-height
            0.85))
        (termingus
         . (:family
            "Termingus"
            :default-height
            200))))
#+end_src

=kenran/current-font= contains a symbol pointing to one of the fonts
specified in =kenran/font-alist=.  Since I can now globally "set" and
change a font I like for my system, Emacs should try to adapt to this
(at startup) as well.  The function =kenran/load-font-from-env= does
just that, as the global font -- if it exists -- can be read from an
environment variable.  If a setting for this font is found in Emacs,
that is taken, unless there's a =kenran/default-font= set, which always
"wins".

If neither default font nor environment variable are set/found, I fall
back to DejaVu Sans Mono.

#+begin_src emacs-lisp
(setq kenran/default-font nil)

(defun kenran/load-font-from-env ()
  "See whether an environment variable specifying a 'system font' is
set, and translate that to one of the font symbols."
  (when-let ((f (getenv "KENRAN_DEFAULT_FONT"))
             (font (seq-find
                    (lambda (x)
                      (equal (plist-get (cdr x) :family)
                             f))
                    kenran/font-alist)))
    (car font)))

(setq kenran/current-font
      (or kenran/default-font
          (kenran/load-font-from-env)
          'dejavu))
#+end_src

For =org-mode= I (sometimes) like using a non-monospace font.  This is
it.

#+begin_src emacs-lisp
(defconst kenran/variable-pitch-font "Cantarell")
#+end_src

The function I use to switch between the various fonts I like.  It
applies the attributes of its value in =kenran/font-alist=.

#+begin_src emacs-lisp
(defun kenran/switch-font (font)
  "Apply the attributes stored for FONT in `kenran/font-alist'."
  (interactive
   (list (intern
          (completing-read
           "Font: "
           (mapcar #'car
                   (assoc-delete-all kenran/current-font
                                     (copy-alist kenran/font-alist)))))))
  (let* ((attrs (alist-get font kenran/font-alist))
         (family (plist-get attrs :family))
         (height (or (plist-get attrs :default-height) 180))
         ;; `buffer-face-mode' is enabled when calling
         ;; `variable-pitch-mode'
         (org-height (if (bound-and-true-p buffer-face-mode)
                         (or (plist-get attrs :org-height) 0.9)
                       1.0))
         (weight (or (plist-get attrs :weight) 'regular)))
    (setq kenran/current-font font)
    (setq kenran/default-font-height height)
    (set-face-attribute
     'default nil
     :font family
     :weight weight
     :height height)
    (set-face-attribute
     'fixed-pitch nil
     :font family
     :height org-height)
    (set-face-attribute
     'variable-pitch nil
     :font kenran/variable-pitch-font
     :height 1.0)
    (set-face-attribute
     'fixed-pitch-serif nil
     :font family
     :inherit 'fixed-pitch
     :height 1.0)))
#+end_src

Finally, set all the face attributes synchronously, or register a hook
that makes sure that these also work when using the Emacs daemon
together with =emacsclient=.

#+begin_src emacs-lisp
(if (daemonp)
    (add-hook 'server-after-make-frame-hook
              (defun kenran/switch-to-current-font ()
                (kenran/switch-font kenran/current-font)
                (remove-hook 'server-after-make-frame-hook
                             #'kenran/switch-to-current-font)))
  (kenran/switch-font kenran/current-font))
#+end_src

I find myself switching fonts /all the time/; I just seem to need that
kind of visual refreshment.  So let's bind it to a "leader" key.

#+begin_src emacs-lisp
(keymap-global-set "C-. t f" 'kenran/switch-font)
#+end_src

** Color theme
*** Utilities

A command to switch themes interactively.  Emacs's =load-theme= applies
all the loaded themes on top of each other; I like to only have one
theme active at all times, so I use =disable-theme= on all themes in
=custom-enabled-themes= before enabling the target theme.

#+begin_src emacs-lisp
  (defvar kenran/switch-theme-hook nil
    "Functions to be called after switching the current (default)
  font.")

  (defun kenran/switch-theme-hook ()
    "Run `kenran/switch-theme-hook'."
    (run-hook-with-args 'kenran/switch-theme-hook))

  (defun kenran/switch-theme (name)
    "Switch themes interactively.  Similar to `load-theme' but also
  disables all other enabled themes."
    (interactive
     (list (intern
	    (completing-read
	     "Theme: "
	     (mapcar #'symbol-name
		     (seq-difference (custom-available-themes)
				     custom-enabled-themes))))))
    (progn
      (mapc #'disable-theme
	    custom-enabled-themes)
      (load-theme name t)
      (kenran/switch-theme-hook)))
#+end_src

When developing a theme, like I did with =naga=, it's handy to
be able to reload it on the fly.

#+begin_src emacs-lisp
(defun kenran/reload-theme ()
  "Reload the currently active theme."
  (interactive)
  (let ((active-theme (car custom-enabled-themes)))
    (kenran/switch-theme active-theme)))
#+end_src

As with fonts, I like changing visuals regularly, as in, multiple
times a day usually.  So keybindings for this come in useful:

#+begin_src emacs-lisp
(keymap-global-set "C-. t t" 'kenran/switch-theme)
(keymap-global-set "C-. t r" 'kenran/reload-theme)
#+end_src

*** My favorite Emacs themes

Since I cannot ever decide which theme I like best, there are a few
themes, or theme collections, loaded here.

**** Custom theme: =naga=

I usually use [[https://github.com/kenranunderscore/emacs-naga-theme][my own /naga/ theme]].  It is currently in the process of
being made ready to be put on MELPA.

While that is still going on I'm using a "mutable" path, assuming I've
cloned my project repository to a fixed location.  This allows for
quick iteration.

#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path "~/projects/emacs-naga-theme")
#+end_src

Enable =naga=:

#+begin_src emacs-lisp
(setq naga-theme-use-lighter-org-block-background nil)
(setq naga-theme-modeline-style 'green-box)
(kenran/switch-theme 'wheatgrass)
#+end_src

**** Modus themes

[[https://protesilaos.com/emacs/modus-themes][This package]] by Protesilaos Stavrou is my first choice of "external"
themes.  I find myself going back to =modus-vivendi= in the evening,
even though I keep saying that I don't like that high of a contrast.

These two themes are very customizable and come with the most
comprehensive and extensive documentation (same as with basically
anything that Prot makes available).

#+begin_src emacs-lisp
(use-package modus-themes
  :defer
  :config
  (setq modus-themes-subtle-line-numbers t)
  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs nil)
  (setq modus-themes-syntax '(green-strings alt-syntax))
  (setq modus-themes-prompts '(background bold))
  (setq modus-themes-mode-line nil)
  (setq modus-themes-completions
        '((matches . (intense background))
          (selection . (intense accented))
          (popup . (intense accented))))
  (setq modus-themes-fringes nil)
  (setq modus-themes-paren-match '(bold intense))
  (setq modus-themes-region '(accented bg-only))
  ;; TODO: org agenda, mail citations
  (setq modus-themes-org-blocks nil))
#+end_src

**** Doom themes

[[https://github.com/hlissner/doom-emacs][This package]] used to be my go-to source of different themes.  It's a
megapack, started by the creator of [[https://github.com/hlissner/doom-emacs][Doom Emacs]], Henrik Lissner, but
over time it grew into an extensive collection of different themes.

It also comes with a DSL to create custom "doom themes", that is, one
specifies a relatively small number of faces / colors and the results
are propagated to most faces of all the common packages.  Without
using (something like) this, it's quite a bit of work to style lots of
packages, as one might imagine.

#+begin_src emacs-lisp
(use-package doom-themes
  :defer
  :disabled t)
#+end_src

** Render color names/codes with as their respective color

It's an ELPA package, so no need/use to put it in the nix-managed
Emacs packages.

#+begin_src emacs-lisp
(use-package rainbow-mode
  :defer)
#+end_src

** Modeline

I can live with the default mode line just fine, but over time (and
from using a neovim mode line) I have learned two things:

- I don't care about the shown modes anymore, especially since using
  =diminish= hides most of the active modes anyway.  If I really need to
  check whether some mode is enabled there's always =C-h m=.

  So let's try to fiddle with the default mode line to make it work
  the way I like.

#+begin_src emacs-lisp
(defmacro kenran/with-active-face (face)
  "Return FACE if we're in the mode line of the active window, and
the `mode-line-inactive' face otherwise."
  `(if (mode-line-window-selected-p)
   ,face
     'mode-line-inactive)) 

(defcustom kenran/major-mode-mode-line-format
  '("(" (:eval (symbol-name major-mode)) ")")
  "How to display the active major mode in the mode line."
  :risky t)

(defcustom kenran/mode-line-buffer-format
  '(compilation-in-progress
     (:eval (propertize
	     "   [Compiling...]"
	     'face
	     (kenran/with-active-face compilation-mode-line-run))))
  "How to display the name of the current buffer in the mode line."
  :risky t)

(defcustom kenran/mode-line-flymake-format
  '(flymake-mode
    (:eval (when-let ((counters (format-mode-line 'flymake-mode-line-counters)))
	     `("   " ,counters))))
  "How to display the name of the current buffer in the mode line."
  :risky t)

(setq-default
 mode-line-format
 '(""
   kenran/mode-line-flymake-format
   kenran/mode-line-buffer-format
   ("   " kenran/major-mode-mode-line-format)
   (:propertize "   %b" face mode-line-buffer-id)
   ;; Always show current line and column, without checking
   ;; `column-number-mode' and `line-number-mode'
   ("   L%l C%c")))
#+end_src

* Basic options
** Startup

FIXME: Move some of the following to =early-init.el= instead.  See
Prot's configuration for inspiration and give credit.

I wish to know how fast my Emacs is starting.  I'm not sure how to
make use of all that =use-package= has to offer in that regard yet, but
I want to at least know when I've made things worse.

#+begin_src emacs-lisp
(add-hook
 'emacs-startup-hook
 (lambda ()
   (message
    "Emacs startup took %s with %d garbage collections"
    (format
     "%.2f seconds"
     (float-time (time-subtract after-init-time before-init-time)))
    gcs-done)))
#+end_src

Disable the graphical UI things like the tool and menu bars, the
splash screen, and others.

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(setq inhibit-splash-screen t)
#+end_src

Ignore the =X= resources.  Now Emacs doesn't use the terminal
background/foreground colors.

#+begin_src emacs-lisp
(setq inhibit-x-resources t)
#+end_src

** Resize proportionally after deleting windows

#+begin_src emacs-lisp
(setq window-combination-resize t)
#+end_src

** Less annoying yes/no questions

The following setting enables answering those yes/no questions with
just =y= or =n=.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** No annoying bell sounds

If =ring-bell-function= is =nil=, Emacs will still make a sound on, for
instance, =C-g=.  Since this annoys me to no end, I disable this by
customizing the function to essentially "do nothing".

#+begin_src emacs-lisp
(setq ring-bell-function #'ignore)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode.  Note:
this doesn't work correctly yet, as =(command-modes 'some-command)=
seems to return the modes in an unexpected format.

#+begin_src emacs-lisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

To display line numbers, the aptly named =display-line-numbers= package
is used.  I used to always show line numbers when programming with
=evil=, but with vanilla Emacs bindings absolute numbers make more
sense.  It's no real use showing them by default anymore though.

#+begin_src emacs-lisp
(defun kenran/toggle-line-numbers ()
  "Toggle `display-line-numbers-mode'.  Meant to be used in a
keybinding."
  (interactive)
  (display-line-numbers-mode 'toggle))

(use-package display-line-numbers
  :defer
  :bind
  ("C-. t l" . kenran/toggle-line-numbers))
#+end_src

** Insert a newline at the end of files

#+begin_src emacs-lisp
(setq require-final-newline t)
(setq mode-require-final-newline t)
#+end_src

** Suppress warning from native compilation

When using Emacs =HEAD= (with the merged =native-comp= branch) a lot of
warnings show up during startup and when changing modes.  We could
increase the minimum severity for logs to be shown by setting
=warning-minimum-level= to =:error=, or just disable the warnings for
native compilation entirely like this:

#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** Spaces over tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

** If I have to use tabs, at least make them smaller

Looking at you, [[https://go.dev/][Go]].

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

** File name searches should be case-insensitive

#+begin_src emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+end_src

** Hide minor modes from the modeline

The =diminish= package enables us to hide minor modes from the modeline.
It's especially useful for certain modes that are globally enabled
anyway.  =Use-package= has built-in support for this available with the
=:diminish= keyword.

#+begin_src emacs-lisp
(use-package diminish)
#+end_src

** Yank (paste) at point with the mouse

The default Emacs behavior when yanking (in the Emacs sense of the
word) things from the clipboard by clicking the middle mouse button is
to insert those at the mouse cursor position.  I wish to be able to
carelessly click anywhere and have it insert at point, similar to how
it's done in most terminal emulators.

Of course there's an existing Emacs options for this:

#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

* Built-in packages with extensions
** Emacs Lisp

I like evaluating the top-level form I'm currently on by pressing =C-c
C-c=, similar to how one compiles in SLY/SLIME.

#+begin_src emacs-lisp
  (use-package emacs
    :bind
    (:map emacs-lisp-mode-map
	  ("C-c C-c" . eval-defun)))
#+end_src
 
** Display whitespace

Make whitespace symbols visible.

#+begin_src emacs-lisp
(use-package whitespace
  :defer
  :config
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode
              org-mode))
  (setq whitespace-style
        '(face newline newline-mark missing-newline-at-eof
               trailing empty tabs tab-mark))
  (setq whitespace-display-mappings
        '((newline-mark 10
                        [9166 10])
          (tab-mark 9
                    [187 9]
                    [92 9]))))
#+end_src

** Render manpages in Emacs

#+begin_src emacs-lisp
(use-package man
  :defer
  :config
  ;; As soon as it is ready open the manpage in a separate, focused
  ;; window.
  (setq Man-notify-method 'aggressive))
#+end_src

** =Isearch=

It hasn't been long since I switched from =evil= with its standard vim
search via =/=.  For many things I use =avy= now, but can't get around
the de-facto standard =isearch=.  I haven't gotten around to configuring
it a lot, but this will probably grow in the coming weeks or months.

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :config
  (setq-default isearch-lazy-count t))
#+end_src

** Diminish only

#+begin_src emacs-lisp
(use-package face-remap
  :defer
  :diminish buffer-face-mode)

(use-package autorevert
  :defer
  :diminish auto-revert-mode)
#+end_src

** Don't trim ELisp evaluation results

#+begin_src emacs-lisp
(use-package simple
  :ensure nil
  :diminish auto-fill-function
  :config
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil))
#+end_src

** ElDoc

#+begin_src emacs-lisp
(use-package eldoc
  :diminish eldoc-mode
  :config
  (advice-add 'eldoc-doc-buffer
              :after
              (defun kenran/focus-eldoc-buffer ()
                (message (buffer-name (current-buffer)))
                (pop-to-buffer eldoc--doc-buffer))))
#+end_src

** Directory editor

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :defer
  :config
  (setq dired-kill-when-opening-new-dired-buffer t)
  (setq dired-create-destination-dirs 'ask)
  :custom
  ;; Sort directories to the top
  (dired-listing-switches "-la --group-directories-first"))
#+end_src

Beautify =dired= a bit.

#+begin_src emacs-lisp
(use-package diredfl
  :defer
  :after dired
  :hook (dired-mode . diredfl-mode))
#+end_src

=Dired-narrow= is a package containing functionality to enter a filter
to narrow down the contents of a =dired= buffer interactively.  The
filter could be either some fixed string, with normal or fuzzy
matching, or a regural expression.  Bind those three functions to the
local leader key to have easier access, as =dired= already has lots of
keys bound.

#+begin_src emacs-lisp
(use-package dired-narrow
  :defer
  :after dired)
#+end_src

** Ediff

=Ediff= is a great way to diff and/or merge files or buffers.  By
default it creates a new frame containing a "control buffer" used to
navigate the diff and manipulate the output.  Unfortunately for the
longest time this behaved weirdly for me: whenever I'd tab to the
frame containing the diff, do something, then tab back, the next
navigational command from the control frame would work but drop me
back in the diff frame.  It's possible to use
=ediff-setup-windows-plain= as setup function, which makes =ediff=
single-frame, circumventing the problem.

#+begin_src emacs-lisp
(use-package ediff-wind
  :defer
  :ensure nil
  :config
  (setq ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

** Auto-closing parens, braces and other pairs

I used to use =smartparens= to automatically insert closing parentheses
and other pairs in non-lispy modes.  One thing I was missing from
Neovim, though, was the newlines and indentation that it inserted
automatically when pressing =RET= with point between braces.

The built-in =electric-pair-mode= does just that (by default).

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init
  ;; disabled for now
  (electric-pair-mode -1)
  :config
  (setq electric-pair-open-newline-between-pairs t))
#+end_src

** Undo changes to window arrangements

Sometimes I accidentally mess up my window layout.  =Winner-mode= comes
with the =winner-undo= command (bound by default to =C-<left>=) that
reverts such changes.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init (winner-mode))
#+end_src

** Correct typos while typing with =abbrev=

=Abbrev-mode= is a nice built-in minor mode that silently replaces some
things I type with other things.  It is mostly used for correcting
typos, though I haven't really "trained" my self-made list of abbrevs
-- I've just started using it.

Since it doesn't come with a global mode itself, I use =setq-default= to
enable it everywhere.

#+begin_src emacs-lisp
(use-package emacs
  :diminish abbrev-mode
  :init
  (setq-default abbrev-mode t)
  :config
  (setq save-abbrevs 'silent)
  (setq abbrev-file-name
        (concat user-emacs-directory "abbrev_defs")))
#+end_src

* Incremental narrowing with =vertico=

I started with =helm= in [[https://www.spacemacs.org/][spacemacs]], then later switched to [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
where after a while I tried out =ivy= and loved it.  Configuring Emacs
from scratch was when I decided to try out some of the newer, more
lightweight Emacs packages like [[https://github.com/raxod502/selectrum][selectrum]] and [[https://github.com/minad/vertico][vertico]].  Those
integrate very well with default Emacs functionality, so a lot of
things can utilize them "implicitly".  I've stuck with =vertico= and
I've been happy with it ever since.

#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode +1)
  :custom
  (vertico-cycle t)
  (vertico-resize t))
#+end_src

Directory navigation in =C-x d= or =C-x C-f= is something else that I
liked in Doom Emacs, as Doom had a notion of "directory name", that
is, =DEL= would delete one level in the directory hierarchy, including
the slash symbol.  The following extension to =vertico= does just that.

#+begin_src emacs-lisp
(use-package vertico-directory
  :ensure nil
  :after vertico
  :bind (:map vertico-map
              ("DEL" . vertico-directory-delete-char)
              ("C-w" . vertico-directory-delete-word)
              ("RET" . vertico-directory-enter)))
#+end_src

** Remembering command history

=savehist-mode= keeps a history of commands and inputs I've done in a
context-sensitive way, and then shows those at the top when presented
with possible results from =vertico=.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][orderless]] is a /completion style/ that fits in very well with =vertico=
(or =selectrum=, for that matter).  Parts of a search string may match
according to several matching styles.  We want to be able to specify
which matching style to use by appending a suffix so a search string.
Therefore we define style dispatchers and use them to customize
=orderless-style-dispatchers=.

Prepending an equals sign to a search term will search for literal
matches of the preceding string.

#+begin_src emacs-lisp
(defun kenran/literal-if-= (pattern _index _total)
  (when (string-prefix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 1))))
#+end_src

A prepended bang discards everything that matches the preceding
literal string.

#+begin_src emacs-lisp
(defun kenran/without-if-! (pattern _index _total)
  (when (string-prefix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

The tilde sign gives me a way to have "fuzzy" search, if needed.

#+begin_src emacs-lisp
(defun kenran/flex-if-~ (pattern _index _total)
  (when (string-prefix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 1))))
#+end_src

#+begin_src emacs-lisp
(use-package orderless
  :custom (completion-styles '(orderless))
  (orderless-style-dispatchers
   '(kenran/literal-if-=
     kenran/without-if-!
     kenran/flex-if-~)))
#+end_src

** Consult

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite
some time, though not in any extent close to full.  This defines some
basic bindings mostly taken from an example in its readme.

#+begin_src emacs-lisp
(use-package consult
  :bind (;; C-x bindings
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ;; C-h bindings (help)
         ("C-h a" . consult-apropos)
         ;; M-g bindings (goto)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ;; M-s bindings (search)
         ("M-s f" . consult-find)
         ("M-s L" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines))
  :config
  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (project-root project))))
  (setq consult-ripgrep-args
        (concat consult-ripgrep-args
                " --hidden")))
;; TODO other isearch integration?
;; TODO :init narrowing, preview delay
#+end_src

** Minibuffer actions

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet.  It seems to be amazing, though!
What I mostly use it for at the moment is its =embark-act= command in
conjunction with =embark-export=.  With this I often pull the results of
some =grep= command into a separate buffer, where I can then utilize
=wgrep= to bulk-modify the original buffers.

#+begin_src emacs-lisp
(use-package embark
  :bind (("C-," . embark-act)
         ("C-h B" . embark-bindings))
  :init
  (setq prefix-help-command #'embark-prefix-help-command))
#+end_src

Integrate =embark= with =consult=.

#+begin_src emacs-lisp
(use-package embark-consult
  :after (embark consult)
  :demand
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

* Jumping and sniping with =avy=

Try out =avy= to quickly jump to specific locations in the currently
visible area of the buffer.  This is similar to =evil-snipe= in Emacs,
or (neo)vim plugins like =vim-snipe=, =easymotion=, =leap.nvim=, =hop.nvim=,
=lightspeed.nvim=, etc.

#+begin_src emacs-lisp
(use-package avy
  :defer
  :config
  (setq avy-timeout-seconds 0.3)
  :bind
  ("C-'" . avy-goto-char-timer))
#+end_src

* Org mode

I want my headers to stand out by being really big.  I also like using
=variable-pitch-mode=, which makes it so only code, verbatim, and some
other things are written with my current monospace / fixed-width font,
and the rest uses a serif font more suitable for longer texts.  But
customizing these faces with =set-face-attribute= has the usual problems
with the initial daemon startup, and doesn't hold up when switching
fonts or themes.  That's why I've put those changes into the following
functions which I can call whenever these sorts of changes happen,
either through hooks or manual trigger.

Note that some themes, like =modus-{vivendi,operandi}=, might set the
=:inherit= attribute on a face, in which case a naive
~(set-face-attribute face nil :inherit 'fixed-pitch)~ overrides the
theme settings.  To circumvent this I've written the following
function that appends a single new value to the current =:inherit=
attribute value of a face.

#+begin_src emacs-lisp
(defun kenran/inherit-fixed-pitch (face)
  "Append `fixed-pitch' to the `:inherit' attribute of FACE."
  (let* ((current (face-attribute face :inherit))
         (new (cond
               ((eq 'unspecified current)
                'fixed-pitch)
               ((listp current)
                (if (member 'fixed-pitch current)
                    current
                  (cons 'fixed-pitch current)))
               ((not (eq 'fixed-pitch current))
                (list 'fixed-pitch current)))))
    (set-face-attribute face nil :inherit new)))

(defun kenran/org-font-setup ()
  "Set the face attributes for code, verbatim, and other markup
elements.  Also increase org header size."
  (interactive)
  (kenran/inherit-fixed-pitch 'org-block)
  (kenran/inherit-fixed-pitch 'org-block-begin-line)
  (kenran/inherit-fixed-pitch 'org-block-end-line)
  (kenran/inherit-fixed-pitch 'org-document-info-keyword)
  (kenran/inherit-fixed-pitch 'org-document-info)
  (kenran/inherit-fixed-pitch 'org-code)
  (kenran/inherit-fixed-pitch 'org-table)
  (kenran/inherit-fixed-pitch 'org-verbatim)
  (kenran/inherit-fixed-pitch 'org-checkbox)
  (kenran/inherit-fixed-pitch 'org-meta-line)
  (kenran/inherit-fixed-pitch 'org-special-keyword)
  (kenran/inherit-fixed-pitch 'org-link)
  (kenran/inherit-fixed-pitch 'org-todo)
  (kenran/inherit-fixed-pitch 'org-done)
  (kenran/inherit-fixed-pitch 'org-drawer)
  (kenran/inherit-fixed-pitch 'org-property-value)
  (kenran/inherit-fixed-pitch 'org-document-title))

(add-hook 'kenran/switch-theme-hook #'kenran/org-font-setup)
#+end_src

When writing text with =org=, =auto-fill-mode= should be enabled to
automatically break overly long lines into smaller pieces when typing.
One may still use =M-q= to re-fill paragraphs when editing text.  After
loading =org=, a custom font setup might run to adjust the headers.

#+begin_src emacs-lisp
(use-package org
  ;; Use the built-in version of org (which is quite up-to-date as I'm
  ;; always using emacs HEAD).  This circumvents problems with
  ;; 'org-compat of the older version having been loaded.
  :ensure nil
  :hook
  ((org-mode . auto-fill-mode)
   (org-mode . kenran/org-font-setup)
   ;; (org-mode . variable-pitch-mode)
   (org-trigger . save-buffer)
   ;; Inheriting fixed-pitch in kenran/org-font-setup doesn't work; the
   ;; face is not yet known there, so use a hook.
   (org-indent-mode . (lambda ()
                        (kenran/inherit-fixed-pitch 'org-indent)
                        (kenran/inherit-fixed-pitch 'org-hide))))
  :diminish org-indent-mode
  :custom
  ((org-startup-indented t)
   (org-startup-folded 'content)
   (org-directory "~/org")
   (org-log-done t)
   (org-special-ctrl-a/e t)
   ;; If this has a value greater than 0, every RET press
   ;; keeps indenting the source block further and further.
   (org-edit-src-content-indentation 0)
   (org-default-notes-file "~/org/notes.org")
   (org-agenda-files '("~/org/inbox.org"
                       "~/org/gtd.org"))
   (org-agenda-restore-windows-after-quit t)
   (org-refile-targets `(("~/org/gtd.org" :maxlevel . 3)
                         ("~/org/someday.org" :level . 1)))
   (org-capture-templates '(("t" "Todo" entry
                             (file+headline "~/org/inbox.org" "Tasks")
                             "* TODO %i%?")
                            ("n" "Note" entry
                             (file+headline "~/org/notes.org" "Notes")
                             "* %?\n%a\nNote taken on %U")))
   (org-capture-bookmark nil)
   (org-bookmark-names-plist nil)
   (org-todo-keywords '((sequence
                         "TODO(t)"
                         "WAITING(w)"
                         "|"
                         "DONE(d)"
                         "CANCELLED(c)")))
   (org-html-htmlize-output-type 'css))
  :config
  (setq-default org-hide-emphasis-markers t)
  (advice-add 'org-refile
              :after (lambda (&rest _) (org-save-all-org-buffers)))
  :bind (:map org-mode-map
              ("M-n" . org-next-visible-heading)
              ("M-p" . org-previous-visible-heading)))
#+end_src

** Keybindings

Add some globally useful =org= keybindings under =C-. o=, like for
capturing, storing links etc.

#+begin_src emacs-lisp
(keymap-global-set "C-. o a" 'org-agenda)
(keymap-global-set "C-. o c" 'org-capture)
(keymap-global-set "C-. o l" 'org-store-link)
(keymap-global-set "C-. o f" 'org-cycle-agenda-files)
#+end_src

** Beautiful bullet points

#+begin_src emacs-lisp
(use-package org-bullets
  ;; :hook (org-mode . org-bullets-mode)
  :custom (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

Also render unordered list bullet points as dots instead of =-= or =+=.

#+begin_src emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^ *\\([-]\\) "
    (0 (prog1 ()
         (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

** Show emphasis markers depending on point

In my =org= configuration I'm setting =org-hide-emphasis-markers= to =t=,
thus hiding certain markup elements around text.  Unfortunately it
seem to be currently impossible to switch this interactively, or I
just don't know how, which prevents me from simply adding a keybinding
to toggle it.

Thankfully a new package has appeared recently: [[https://github.com/awth13/org-appear][org-appear]]. It reacts
to the position of point to automatically show surrounding markup.

#+begin_src emacs-lisp
(use-package org-appear
  :hook ((org-mode . org-appear-mode))
  :config
  (setq org-appear-autolinks t)
  (setq org-appear-autosubmarkers t)
  (setq org-appear-autoentities t)
  (setq org-appear-autokeywords t)
  (setq org-appear-trigger 'always))
#+end_src

** Enable syntax highlighting when exporting to HTML

#+begin_src emacs-lisp
(use-package htmlize
  :defer
  :after ox)
#+end_src

* "Menus" with =hydra=

TODO

#+begin_src emacs-lisp
(use-package hydra
  :defer)
#+end_src

** "Error" navigation

Commands like =next-error= provide navigation for more than just errors
in the strict sense of the word.  For instance, they also work with
=occur= and =grep= type buffers (this holds for the variants of those that
I use as well: =embark= and =ripgrep=, with or without =consult=).

#+begin_src emacs-lisp
(defhydra hydra-navigate-errors (:hint nil)
  "
  Navigate the error list.\n
  _f_: first  _n_: next  _p_: previous\n
  "
  ("n" next-error)
  ("p" previous-error)
  ("f" first-error)
  ("q" nil "exit"))

(keymap-global-set "C-. n e" 'hydra-navigate-errors/body)
#+end_src

* On-the-fly syntax checking (and other things): Flymake

#+begin_src emacs-lisp
(use-package flymake
  :ensure nil
  :defer
  :config
  (setq flymake-suppress-zero-counters nil)
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-no-changes-timeout 1.0)
  (setq flymake-mode-line-lighter ""))
#+end_src

** Static analysis of shell scripts

[[https://github.com/koalaman/shellcheck][ShellCheck]] is a great little program providing feedback when writing
shell scripts.  The Emacs package [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]] integrates
ShellCheck with Flymake.  We have to trigger =flymake-shellcheck-load=
when loading shell scripts, and also enable Flymake itself, both done
via hooks to =sh-mode=.

#+begin_src emacs-lisp
(use-package flymake-shellcheck
  :after flymake
  :commands (flymake-shellcheck-load)
  :hook ((sh-mode . flymake-shellcheck-load)
         (sh-mode . flymake-mode)))
#+end_src

* Auto-completion popups via =corfu=

This is another one of Daniel Mendler's (aka =minad='s) absolutely great
Emacs packages!  I've replaced =company= with =corfu= in the past, but
back then it did not have the automatic mode (=corfu-auto=) yet.
Without automatic completion it was a little more tedious to use in
modes where =TAB= changes the level of indentation, like in
=haskell-mode= for instance.

Now that this feature exists it's time to give the package another
try.  The first impression was very positive, as =corfu= is using a
child frame for the completion popup and thus does not clash with
=whitespace-mode= the way =company= does.

#+begin_src emacs-lisp
(use-package corfu
  :init (global-corfu-mode)
  :config
  (setq corfu-cycle t)
  (setq corfu-auto nil)
  (setq corfu-auto-delay 0.0)
  (setq corfu-excluded-modes '(erc-mode))
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)))
#+end_src

** Show documentation in a separate popup

I'll have to figure out whether I like this or not.  At the moment it
seems great.

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :ensure nil
  :config
  (corfu-popupinfo-mode)
  (setq corfu-popupinfo-delay 0.5))
#+end_src

** More completion-at-point backends via =cape=

#+begin_src emacs-lisp
(defun kenran/ignore-elisp-keywords (cand)
  "Do not show Emacs Lisp keywords in completions in
'emacs-lisp-mode'."
  (or (not (keywordp cand))
      (eq (char-after (car completion-in-region--data)) ?:)))

(defun kenran/setup-elisp-capfs ()
  "Uses 'cape-super-capf' to work around the problem that dabbrev
completions don't show up in 'emacs-lisp-mode' by default."
  (setq-local completion-at-point-functions
              `(,(cape-super-capf
                  (cape-capf-predicate
                   #'elisp-completion-at-point
                   #'kenran/ignore-elisp-keywords)
                  #'cape-dabbrev)
                cape-file))
  (setq-local cape-dabbrev-min-length 4))

(defun kenran/register-default-capfs ()
  "I use 'cape-dabbrev' and 'cape-file' everywhere as they are
generally useful.  This function needs to be called in certain
mode hooks, as some modes fill the buffer-local capfs with
exclusive completion functions, so that the global ones don't get
called at all."
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))

(use-package cape
  :hook ((emacs-lisp-mode . kenran/setup-elisp-capfs)
         (haskell-mode . kenran/register-default-capfs))
  :init
  (kenran/register-default-capfs))
#+end_src

* E-Mail configuration

There are some different ways to "do e-mail in Emacs".  Over the last
two years I've tried out =notmuch=, =gnus=, and =mu4e=. Some thoughts on
each of those:

** Notmuch

The Emacs integration for =notmuch= is great; it has the most intuitive
and appealing UI from each of the options.  =Notmuch= works by
referencing incoming e-mail in a separate database only, not ever
touching or modifying it.  I really like this idea, and in practice it
also felt great due to the quick und customizable searches.  The usual
approach is to use a tag-based system of categorizing your e-mail, but
simply having lots of stored queries is a little bit more flexible.

But =notmuch= only handles this single aspect; this means that one needs
to find solutions to the following:

- Getting mail
- Initial tagging
- Sending mail
- Synchronization between machines

Due to the declarative e-mail account configuration from =home-manager=
the first part is very simple, and I could also easily switch between
different tools like =isync= or =offlineimap=.

The initial tagging can be done with a shell script using the
well-documented =notmuch= CLI, or via =afew=.

For sending mail I use =msmtp=.

Synchronization is where it broke down for me.  I have a PC at home,
and a laptop at work, and I'd like those two machines to have
identical state with respect to e-mail at all times.  I've tried using
=muchsync= on my personal server to be the "source of truth".  This
means that only the server downloads e-mail via IMAP, and the machines
are simply its /clients/; they use =muchsync= to download mail from the
server.

This sounds great on paper but it presents a problem with sent mail,
which I'd also like to sync back via IMAP to my accounts.  The client
machine sends this and puts it into a special =sent= directory, which is
then synchronized/uploaded to the server via =muchsync=.  I've had
problems with mails appearing twice, or appearing not at all on the
respective "other" machine.

If I only used one machine, =notmuch= would definitely be my preference,
but debugging this situation was very tedious and I just didn't have
the energy or time to do it.

** Gnus

I've not given =gnus= the trial it deserves.  Reading newsgroups and
mailing lists is something I can image using =gnus= for in the future.
Using it for e-mail, though, would require another synchronization
process of the =gnus= state.

I could utilize =syncthing=, which I use for synchronization of my =org=
files, to do this as well, but I've given it a couple of tries and
couldn't do it.  An experiment for another time, for sure.

** Mu for Emacs

[[https://www.djcbsoftware.nl/code/mu/][Mu]] is what I'm currently using, and =mu4e= is its Emacs frontend.  It's
not as customizable as =notmuch=, but part of its charme is that I don't
need to sync anything between my machines, at the cost of =mu= touching
my e-mail (adding custom headers I believe).  I don't mind this at
all, and I can use =isync= and =msmtp= to receive and send mail on any
host.

For writing e-mails =mu4e= uses =message-mode= like the other tools.  This
checks the =user-full-name= variable to fill in my name.

#+begin_src emacs-lisp
(setq user-full-name "Johannes Maier")
#+end_src

The actual =mu4e= configuration is one huge =use-package= block, but most
of it is due to its concept of /contexts/.  Usually there's one context
for each of my e-mail addresses, and switching between them I may set
some context-specific variables, or even change the =mu4e= UI
accordingly.

#+begin_src emacs-lisp
(use-package mu4e
  :load-path "~/.nix-profile/share/emacs/site-lisp/mu4e"
  :defer
  :commands (mu4e)
  :config
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-completing-read-function #'completing-read)
  ;; I don't sync drafts to either of the accounts
  (setq mu4e-confirm-quit nil)
  (setq mu4e-change-filenames-when-moving t)
  (setq mu4e-drafts-folder "/drafts")
  (setq mu4e-attachment-dir "~/Downloads/")
  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "mailbox"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/mailbox"
                                             (mu4e-message-field msg :maildir)
                                             t)))
            :vars '((user-mail-address . "johannes.maier@mailbox.org")
                    (mu4e-compose-signature . nil)
                    (mu4e-sent-folder . "/mailbox/Sent")
                    (mu4e-trash-folder . "/mailbox/Trash")
                    (mu4e-refile-folder . (lambda (msg)
                                            (let* ((date (mu4e-message-field-at-point :date))
                                                   (year (decoded-time-year (decode-time date))))
                                              (concat "/mailbox/Archive/"
                                                      (number-to-string year)))))))
          ,(make-mu4e-context
            :name "ag"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/ag"
                                             (mu4e-message-field msg :maildir)
                                             t)))
            :vars `((user-mail-address . "johannes.maier@active-group.de")
                    ;; FIXME: Signature in a file?
                    (mu4e-compose-signature . ,(concat
                                                "Johannes Maier\n"
                                                "johannes.maier@active-group.de\n\n"
                                                "+49 (7071) 70896-67\n\n"
                                                "Active Group GmbH\n"
                                                "Hechinger Str. 12/1\n"
                                                "72072 Tübingen\n"
                                                "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                                                "Geschäftsführer: Dr. Michael Sperber"))
                    (mu4e-sent-folder . "/ag/Sent")
                    (mu4e-refile-folder . (lambda (msg)
                                            (let* ((date (mu4e-message-field-at-point :date))
                                                   (year (decoded-time-year (decode-time date))))
                                              (concat "/ag/Archives/"
                                                      (number-to-string year)))))
                    (mu4e-trash-folder . "/ag/Trash")))))
  (setq mu4e-bookmarks '((:name "Active-Group inbox" :query "maildir:/ag/Inbox" :key ?a)
                         (:name "Mailbox inbox" :query "maildir:/mailbox/Inbox" :key ?m)
                         (:name "Unread messages" :query "flag:unread AND NOT flag:trashed" :key ?u)
                         (:name "Sent" :query "maildir:/ag/Sent OR maildir:/mailbox/Sent" :key ?s)))
  (setf (alist-get 'trash mu4e-marks)
        (list :char '("d" . "▼")
              :prompt "dtrash"
              :dyn-target (lambda (target msg)
                            (mu4e-get-trash-folder msg))
              :action (lambda (docid msg target)
                        (mu4e~proc-move docid (mu4e~mark-check-target target)) "-N")))
  (setq mu4e-headers-fields '((:human-date . 12)
                              (:flags . 6)
                              (:maildir . 15)
                              (:mailing-list . 10)
                              (:from . 22)
                              (:subject)))
  (setq mu4e-context-policy 'pick-first)
  (setq mu4e-compose-policy 'ask)
  ;; Getting mail via mbsync
  (setq mu4e-get-mail-command "mbsync -a")
  ;; Composing emails
  (setq message-send-mail-function #'message-send-mail-with-sendmail)
  (setq send-mail-function #'message-send-mail-with-sendmail)
  (setq message-sendmail-envelope-from 'header)
  (setq mail-envelope-from 'header)
  (setq mail-specify-envelope-from 'header)
  (setq message-kill-buffer-on-exit t)
  ;; Visuals
  (setq mu4e-headers-thread-single-orphan-prefix '("─> " . "─▶"))
  (setq mu4e-headers-thread-orphan-prefix '("┬> " . "┬▶ "))
  (setq mu4e-headers-thread-child-prefix '("├> " . "├▶"))
  (setq mu4e-headers-thread-connection-prefix '("│ " . "│ "))
  (setq mu4e-headers-thread-duplicate-prefix '("= " . "≡ "))
  (setq mu4e-headers-thread-first-child-prefix '("├> " . "├▶"))
  (setq mu4e-headers-thread-last-child-prefix '("└> " . "╰▶")))
#+end_src

* Window management: taming popups

One thing I'm missing from Doom Emacs is the way it handled all sorts
of popup-like buffers.  When using vanilla Emacs with packages, there
are some different behaviors w.r.t. popups:

- Window splits, new buffer is focused
- Window splits, but new buffer is not focused
- Popup opens over current buffer
- The popup may be closed by pressing =q=
- The popup needs to be closed by killing the window
- The popup needs to be closed by killing the buffer
- ... and probably others

Doom makes it so there is a unified way of dealing with these, and
they all open and behave the same way.  In theory much of this should
boil down to good customization of =display-buffer-alist=, but that's
pretty arcane.  =Shackle.el= seems to make this easier.  There's also
=popper.el=, and I'm not quite sure yet where the differences are.  My
guess is that they probably go well together.

#+begin_src emacs-lisp
(use-package shackle
  :init (shackle-mode)
  :config
  (setq shackle-inhibit-window-quit-on-same-windows t)
  (setq shackle-default-alignment 'below)
  (setq shackle-default-size 0.4)
  (setq shackle-rules '((helpful-mode :align t :select t)
                        (help-mode :align t :select t)
                        (compilation-mode :align t :select t)
                        (apropos-mode :align t :select t)
                        ("^\\*eldoc" :regexp t :align below :select t)
                        ("^\\*Occur" :regexp t :align t :select t)
                        ("^\\*sly-description" :regexp t :align t :select t)
                        ("^\\*lispy" :regexp t :align t :noselect t)))
  (setq shackle-default-rule nil))
#+end_src

#+begin_src emacs-lisp
(use-package popper
  :disabled t
  :defer
  :init (popper-mode))
#+end_src

*** TODO What kinds of popups to try and tame? [0/7]
- [ ] REPLs
- [ ] =helpful=
- [ ] =apropos=
- [ ] Compilation results
- [ ] Shell command results
- [ ] LSP / =eglot=

* IRC with ERC

I've been using [[https://weechat.org][weechat]] for IRC communication in the past.  And while
my usage of IRC has decreased quite a bit due to a lot of things
moving over to Discord, there are some channels and communities that
have their sole online presence in IRC.  As with anything, it's worth
trying whether just using Emacs might be preferable.  So far my
experience with ERC has been quite smooth and I don't regret it yet,
so I've fully switched over.

#+begin_src emacs-lisp
(use-package erc
  :defer
  :config
  (setq erc-autojoin-channels-alist
        '((libera "#emacs"
                  "#nyxt"
                  "#systemcrafters"
                  "#org-mode"
                  "#haskell"
                  "#nim"
                  "#zig"
                  "#crawl"
                  "#guix"
                  "#commonlisp"
                  "#lisp"
                  "#herrhotzenplotz")))
  (setq erc-track-exclude
        '("#org-mode" "#crawl" "#nim" "#zig"))
  (setq erc-track-exclude-types '("333" "353"))
  (setq erc-hide-list '("NICK" "MODE" "AWAY" "JOIN" "PART" "QUIT" "AWAY"))
  (setq erc-track-exclude-server-buffer t)
  (setq erc-kill-server-buffer-on-quit t)
  (setq erc-kill-buffer-on-part t)
  (setq erc-fill-column 130)
  (setq erc-fill-static-center 20)
  (setq erc-fill-function #'erc-fill-static))

(use-package erc-hl-nicks
  :after erc
  (add-to-list 'erc-modules 'hl-nicks))

(use-package erc-image
  :after erc
  :config
  (setq erc-image-inline-rescale 200)
  (add-to-list 'erc-modules 'image))

(defun start-irc ()
  "Connect to some IRC servers."
  (interactive)
  (erc-tls :id 'libera
           :server "irc.libera.chat"
           :port 6697
           :nick "kenran"
           :full-name "kenran"
           :client-certificate (let ((cert-dir (getenv "KENRAN_IRC_CERTS")))
                                 `(,(concat cert-dir "/kenran.key")
                                   ,(concat cert-dir "/kenran.crt")))))
#+end_src

* Package-specific configuration
** Mode-specific code snippets

#+begin_src emacs-lisp
(use-package tempel
  :commands (tempel-done)
  :config
  (setq tempel-path
        (expand-file-name "templates.eld"
                          user-emacs-directory))
  :bind
  (("M-*" . tempel-expand)
   (:map tempel-map
         ("C-j" . tempel-next)
         ("TAB" . tempel-next)
         ("C-k" . tempel-previous))))
#+end_src

** Unified interface for creating code formatters

Another generally useful package by Steve Purcell is [[https://github.com/purcell/emacs-reformatter][reformatter.el]].
It enables easy definition of commands to format buffers, as well as
minor modes that, when active, automatically apply these commands on
save.

#+begin_src emacs-lisp
(use-package reformatter
  :defer)
#+end_src

** Terminal emulator in Emacs

=vterm= is a terminal emulator for Emacs, more feature-rich than the
built-in =term=.  This is very useful for quickly spawning a terminal,
for instance in the top-level directory of a project.

#+begin_src emacs-lisp
(use-package vterm
  :commands (vterm)
  :defer)
#+end_src

** C/C++

#+begin_src emacs-lisp
(setq c-default-style '((awk-mode . "awk")
                        (other . "stroustrup")))
#+end_src

** Zig

[[https://ziglang.org/][Zig]] is a relatively new systems programming language that I could see
me learning more in-depth in the near future.  It's a smaller language
than, say, Rust, and less safe; but I like its explicit nature and
great defaults.  The community is very welcoming so far, as well!

#+begin_src emacs-lisp
(use-package zig-mode
  :defer)
#+end_src

** OCaml

[[https://github.com/ocaml/tuareg][tuareg]] is the standard mode for OCaml editing, providing syntax
highlighting, REPL support, etc., similar to what =haskell-mode= does
for Haskell.

#+begin_src emacs-lisp
(use-package tuareg
  :defer
  :hook (tuareg-mode . (lambda () (setq mode-name "🐫")))
  :config
  (setq tuareg-indent-align-with-first-arg nil)
  (setq tuareg-match-patterns-aligned t))
#+end_src

To get some IDE features for OCaml in Emacs I use [[https://github.com/ocaml/merlin][merlin]].

#+begin_src emacs-lisp
(use-package merlin
  :hook ((tuareg-mode . merlin-mode)))
#+end_src

[[https://github.com/Khady/merlin-eldoc][merlin-eldoc]] integrates =merlin= with =eldoc-mode=, automatically
documenting things at point.

#+begin_src emacs-lisp
(use-package merlin-eldoc
  :after merlin
  :hook (tuareg-mode . merlin-eldoc-setup)
  :config
  (setq merlin-eldoc-max-lines 8)
  (setq merlin-eldoc-type-verbosity 'min)
  (setq merlin-eldoc-function-arguments t)
  (setq merlin-eldoc-doc t))
#+end_src

** Fish

I'm often using the [[https://fishshell.com/][fish]] shell.  It comes with its own,
POSIX-incompatible language, but I mainly use it for =fish='s
configuration (though most of that is done via =nix=, anyway).  It's
nice to have syntax highlighting, though.

#+begin_src emacs-lisp
(use-package fish-mode
  :defer)
#+end_src

** EditorConfig

I want to be able to simply clone and work in projects and adapt to
their respective styles of indentation, newlines at the end of files,
and the like.  [[https://editorconfig.org/][EditorConfig]] comes with a specified file format to
describe these things, possible even on per-file basis; all one needs
to use these is support of one's editor.  Many editors have
out-of-the-box EditorConfig support nowadays.  For Emacs, there's the
official [[https://github.com/editorconfig/editorconfig-emacs][editorconfig-emacs]] package.

#+begin_src emacs-lisp
(use-package editorconfig
  :config
  (setq editorconfig-mode-lighter " EC")
  (editorconfig-mode 1))
#+end_src

** Ini files

I'm not 100 percent happy with this package, as paragraphs seem to be
acting strange.  Deleting a paragraph via =dap= for instance often
deletes the following one, too, plus sometimes the previous section
header.

#+begin_src emacs-lisp
(use-package ini-mode
  :defer)
#+end_src

** JavaScript

#+begin_src emacs-lisp
(use-package js
  :defer
  :config
  (setq js-indent-level 2))
#+end_src

** Purescript

#+begin_src emacs-lisp
(use-package psc-ide
  :hook (purescript-mode . psc-ide-mode)
  :config
  (setq psc-ide-rebuild-on-save t))

(use-package purescript-mode
  :hook (purescript-mode . turn-on-purescript-indentation))
#+end_src

** Nix

#+begin_src emacs-lisp
(reformatter-define kenran/nix-format
  :program "nixfmt"
  :args '()
  :lighter " k/nixfmt")

(use-package nix-mode
  :mode "\\.nix\\'"
  :hook (nix-mode . kenran/nix-format-on-save-mode))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc")
  :hook ((markdown-mode gfm-mode) . auto-fill-mode))
#+end_src

** Haskell

Provide an interactive mode for writing Haskell.  I can work with a
REPL, get feedback and compilation errors shown in the code, and so
on.  I've also added a bunch of utility functions and want to load
everything lazily, so I've created a [[file:my-packages/my-haskell.org][custom local Emacs package]] that
contains everything.

#+begin_src emacs-lisp
(use-package my-haskell
  :demand
  :load-path kenran/custom-package-dir)
#+end_src

** Dhall

#+begin_src emacs-lisp
(use-package dhall-mode
  :mode "\\.dhall\\'"
  :config
  (setq dhall-type-check-inactivity-timeout 2))
#+end_src

** Docker

I still have to semi-regularly write Dockerfiles.  This package comes
with syntax highlighting for those.

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :defer)
#+end_src

I'm trying out this package, as it provides a =magit=-like UI to control
images, containers, volumes, networks, etc. from inside Emacs.

#+begin_src emacs-lisp
(use-package docker
  :defer)
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :defer)
#+end_src

** Clojure

The key to using Clojure effectively with Emacs seems to be [[https://github.com/clojure-emacs/cider][CIDER]].

#+begin_src emacs-lisp
(use-package clojure-mode
  :defer)

(use-package cider
  :after clojure-mode
  :defer)
#+end_src

** CSV

#+begin_src emacs-lisp
(use-package csv-mode
  :defer)
#+end_src

** PlantUML

#+begin_src emacs-lisp
(use-package plantuml-mode
  :defer
  :init
  (add-to-list 'auto-mode-alist
               '("\\.\\(plantuml\\|puml\\)\\'" . plantuml-mode))
  :config
  (setq plantuml-default-exec-mode 'executable))
#+end_src

** Common Lisp

[[https://github.com/joaotavora/sly][SLY]] seems to be a bit more actively developed and modern than [[https://slime.common-lisp.dev/][SLIME]].

#+begin_src emacs-lisp
(use-package sly
  :defer
  :config
  (setq inferior-lisp-program "sbcl"))
#+end_src

=sly-asdf= gives integration with Common Lisp's package manager, [[https://asdf.common-lisp.dev/][ASDF]].

#+begin_src emacs-lisp
(use-package sly-asdf
  :defer)
#+end_src

** Racket

#+begin_src emacs-lisp
(use-package racket-mode
  :defer
  :hook ((racket-mode . racket-xp-mode)
         (racket-mode . racket-unicode-input-method-enable)
         (racket-repl-mode . racket-unicode-input-method-enable)))
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :defer
  :config
  (setq rust-format-on-save t))
#+end_src

** Java

I don't use Java, but Bob Nystrom's excellent and free book [[https://craftinginterpreters.com/][Crafting
Interpreters]] uses it for the first part.  It's actually quite OK to
write Java with =meghanada,= but it takes a long time to download all
its dependencies.

It's currently commented out as it's the last remaining package
pulling in =yasnippet=.

#+begin_src emacs-lisp
;; (use-package meghanada
;;   :defer
;;   :init
;;   (add-hook 'java-mode-hook
;;             (lambda ()
;;               (meghanada-mode t)
;;               (flycheck-mode +1)
;;               (setq c-basic-offset 2)
;;               (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))))
#+end_src

** Python

#+begin_src emacs-lisp
(use-package anaconda-mode
  :defer
  :hook (python-mode . anaconda-mode))

(use-package pyimport
  :defer)
#+end_src

** Nim

#+begin_src emacs-lisp
(use-package nim-mode
  :defer)
#+end_src

** F#

#+begin_src emacs-lisp
(use-package fsharp-mode
  :defer
  :config
  (setq fsharp-indent-offset 2)
  (setq fsharp-continuation-offset 2)
  (setq inferior-fsharp-program "dotnet fsi --readline-"))
#+end_src

** Go

I neither like nor normally use Go, but it's nice to have some syntax
highlighting at least for when I /do/ have to read it.

#+begin_src emacs-lisp
(use-package go-mode
  :defer)
#+end_src

** LSP integration

I've used =lsp-mode= in the past and while it's nice, I feel like it's
more in line with the rest of this configuration to try out something
more lightweight and closer to vanilla Emacs.  This is where [[https://github.com/joaotavora/eglot][eglot]]
comes into play.

#+begin_src emacs-lisp
(use-package eglot
  :ensure nil
  :defer)
#+end_src

** Better Emacs help and documentation

This gives us better and more readable help pages.  We also replace
some built-in =C-h= keybings with =helpful-*= functions.

#+begin_src emacs-lisp
(use-package helpful
  :bind (("C-h f" . helpful-callable)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)))
#+end_src

** Project management

I've used [[https://github.com/bbatsov/projectile][projectile]] for a while.  It's great, but I found myself not
using most of its features.  Now that the built-in =project.el= has been
coming along great, I'm giving it a try.  I'm very happy with it so
far.

The following are utility functions that mostly rely on being in the
top-level directory of a known project.  =project.el= is making this
possible in a straightforward way.

#+begin_src emacs-lisp
(defun kenran/add-nix-envrc-file ()
  "If it doesn't already exist create a .envrc file containing 'use
nix' in the current directory."
  (interactive)
  (let ((envrc (expand-file-name ".envrc")))
    (if (file-exists-p envrc)
        (message "Envrc file already exists")
      (write-region "use nix" nil envrc))))

(defun kenran/project-vterm ()
  "Open a `vterm' session in the project root of the current
project.  Prompt if no project can be found."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (vterm)))

(defun kenran/project-edit-dir-local-variable (mode variable value)
  "Edit directory-local variables in the root directory of the
current project."
  (interactive
   ;; Taken from `add-dir-local-variable', as I don't know of a better
   ;; way to simply wrap that command.
   (let (variable)
     (require 'files-x)
     (list
      (read-file-local-variable-mode)
      (setq variable (read-file-local-variable "Add or edit directory-local variable"))
      (read-file-local-variable-value variable))))
  (let ((default-directory (project-root (project-current t))))
    (modify-dir-local-variable mode variable value 'add-or-replace)))
#+end_src

Another thing I sometimes need is quickly navigate into my project
directory, so why not write something to open =dired= there and then add
this function to =project-prefix-map=?

#+begin_src emacs-lisp
(defun kenran/navigate-to-projects ()
  "Open a `dired' buffer in my personal project directory."
  (interactive)
  (dired "~/projects"))
#+end_src

One tricky thing was making it possible to bind the keymap
=project-prefix-map= to a key.  One needs to make it callable via =fset=.

#+begin_src emacs-lisp
(use-package project
  :config
  (fset 'project-prefix-map project-prefix-map)
  (setq project-switch-commands
        '((project-find-file "find file")
          (consult-ripgrep "search/grep" ?s)
          ((lambda ()
             (interactive)
             (magit-status (project-root (project-current t))))
           "git status"
           ?g)
          (project-dired "dired")
          (kenran/project-vterm "vterm" ?t)
          (project-switch-to-buffer "find buffer" ?b)
          (project-vc-dir "vc")))
  :bind (:map project-prefix-map
              ("t" . kenran/project-vterm)
              ("d" . project-dired)
              ("s" . consult-ripgrep)
              ("D" . kenran/project-edit-dir-local-variable)
              ("n" . kenran/navigate-to-projects)))
#+end_src

** Magit

Not much to say here: =magit= is awesome and in my top 3 reasons why I
can't ever switch to anything that doesn't have this.  I've tried
=vim-fugitive= and =neogit= for (neo)vim, and while they're great, I still
missed =magit=.  I'm in the process of getting used to the non-=evil=
keybindings (again); once that is finished, I might add some custom
bindings here.  =magit-status-here= is surely the one I use the most,
but I have a hunch it's not used nearly often enough to warrant a
custom key chord; I can just use =M-x=, where I don't have to enter
much due to =savehist-mode=.

#+begin_src emacs-lisp
(use-package magit
  :defer
  :config
  ;; No autosave for open buffers, as that might trigger hooks and
  ;; such.
  (setq magit-save-repository-buffers nil)
  (setq magit-diff-refine-hunk t)
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-bury-buffer-function #'magit-restore-window-configuration)
  ;; I frequently pull with the autostash option, so add that to the
  ;; transient command list.
  (transient-append-suffix 'magit-pull "-r"
    '("-a" "Autostash" "--autostash")))
#+end_src

I used to have way more =magit= keybindings when I used =evil=, but as
mentioned above =M-x= seems like the way to go.  I was missing
=magit-status-here= a lot, though, so add it in an accessible spot.

#+begin_src emacs-lisp
(keymap-global-set "C-. g" 'magit-status-here)
#+end_src

*** Interactively browse =git= history

#+begin_src emacs-lisp
(use-package git-timemachine
  :defer)
#+end_src

*** Modes for other kinds of =git=-related files

It's useful to have a little bit of syntax highlighting in files like
=.gitignore= or =.gitattributes=.  The =git-modes= package provides just
that, and autoloads the specific modes for the respective file types.
Like its readme proposes it's also possible to reuse the
=gitignore-mode= for other things, in this case =.dockerignore= files.

#+begin_src emacs-lisp
(use-package git-modes
  :defer
  :init
  (add-to-list 'auto-mode-alist
               (cons "/.dockerignore\\'" 'gitignore-mode)))
#+end_src

** LISP editing with Lispy and Lispyville

#+begin_src emacs-lisp
(use-package lispy
  :hook
  ((emacs-lisp-mode
    lisp-mode
    clojure-mode
    clojurec-mode
    clojurescript-mode
    common-lisp-mode
    racket-mode
    racket-repl-mode
    sly-mrepl-mode)
   . lispy-mode))
#+end_src

** Highlight "todo", "fixme" and other keywords everywhere.

#+begin_src emacs-lisp
(use-package hl-todo
  :init
  (add-hook 'after-init-hook 'global-hl-todo-mode))
#+end_src

** Display commands bound to keys in the minibuffer

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src emacs-lisp
(use-package which-key
  :defer
  :custom
  (which-key-idle-delay 0.3)
  :diminish which-key-mode
  :init
  ;; See https://github.com/justbur/emacs-which-key/issues/306
  (if (daemonp)
      (add-hook 'server-after-make-frame-hook 'which-key-mode)
    (add-hook 'after-init-hook 'which-key-mode)))
#+end_src

** Annotate minibuffer completions

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in =C-h v=, file sizes
and permissions in =C-x C-f=, and much more.

#+begin_src emacs-lisp
(use-package marginalia
  :init
  (marginalia-mode)
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit 'keep-selected))))
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle)))
#+end_src

** Make Emacs =direnv=-sensitive

Steve Purcell's [[https://github.com/purcell/envrc][envrc]] package is an alternative to [[https://github.com/wbolster/emacs-direnv][emacs-direnv]].  The
latter has a long-standing issue where it sometimes loads too late,
that is, /after/ packages like =lsp-mode= would need it.  =envrc= has worked
flawlessly so far.  Note: this should probably be one of the last
modes to load, as the hook function is then placed before the other
modes to ensure =direnv= integration is working as expected.

#+begin_src emacs-lisp
(use-package envrc
  :defer
  :init (envrc-global-mode))
#+end_src

** Fast grepping via =ripgrep=

I use [[https://github.com/BurntSushi/ripgrep][ripgrep]] on the command line a lot.  This packages makes it
comfortably usable from within Emacs.

#+begin_src emacs-lisp
(use-package ripgrep
  :defer)
#+end_src

** Interactive window switching

#+begin_src emacs-lisp
(use-package ace-window
  :defer
  :init
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r))
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5))
#+end_src

** Global font scaling

#+begin_src emacs-lisp
(use-package default-text-scale
  :defer
  :after hydra
  :config
  (setq default-text-scale-amount 10))

(defhydra hydra-global-zoom (:hint nil :timeout 3)
  "
  Change the font size globally.\n
  _g_: increase
  _l_: decrease\n
  "
  ("g" default-text-scale-increase)
  ("l" default-text-scale-decrease)
  ("r" (lambda ()
         (interactive)
         (setq default-text-scale--complement 0)
         (face-spec-set 'default `((t (:height ,kenran/default-font-height))))
         (set-face-attribute 'default nil
                             :height kenran/default-font-height))
   "reset" :color blue)
  ("s" (lambda (height)
         (interactive "nFont size: ")
         (set-face-attribute 'default nil
                             :height height))
   "set size" :color blue)
  ("q" nil "exit"))

(keymap-global-set "C-. z" 'hydra-global-zoom/body)
#+end_src

** Edit =grep= results over multiple buffers

#+begin_src emacs-lisp
(use-package wgrep
  :defer
  :custom
  ((wgrep-auto-save-buffer t)
   (wgrep-change-readonly-file nil)
   (wgrep-too-many-file-length 15)))
#+end_src

** Improve garbage collector behavior

#+begin_src emacs-lisp
(use-package gcmh
  :diminish gcmh-mode
  :init
  (gcmh-mode 1))
#+end_src
