#+TITLE: My GNU Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: showall

* Package management

I'm specifying the Emacs I'm using via [[https://github.com/nixos/nixpkgs][nixpkgs]] / my [[https://github.com/nix-community/home-manager][home-manager]]
setup, but for package management I'm currently using the now-built-in
=use-package= macro.  Having the packages come from =nixpkgs= (marked as
=external= in =list-packages=) is nice, but requires a =nixos-rebuild= and
restarting Emacs after making some changes.

FIXME: note on =straight=

Set up MELPA.

#+begin_src emacs-lisp
(require 'package)
(package-initialize)
(setq package-archives
      '(("gnu" . "https://elpa.gnu.org/packages/")
        ("melpa" . "https://melpa.org/packages/")))
#+end_src

And set up =use-package= itself in a way such that the =:ensure= keyword
is by default set to =t=, that is, =use-packages= ensures that the package
will be installed if it isn't already.

#+begin_src emacs-lisp
(require 'use-package)
(setq use-package-always-ensure t)
#+end_src

* Profiling the startup time

For no real reason whatsoever I like it when my Emacs starts up
quickly.  The =benchmark-init= package nicely profiles where the time
during startup went, and if a culprit is found, the "fix" is usually
to add =:defer= to a =use-package= call.

Note that this block is not tangled; I only run this when I encounter
weird behavior.

#+begin_src emacs-lisp :tangle no
(use-package benchmark-init
  :demand
  :config (benchmark-init/activate)
  :hook (after-init . benchmark-init/deactivate))
#+end_src

* Keybinding management

I used to use the [[https://github.com/noctuid/general][general]] package to define keybindings in a more
straightforward and declarative way.  But since this is especially
useful in =evil-mode=, where I have to bind keys according to the
current mode, I decided to drop this as well while trying to live
without =evil=.

The concept of a /prefix key/ (or /leader key/) is still quite useful in
my opinion: decide on a key that should hold all custom or built-in
functionality I often need, but that's not specific to a major mode
(where =C-c <letter>= would be the appropriate place to bind things to).

I had already decided to use =C-.= as my leader, but am now changing
that to use the even more accessible =C-t=.  =C-t= is used by my window
manager StumpWM by default, but having the more comfortable key in
Emacs is the better tradeoff I think.

#+begin_src emacs-lisp
(define-prefix-command 'my/prefix-map)
(keymap-global-set "C-t" 'my/prefix-map)
#+end_src

#+begin_src emacs-lisp
(use-package emacs
  :bind
  ("C-h F" . describe-face)
  ("C-h M" . describe-keymap)
  ("C-h V" . set-variable)
  ("C-x C-o" . other-window)
  ("C-t b k" . kill-current-buffer)
  ("C-t b i" . ibuffer)
  ("C-t b p" . previous-buffer)
  ("C-t b n" . next-buffer)
  ("C-t b s" . scratch-buffer)
  ("C-t c" . comment-or-uncomment-region))
#+end_src

* The region

I sometimes like to narrow to the region.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+end_src

* Loading additional ELisp configuration files

I do not want customizations done via =customize= to end up in this
file.  Use a separate file instead and load that one on startup.

#+begin_src emacs-lisp
(let ((my-custom-file (locate-user-emacs-file "custom.el")))
  (setq custom-file my-custom-file)
  (load custom-file 'no-error))
#+end_src

A quick way to jump to this file, and an accompanying keybinding, as I
do this /very often/.

#+begin_src emacs-lisp
(defun my/open-init-file ()
  "Open my config.org file."
  (interactive)
  (find-file (file-truename (locate-user-emacs-file "config.org"))))

(keymap-global-set "C-t e" 'my/open-init-file)
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.

One thing to pay attention to is that nearly all those operations on
"visuals" work slightly differently when starting Emacs as
=emacsclient=, for instance via

#+begin_src shell :tangle no
emacsclient -a ''
#+end_src

Setting some things at this point often results in the changes not
being applied correctly.  It's due to them happening in a technical,
invisible Emacs frame.  So you'll often see =(daemonp)= being called,
checking whether this instance of Emacs is using the daemon, then
adding some initializer function to =server-after-make-frame-hook= if it
is.

** Cursor

The default cursor is black, which interferes with mostly using a dark
theme.  Brighten it up a bit.

#+begin_src emacs-lisp
(set-mouse-color "white")
(add-hook 'server-after-make-frame-hook
          (lambda () (set-mouse-color "white")))
#+end_src

Enable a forever-blinking cursor.  I used to disable this mode but I
found myself searching for the cursor a couple of times lately.

#+begin_src emacs-lisp
(setq blink-cursor-delay 0.5)
(setq blink-cursor-blinks -1)
(blink-cursor-mode 1)
#+end_src

Don't show a cursor in inactive windows.

#+begin_src emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

** Fonts

An alist of my preferred font families, together with a plist of
certain attributes that need to be applied when switching to the
respective font.

#+begin_src emacs-lisp
(setq my/font-alist
      '((pragmata-pro
         . (:family
            "Pragmata Pro Mono"))
        (iosevka
         . (:family
            "Iosevka"))
        (dejavu
         . (:family
            "DejaVu Sans Mono"))
        (ibm-plex
         . (:family
            "IBM Plex Mono"))
        (cascadia
         . (:family
            "Cascadia Code"))
        (source-code-pro
         . (:family
            "Source Code Pro"))
        (fira-code
         . (:family
            "Fira Code"
            :org-height
            0.8))
        (jetbrains-mono
         . (:family
            "JetBrains Mono"
            :org-height
            0.8))
        (courier-prime
         . (:family
            "Courier Prime"
            :org-height
            0.95))
        (sf-mono
         . (:family
            "SFMono"
            :org-height
            0.85))
        (fantasque-sans-mono
         . (:family
            "Fantasque Sans Mono"))
        (lucida-console
         . (:family
            "Lucida Console"
            :default-height
            166
            :org-height
            0.8))
        (inconsolata
         . (:family
            "Inconsolata"
            :default-height
            170
            :org-height
            0.9))
        (borg
         . (:family
            "Borg Sans Mono"
            :org-height
            0.85))
        (termingus
         . (:family
            "Termingus"
            :default-height
            200))
        (unifont
         . (:family
            "Unifont"
            :default-height
            200))))
#+end_src

=my/current-font= contains a symbol pointing to one of the fonts
specified in =my/font-alist=.  Since I can now globally "set" and change
a font I like for my system, Emacs should try to adapt to this (at
startup) as well.  The function =my/load-font-from-env= does just that,
as the global font -- if it exists -- can be read from an environment
variable.  If a setting for this font is found in Emacs, that is
taken, unless there's a =my/default-font= set, which always "wins".

If neither default font nor environment variable are set/found, I fall
back to DejaVu Sans Mono.

#+begin_src emacs-lisp
(setq my/default-font nil)

(defun my/load-font-from-env ()
  "See whether an environment variable specifying a 'system font' is
set, and translate that to one of the font symbols."
  (when-let ((f (getenv "KENRAN_DEFAULT_FONT"))
             (font (seq-find
                    (lambda (x)
                      (equal (plist-get (cdr x) :family)
                             f))
                    my/font-alist)))
    (car font)))

(setq my/current-font
      (or my/default-font
          (my/load-font-from-env)
          'dejavu))
#+end_src

For =org-mode= I (sometimes) like using a non-monospace font.  This is
it.

#+begin_src emacs-lisp
(defconst my/variable-pitch-font "Cantarell")
#+end_src

The function I use to switch between the various fonts I like.  It
applies the attributes of its value in =my/font-alist=.

#+begin_src emacs-lisp
(defun my/switch-font (font)
  "Apply the attributes stored for FONT in `my/font-alist'."
  (interactive
   (list (intern
          (completing-read
           "Font: "
           (mapcar #'car
                   (assoc-delete-all my/current-font
                                     (copy-alist my/font-alist)))))))
  (let* ((attrs (alist-get font my/font-alist))
         (family (plist-get attrs :family))
         (height (or (plist-get attrs :default-height) 180))
         ;; `buffer-face-mode' is enabled when calling
         ;; `variable-pitch-mode'
         (org-height (if (bound-and-true-p buffer-face-mode)
                         (or (plist-get attrs :org-height) 0.9)
                       1.0))
         (weight (or (plist-get attrs :weight) 'regular)))
    (setq my/current-font font)
    (setq my/default-font-height height)
    (set-face-attribute
     'default nil
     :font family
     :weight weight
     :height height)
    (set-face-attribute
     'fixed-pitch nil
     :font family
     :height org-height)
    (set-face-attribute
     'variable-pitch nil
     :font my/variable-pitch-font
     :height 1.0)
    (set-face-attribute
     'fixed-pitch-serif nil
     :font family
     :inherit 'fixed-pitch
     :height 1.0)))
#+end_src

Finally, set all the face attributes synchronously, or register a hook
that makes sure that these also work when using the Emacs daemon
together with =emacsclient=.

#+begin_src emacs-lisp
(if (daemonp)
    (add-hook 'server-after-make-frame-hook
              (defun my/switch-to-current-font ()
                (my/switch-font my/current-font)
                (remove-hook 'server-after-make-frame-hook
                             #'my/switch-to-current-font)))
  (my/switch-font my/current-font))
#+end_src

I find myself switching fonts /all the time/; I just seem to need that
kind of visual refreshment.  So let's bind it to a "leader" key.

#+begin_src emacs-lisp
(keymap-global-set "C-t t f" 'my/switch-font)
#+end_src

** Color theme
*** Utilities

A command to switch themes interactively.  Emacs's =load-theme= applies
all the loaded themes on top of each other; I like to only have one
theme active at all times, so I use =disable-theme= on all themes in
=custom-enabled-themes= before enabling the target theme.

#+begin_src emacs-lisp
  (defvar my/switch-theme-hook nil
    "Functions to be called after switching the current (default)
  font.")

  (defun my/switch-theme-hook ()
    "Run `my/switch-theme-hook'."
    (run-hook-with-args 'my/switch-theme-hook))

  (defun my/switch-theme (name)
    "Switch themes interactively.  Similar to `load-theme' but also
  disables all other enabled themes."
    (interactive
     (list (intern
	    (completing-read
	     "Theme: "
	     (mapcar #'symbol-name
		     (seq-difference (custom-available-themes)
				     custom-enabled-themes))))))
    (progn
      (mapc #'disable-theme
	    custom-enabled-themes)
      (load-theme name t)
      (my/switch-theme-hook)))
#+end_src

When developing a theme, like I did with =naga=, it's handy to
be able to reload it on the fly.

#+begin_src emacs-lisp
(defun my/reload-theme ()
  "Reload the currently active theme."
  (interactive)
  (let ((active-theme (car custom-enabled-themes)))
    (my/switch-theme active-theme)))
#+end_src

As with fonts, I like changing visuals regularly, as in, multiple
times a day usually.  So keybindings for this come in useful:

#+begin_src emacs-lisp
(keymap-global-set "C-t t t" 'my/switch-theme)
(keymap-global-set "C-t t r" 'my/reload-theme)
#+end_src

*** My favorite Emacs themes

Since I cannot ever decide which theme I like best, there are a few
themes, or theme collections, loaded here.

**** Custom theme: =naga=

I usually use [[https://github.com/kenranunderscore/emacs-naga-theme][my own /naga/ theme]].  It is currently in the process of
being made ready to be put on MELPA.

While that is still going on I'm using a "mutable" path, assuming I've
cloned my project repository to a fixed location.  This allows for
quick iteration.

#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path "~/projects/emacs-naga-theme")
#+end_src

Enable =naga=:

#+begin_src emacs-lisp
(setq naga-theme-use-lighter-org-block-background nil)
(setq naga-theme-modeline-style 'green-box)
(my/switch-theme 'wheatgrass)
#+end_src

**** Modus themes

[[https://protesilaos.com/emacs/modus-themes][This package]] by Protesilaos Stavrou is my first choice of "external"
themes.  I find myself going back to =modus-vivendi= in the evening,
even though I keep saying that I don't like that high of a contrast.

These two themes are very customizable and come with the most
comprehensive and extensive documentation (same as with basically
anything that Prot makes available).

#+begin_src emacs-lisp
(use-package modus-themes
  :defer
  :config
  (setq modus-themes-subtle-line-numbers t)
  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs nil)
  (setq modus-themes-syntax '(green-strings alt-syntax))
  (setq modus-themes-prompts '(background bold))
  (setq modus-themes-mode-line nil)
  (setq modus-themes-completions
        '((matches . (intense background))
          (selection . (intense accented))
          (popup . (intense accented))))
  (setq modus-themes-fringes nil)
  (setq modus-themes-paren-match '(bold intense))
  (setq modus-themes-region '(accented bg-only))
  ;; TODO: org agenda, mail citations
  (setq modus-themes-org-blocks nil))
#+end_src

**** Doom themes

[[https://github.com/hlissner/doom-emacs][This package]] used to be my go-to source of different themes.  It's a
megapack, started by the creator of [[https://github.com/hlissner/doom-emacs][Doom Emacs]], Henrik Lissner, but
over time it grew into an extensive collection of different themes.

It also comes with a DSL to create custom "doom themes", that is, one
specifies a relatively small number of faces / colors and the results
are propagated to most faces of all the common packages.  Without
using (something like) this, it's quite a bit of work to style lots of
packages, as one might imagine.  I'll leave this here for posterity
and also to from time to time enable it and check out newly added doom
themes.

#+begin_src emacs-lisp :tangle no
(use-package doom-themes
  :defer
  :disabled)
#+end_src

** Render color names/codes in their respective color

=Rainbow-mode= does what the (org) title says: whenever you see a color
in text in Emacs, say, the nice orange #ff9000, then it will be
rendered with the respective background color.  The package will even
pick a fitting light or dark foreground for you.

Note that I load this deferred, and it won't be automatically started
when a color is encountered; I'll activate it with =M-x rainbow-mode
RET= whenever I see fit.

#+begin_src emacs-lisp
(use-package rainbow-mode
  :defer)
#+end_src

** Mode line

I could (and can) live with the default mode line just fine, but I
sometimes (usually when sharing my screen) stupidly click on the modes
and something annoying happens.  So let's try to fiddle with it to
make it work the way I like:

- No context/mouse menus
- Major mode separate from the list of minor modes I want to see
- Render the major mode with its "real" (but shortened through
  stripping the always-present =-mode= ending) name, i.e., in this file
  it should just show =org=
- Strip stuff away that I don't look at anyway

#+begin_src emacs-lisp
(defmacro my/with-active-face (face)
  "Return FACE if we're in the mode line of the active window, and
the `mode-line-inactive' face otherwise."
  `(if (mode-line-window-selected-p)
   ,face
     'mode-line-inactive)) 

(defcustom my/mode-line-buffer-format
  '(compilation-in-progress
     (:eval (propertize
	     "   [Compiling...]"
	     'face
	     (my/with-active-face compilation-mode-line-run))))
  "How to display the name of the current buffer in the mode line."
  :risky t)

(defcustom my/mode-line-flymake-format
  '(flymake-mode
    (:eval (when-let ((counters (format-mode-line 'flymake-mode-line-counters)))
	     `("   " ,counters))))
  "How to display the name of the current buffer in the mode line."
  :risky t)

(defcustom my/major-mode-mode-line-format
  '("" (:eval (string-replace "-mode" "" (symbol-name major-mode))))
  "How to display the active major mode in the mode line."
  :risky t)

(defun my/visible-minor-modes ()
  "Return `minor-mode-alist', but with certain modes I don't want to
see filtered out."
  (let ((hidden-modes '(gcmh-mode
                        which-key-mode
                        buffer-face-mode
                        eldoc-mode
                        org-indent-mode
                        auto-revert-mode
                        auto-fill-function)))
    (seq-difference minor-mode-alist
                    hidden-modes
                    (lambda (hidden cell)
                      (eq (car cell)
                          hidden)))))

(defcustom my/minor-modes-mode-line-format
  '("("
    (:eval
     (let ((s (format-mode-line (my/visible-minor-modes))))
       (substring s 1)))
    ")")
  "How to display the active minor modes in the mode line."
  :risky t)

(setq-default
 mode-line-format
 '(""
   my/mode-line-flymake-format
   my/mode-line-buffer-format
   (:propertize "   %b" face mode-line-buffer-id)
   ;; Always show current line and column, without checking
   ;; `column-number-mode' and `line-number-mode'
   ("   L%l C%c")
   ("   " my/major-mode-mode-line-format)
   ("   " my/minor-modes-mode-line-format)))
#+end_src

* Basic options
** Startup

FIXME: Move some of the following to =early-init.el= instead.  See
Prot's configuration for inspiration and give credit.

I wish to know how fast my Emacs is starting.  I'm not sure how to
make use of all that =use-package= has to offer in that regard yet, but
I want to at least know when I've made things worse.

#+begin_src emacs-lisp
(add-hook
 'emacs-startup-hook
 (lambda ()
   (message
    "Emacs startup took %s with %d garbage collections"
    (format
     "%.2f seconds"
     (float-time (time-subtract after-init-time before-init-time)))
    gcs-done)))
#+end_src

Disable the graphical UI things like the tool and menu bars, the
splash screen, and others.

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(setq inhibit-splash-screen nil)
#+end_src

** Resize proportionally after deleting windows

#+begin_src emacs-lisp
(setq window-combination-resize t)
#+end_src

** Less annoying yes/no questions

The following setting enables answering those yes/no questions with
just =y= or =n=.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** No annoying bell sounds

If =ring-bell-function= is =nil=, Emacs will still make a sound on, for
instance, =C-g=.  Since this annoys me to no end, I disable this by
customizing the function to essentially "do nothing".

#+begin_src emacs-lisp
(setq ring-bell-function #'ignore)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode.  Note:
this doesn't work correctly yet, as =(command-modes 'some-command)=
seems to return the modes in an unexpected format.

#+begin_src emacs-lisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

To display line numbers, the aptly named =display-line-numbers= package
is used.  I used to always show line numbers when programming with
=evil=, but with vanilla Emacs bindings absolute numbers make more
sense.  It's no real use showing them by default anymore though.

#+begin_src emacs-lisp
(defun my/toggle-line-numbers ()
  "Toggle `display-line-numbers-mode'.  Meant to be used in a
keybinding."
  (interactive)
  (display-line-numbers-mode 'toggle))

(use-package display-line-numbers
  :defer
  :bind
  ("C-t t l" . my/toggle-line-numbers))
#+end_src

** Insert a newline at the end of files

#+begin_src emacs-lisp
(setq require-final-newline t)
(setq mode-require-final-newline t)
#+end_src

** Suppress warning from native compilation

When using Emacs =HEAD= (with the merged =native-comp= branch) a lot of
warnings show up during startup and when changing modes.  We could
increase the minimum severity for logs to be shown by setting
=warning-minimum-level= to =:error=, or just disable the warnings for
native compilation entirely like this:

#+begin_src emacs-lisp
(setq native-comp-async-report-warnings-errors nil)
#+end_src

** Spaces over tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

** If I have to use tabs, at least make them smaller

Looking at you, [[https://go.dev/][Go]].

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

** File name searches should be case-insensitive

#+begin_src emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+end_src

** Yank (paste) at point with the mouse

The default Emacs behavior when yanking (in the Emacs sense of the
word) things from the clipboard by clicking the middle mouse button is
to insert those at the mouse cursor position.  I wish to be able to
carelessly click anywhere and have it insert at point, similar to how
it's done in most terminal emulators.

Of course there's an existing Emacs options for this:

#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

* Built-in packages with extensions
** Emacs Lisp

I like evaluating the top-level form I'm currently on by pressing =C-c
C-c=, similar to how one compiles in SLY/SLIME.

#+begin_src emacs-lisp
(use-package emacs
  :bind
  (:map emacs-lisp-mode-map
        ("C-c C-c" . eval-defun)))
#+end_src
 
** Display whitespace

Make whitespace symbols visible.

#+begin_src emacs-lisp
(use-package whitespace
  :defer
  :config
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode
              org-mode))
  (setq whitespace-style
        '(face newline newline-mark missing-newline-at-eof
               trailing empty tabs tab-mark))
  (setq whitespace-display-mappings
        '((newline-mark 10
                        [9166 10])
          (tab-mark 9
                    [187 9]
                    [92 9]))))
#+end_src

** Render manpages in Emacs

#+begin_src emacs-lisp
(use-package man
  :defer
  :config
  ;; As soon as it is ready open the manpage in a separate, focused
  ;; window.
  (setq Man-notify-method 'aggressive))
#+end_src

** =Isearch=

It hasn't been long since I switched from =evil= with its standard vim
search via =/=.  For many things I use =avy= now, but can't get around
the de-facto standard =isearch=.  I haven't gotten around to configuring
it a lot, but this will probably grow in the coming weeks or months.

#+begin_src emacs-lisp
(use-package isearch
  :ensure nil
  :config
  (setq-default isearch-lazy-count t))
#+end_src

** Don't trim ELisp evaluation results

#+begin_src emacs-lisp
(use-package simple
  :ensure nil
  :config
  (setq eval-expression-print-length nil)
  (setq eval-expression-print-level nil))
#+end_src

** ElDoc

#+begin_src emacs-lisp
(use-package eldoc
  :config
  (advice-add 'eldoc-doc-buffer
              :after
              (defun my/focus-eldoc-buffer ()
                (message (buffer-name (current-buffer)))
                (pop-to-buffer eldoc--doc-buffer))))
#+end_src

** Directory editor

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :defer
  :config
  (setq dired-kill-when-opening-new-dired-buffer t)
  (setq dired-create-destination-dirs 'ask)
  :custom
  ;; Sort directories to the top
  (dired-listing-switches "-la --group-directories-first"))
#+end_src

Beautify =dired= a bit.

#+begin_src emacs-lisp
(use-package diredfl
  :defer
  :after dired
  :hook (dired-mode . diredfl-mode))
#+end_src

=Dired-narrow= is a package containing functionality to enter a filter
to narrow down the contents of a =dired= buffer interactively.  The
filter could be either some fixed string, with normal or fuzzy
matching, or a regural expression.  Bind those three functions to the
local leader key to have easier access, as =dired= already has lots of
keys bound.

#+begin_src emacs-lisp
(use-package dired-narrow
  :defer
  :after dired)
#+end_src

** Ediff

=Ediff= is a great way to diff and/or merge files or buffers.  By
default it creates a new frame containing a "control buffer" used to
navigate the diff and manipulate the output.  Unfortunately for the
longest time this behaved weirdly for me: whenever I'd tab to the
frame containing the diff, do something, then tab back, the next
navigational command from the control frame would work but drop me
back in the diff frame.  It's possible to use
=ediff-setup-windows-plain= as setup function, which makes =ediff=
single-frame, circumventing the problem.

#+begin_src emacs-lisp
(use-package ediff-wind
  :defer
  :ensure nil
  :config
  (setq ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

** Auto-closing parens, braces and other pairs

I used to use =smartparens= to automatically insert closing parentheses
and other pairs in non-lispy modes.  One thing I was missing from
Neovim, though, was the newlines and indentation that it inserted
automatically when pressing =RET= with point between braces.

The built-in =electric-pair-mode= does just that (by default).  I just
realized that I don't really need it after all (neither with =evil= nor
without it).

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init
  (electric-pair-mode -1) ; disabled
  :config
  (setq electric-pair-open-newline-between-pairs t))
#+end_src

** Undo changes to window arrangements

Sometimes I accidentally mess up my window layout.  =Winner-mode= comes
with the =winner-undo= command (bound by default to =C-<left>=) that
reverts such changes.

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :init (winner-mode))
#+end_src

** Correct typos while typing with =abbrev=

=Abbrev-mode= is a nice built-in minor mode that silently replaces some
things I type with other things.  It is mostly used for correcting
typos, though I haven't really "trained" my self-made list of abbrevs
-- I've just started using it.

Since it doesn't come with a global mode itself, I use =setq-default= to
enable it everywhere.

#+begin_src emacs-lisp
(use-package emacs
  :init
  (setq-default abbrev-mode t)
  :config
  (setq save-abbrevs 'silent)
  (setq abbrev-file-name
        (concat user-emacs-directory "abbrev_defs")))
#+end_src

* Incremental narrowing with =vertico=

I started with =helm= in [[https://www.spacemacs.org/][spacemacs]], then later switched to [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
where after a while I tried out =ivy= and loved it.  Configuring Emacs
from scratch was when I decided to try out some of the newer, more
lightweight Emacs packages like [[https://github.com/raxod502/selectrum][selectrum]] and [[https://github.com/minad/vertico][vertico]].  Those
integrate very well with default Emacs functionality, so a lot of
things can utilize them "implicitly".  I've stuck with =vertico= and
I've been happy with it ever since.

#+begin_src emacs-lisp
(use-package vertico
  :init
  (vertico-mode +1)
  :custom
  (vertico-cycle t)
  (vertico-resize t))
#+end_src

Directory navigation in =C-x d= or =C-x C-f= is something else that I
liked in Doom Emacs, as Doom had a notion of "directory name", that
is, =DEL= would delete one level in the directory hierarchy, including
the slash symbol.  The following extension to =vertico= does just that.

#+begin_src emacs-lisp
(use-package vertico-directory
  :ensure nil
  :after vertico
  :bind (:map vertico-map
              ("DEL" . vertico-directory-delete-char)
              ("C-w" . vertico-directory-delete-word)
              ("RET" . vertico-directory-enter)))
#+end_src

** Remembering command history

=savehist-mode= keeps a history of commands and inputs I've done in a
context-sensitive way, and then shows those at the top when presented
with possible results from =vertico=.

#+begin_src emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][orderless]] is a /completion style/ that fits in very well with =vertico=
(or =selectrum=, for that matter).  Parts of a search string may match
according to several matching styles.  We want to be able to specify
which matching style to use by appending a suffix so a search string.
Therefore we define style dispatchers and use them to customize
=orderless-style-dispatchers=.

Prepending an equals sign to a search term will search for literal
matches of the preceding string.

#+begin_src emacs-lisp
(defun my/literal-if-= (pattern _index _total)
  (when (string-prefix-p "=" pattern)
    `(orderless-literal . ,(substring pattern 1))))
#+end_src

A prepended bang discards everything that matches the preceding
literal string.

#+begin_src emacs-lisp
(defun my/without-if-! (pattern _index _total)
  (when (string-prefix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

The tilde sign gives me a way to have "fuzzy" search, if needed.

#+begin_src emacs-lisp
(defun my/flex-if-~ (pattern _index _total)
  (when (string-prefix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 1))))
#+end_src

#+begin_src emacs-lisp
(use-package orderless
  :custom (completion-styles '(orderless))
  (orderless-style-dispatchers
   '(my/literal-if-=
     my/without-if-!
     my/flex-if-~)))
#+end_src

** Consult

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite
some time, though not in any extent close to full.  This defines some
basic bindings mostly taken from an example in its readme.

#+begin_src emacs-lisp
(use-package consult
  :bind (("C-x b" . consult-buffer)
         ("C-x C-b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ("C-h a" . consult-apropos)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ("M-s f" . consult-find)
         ("M-s L" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s m" . consult-multi-occur)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines))
  :config
  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (project-root project))))
  (setq consult-ripgrep-args
        (concat consult-ripgrep-args
                " --hidden")))
;; TODO other isearch integration?
;; TODO :init narrowing, preview delay
#+end_src

** Minibuffer actions

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet.  It seems to be amazing, though!
What I mostly use it for at the moment is its =embark-act= command in
conjunction with =embark-export=.  With this I often pull the results of
some =grep= command into a separate buffer, where I can then utilize
=wgrep= to bulk-modify the original buffers.

#+begin_src emacs-lisp
(use-package embark
  :bind (("C-," . embark-act)
         ("C-h B" . embark-bindings))
  :init
  (setq prefix-help-command #'embark-prefix-help-command))
#+end_src

Integrate =embark= with =consult=.

#+begin_src emacs-lisp
(use-package embark-consult
  :after (embark consult)
  :demand
  :hook (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

* Jumping and sniping with =avy=

Try out =avy= to quickly jump to specific locations in the currently
visible area of the buffer.  This is similar to =evil-snipe= in Emacs,
or (neo)vim plugins like =vim-snipe=, =easymotion=, =leap.nvim=, =hop.nvim=,
=lightspeed.nvim=, etc.

#+begin_src emacs-lisp
(use-package avy
  :defer
  :config
  (setq avy-timeout-seconds 0.3)
  :bind
  ("C-'" . avy-goto-char-timer))
#+end_src

The =C-'= binding for =avy= clashes with the default binding for
=org-cycle-agenda-files= in the =org-mode-map=.  Removing it via hook
doesn't seem like a good way to do it, but it does the job.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (defun my/remove-shadowing-org-bindings ()
            (keymap-unset org-mode-map "C-'" t)
            (remove-hook 'org-mode-hook #'my/remove-shadowing-org-bindings)))
#+end_src

* Org mode

I want my headers to stand out by being really big.  I also like using
=variable-pitch-mode=, which makes it so only code, verbatim, and some
other things are written with my current monospace / fixed-width font,
and the rest uses a serif font more suitable for longer texts.  But
customizing these faces with =set-face-attribute= has the usual problems
with the initial daemon startup, and doesn't hold up when switching
fonts or themes.  That's why I've put those changes into the following
functions which I can call whenever these sorts of changes happen,
either through hooks or manual trigger.

Note that some themes, like =modus-{vivendi,operandi}=, might set the
=:inherit= attribute on a face, in which case a naive
~(set-face-attribute face nil :inherit 'fixed-pitch)~ overrides the
theme settings.  To circumvent this I've written the following
function that appends a single new value to the current =:inherit=
attribute value of a face.

#+begin_src emacs-lisp
(defun my/inherit-fixed-pitch (face)
  "Append `fixed-pitch' to the `:inherit' attribute of FACE."
  (let* ((current (face-attribute face :inherit))
         (new (cond
               ((eq 'unspecified current)
                'fixed-pitch)
               ((listp current)
                (if (member 'fixed-pitch current)
                    current
                  (cons 'fixed-pitch current)))
               ((not (eq 'fixed-pitch current))
                (list 'fixed-pitch current)))))
    (set-face-attribute face nil :inherit new)))

(defun my/org-font-setup ()
  "Set the face attributes for code, verbatim, and other markup
elements.  Also increase org header size."
  (interactive)
  (my/inherit-fixed-pitch 'org-block)
  (my/inherit-fixed-pitch 'org-block-begin-line)
  (my/inherit-fixed-pitch 'org-block-end-line)
  (my/inherit-fixed-pitch 'org-document-info-keyword)
  (my/inherit-fixed-pitch 'org-document-info)
  (my/inherit-fixed-pitch 'org-code)
  (my/inherit-fixed-pitch 'org-table)
  (my/inherit-fixed-pitch 'org-verbatim)
  (my/inherit-fixed-pitch 'org-checkbox)
  (my/inherit-fixed-pitch 'org-meta-line)
  (my/inherit-fixed-pitch 'org-special-keyword)
  (my/inherit-fixed-pitch 'org-link)
  (my/inherit-fixed-pitch 'org-todo)
  (my/inherit-fixed-pitch 'org-done)
  (my/inherit-fixed-pitch 'org-drawer)
  (my/inherit-fixed-pitch 'org-property-value)
  (my/inherit-fixed-pitch 'org-document-title))

(add-hook 'my/switch-theme-hook #'my/org-font-setup)
#+end_src

I capture mostly =TODO= items, so it's convenient to have a special
shortcut for that.

#+begin_src emacs-lisp
(defun my/capture-todo ()
  "Capture a TODO item with `org-capture'."
  (interactive)
  (org-capture nil "t"))
#+end_src

For navigation and other =org=-specific stuff I'm going to try out
another =hydra=.

#+begin_src emacs-lisp
(defhydra hydra-org (:hint nil)
  "\n
  navigational commands
  ^^----------------------^^----------------------------
  visible header:  [_n_] / [_p_]
  sibling header:  [_N_] / [_P_]
  block:           [_b_] / [_B_]

  misc commands
  ^^----------------------^^----------------------------
  [_t_]:   capture todo     [_c_]:   capture
  [_a_]:   agenda           [_f_]:   cycle agenda files
  [_l_]:   store link\n
  "
  ("n" org-next-visible-heading)
  ("p" org-previous-visible-heading)
  ("b" org-next-block)
  ("B" org-previous-block)
  ("N" org-forward-heading-same-level)
  ("P" org-backward-heading-same-level)
  ("t" my/capture-todo :exit t)
  ("c" org-capture :exit t)
  ("a" org-agenda :exit t)
  ("f" org-cycle-agenda-files :exit t)
  ("l" org-store-link :exit t)
  ("q" nil "exit"))
#+end_src

When writing text with =org=, =auto-fill-mode= should be enabled to
automatically break overly long lines into smaller pieces when typing.
One may still use =M-q= to re-fill paragraphs when editing text.  After
loading =org=, a custom font setup might run to adjust the headers.

#+begin_src emacs-lisp
(use-package org
  ;; Use the built-in version of org (which is quite up-to-date as I'm
  ;; always using emacs HEAD).  This circumvents problems with
  ;; 'org-compat of the older version having been loaded.
  :ensure nil
  :hook
  ((org-mode . auto-fill-mode)
   (org-mode . my/org-font-setup)
   ;; (org-mode . variable-pitch-mode)
   (org-trigger . save-buffer)
   ;; Inheriting fixed-pitch in my/org-font-setup doesn't work; the
   ;; face is not yet known there, so use a hook.
   (org-indent-mode . (lambda ()
                        (my/inherit-fixed-pitch 'org-indent)
                        (my/inherit-fixed-pitch 'org-hide))))
  :custom
  ((org-startup-indented t)
   (org-startup-folded 'content)
   (org-directory "~/org")
   (org-log-done t)
   (org-special-ctrl-a/e t)
   ;; If this has a value greater than 0, every RET press
   ;; keeps indenting the source block further and further.
   (org-edit-src-content-indentation 0)
   (org-default-notes-file "~/org/notes.org")
   (org-agenda-files '("~/org/inbox.org"
                       "~/org/gtd.org"))
   (org-agenda-restore-windows-after-quit t)
   (org-refile-targets `(("~/org/gtd.org" :maxlevel . 3)
                         ("~/org/someday.org" :level . 1)))
   (org-capture-templates '(("t" "Todo" entry
                             (file+headline "~/org/inbox.org" "Tasks")
                             "* TODO %i%?")
                            ("n" "Note" entry
                             (file+headline "~/org/notes.org" "Notes")
                             "* %?\n%a\nNote taken on %U")))
   (org-capture-bookmark nil)
   (org-bookmark-names-plist nil)
   (org-todo-keywords '((sequence
                         "TODO(t)"
                         "WAITING(w)"
                         "|"
                         "DONE(d)"
                         "CANCELLED(c)")))
   (org-html-htmlize-output-type 'css))
  :config
  (setq-default org-hide-emphasis-markers t)
  (advice-add 'org-refile
              :after (lambda (&rest _) (org-save-all-org-buffers)))
  :bind (("C-t o" . hydra-org/body)))
#+end_src

** Beautiful bullet points

#+begin_src emacs-lisp
(use-package org-bullets
  ;; :hook (org-mode . org-bullets-mode)
  :custom (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

Also render unordered list bullet points as dots instead of =-= or =+=.

#+begin_src emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("^ *\\([-]\\) "
    (0 (prog1 ()
         (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

** Show emphasis markers depending on point

In my =org= configuration I'm setting =org-hide-emphasis-markers= to =t=,
thus hiding certain markup elements around text.  Unfortunately it
seem to be currently impossible to switch this interactively, or I
just don't know how, which prevents me from simply adding a keybinding
to toggle it.

Thankfully a new package has appeared recently: [[https://github.com/awth13/org-appear][org-appear]]. It reacts
to the position of point to automatically show surrounding markup.

#+begin_src emacs-lisp
(use-package org-appear
  :hook ((org-mode . org-appear-mode))
  :config
  (setq org-appear-autolinks t)
  (setq org-appear-autosubmarkers t)
  (setq org-appear-autoentities t)
  (setq org-appear-autokeywords t)
  (setq org-appear-trigger 'always))
#+end_src

** Enable syntax highlighting when exporting to HTML

#+begin_src emacs-lisp
(use-package htmlize
  :defer
  :after ox)
#+end_src

* "Menus" with =hydra=

TODO

#+begin_src emacs-lisp
(use-package hydra
  :defer)
#+end_src

** "Error" navigation

Commands like =next-error= provide navigation for more than just errors
in the strict sense of the word.  For instance, they also work with
=occur= and =grep= type buffers (this holds for the variants of those that
I use as well: =embark= and =ripgrep=, with or without =consult=).

#+begin_src emacs-lisp
(defhydra hydra-navigate-errors (:hint nil)
  "\n
  Navigate the error list.\n
  _f_: first  _n_: next  _p_: previous\n
  "
  ("n" next-error)
  ("p" previous-error)
  ("f" first-error)
  ("q" nil "exit"))

(keymap-global-set "C-t n e" 'hydra-navigate-errors/body)
#+end_src

* On-the-fly syntax checking (and other things): =Flymake=

#+begin_src emacs-lisp
(use-package flymake
  :ensure nil
  :defer
  :config
  (setq flymake-suppress-zero-counters nil)
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-no-changes-timeout 1.0)
  (setq flymake-mode-line-lighter ""))
#+end_src

** Static analysis of shell scripts

[[https://github.com/koalaman/shellcheck][ShellCheck]] is a great little program providing feedback when writing
shell scripts.  The Emacs package [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]] integrates
ShellCheck with Flymake.  We have to trigger =flymake-shellcheck-load=
when loading shell scripts, and also enable Flymake itself, both done
via hooks to =sh-mode=.

#+begin_src emacs-lisp
(use-package flymake-shellcheck
  :after flymake
  :commands (flymake-shellcheck-load)
  :hook ((sh-mode . flymake-shellcheck-load)
         (sh-mode . flymake-mode)))
#+end_src

* Auto-completion popups via =corfu=

This is another one of Daniel Mendler's (aka =minad='s) absolutely great
Emacs packages!  I've replaced =company= with =corfu= in the past, but
back then it did not have the automatic mode (=corfu-auto=) yet.
Without automatic completion it was a little more tedious to use in
modes where =TAB= changes the level of indentation, like in
=haskell-mode= for instance.

Now that this feature exists it's time to give the package another
try.  The first impression was very positive, as =corfu= is using a
child frame for the completion popup and thus does not clash with
=whitespace-mode= the way =company= does.

#+begin_src emacs-lisp
(use-package corfu
  :init (global-corfu-mode)
  :config
  (setq corfu-cycle t)
  (setq corfu-auto nil)
  (setq corfu-auto-delay 0.0)
  (setq corfu-excluded-modes '(erc-mode)))
#+end_src

** Show documentation in a separate popup

I'll have to figure out whether I like this or not.  At the moment it
seems great.

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :ensure nil
  :config
  (corfu-popupinfo-mode)
  (setq corfu-popupinfo-delay 0.5))
#+end_src

** More completion-at-point backends via =cape=

#+begin_src emacs-lisp
(defun my/ignore-elisp-keywords (cand)
  "Do not show Emacs Lisp keywords in completions in
'emacs-lisp-mode'."
  (or (not (keywordp cand))
      (eq (char-after (car completion-in-region--data)) ?:)))

(defun my/setup-elisp-capfs ()
  "Uses 'cape-super-capf' to work around the problem that dabbrev
completions don't show up in 'emacs-lisp-mode' by default."
  (setq-local completion-at-point-functions
              `(,(cape-super-capf
                  (cape-capf-predicate
                   #'elisp-completion-at-point
                   #'my/ignore-elisp-keywords)
                  #'cape-dabbrev)
                cape-file))
  (setq-local cape-dabbrev-min-length 4))

(defun my/register-default-capfs ()
  "I use 'cape-dabbrev' and 'cape-file' everywhere as they are
generally useful.  This function needs to be called in certain
mode hooks, as some modes fill the buffer-local capfs with
exclusive completion functions, so that the global ones don't get
called at all."
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file))

(use-package cape
  :hook ((emacs-lisp-mode . my/setup-elisp-capfs)
         (haskell-mode . my/register-default-capfs))
  :init
  (my/register-default-capfs))
#+end_src

* E-mail configuration

There are different ways to "do e-mail in Emacs".  Over the last two
years I've tried out =notmuch=, =gnus=, and =mu4e=.  Some thoughts on each
of those:

** Notmuch

The Emacs integration for =notmuch= is great; it has the most intuitive
and appealing UI from each of the options.  =Notmuch= works by
referencing incoming e-mail in a separate database only, not ever
touching or modifying it.  I really like this idea, and in practice it
also felt great due to the quick und customizable searches.  The usual
approach is to use a tag-based system of categorizing your e-mail, but
simply having lots of stored queries is a little bit more flexible.

But =notmuch= only handles this single aspect; this means that one needs
to find solutions to the following:

- Getting mail
- Initial tagging
- Sending mail
- Synchronization between machines

Due to the declarative e-mail account configuration from =home-manager=
the first part is very simple, and I could also easily switch between
different tools like =isync= or =offlineimap=.

The initial tagging can be done with a shell script using the
well-documented =notmuch= CLI, or via =afew=.

For sending mail I use =msmtp=.

I'm using =muchsync= on my personal server to be the "source of truth".
This means that only the server downloads e-mail via IMAP, and the
machines are simply its /clients/; they use =muchsync= to download mail
from the server.

This sounds great on paper but is a little finicky with sent mail,
which I'd also like to sync back via IMAP to my accounts.  The client
machine sends this and puts it into respective =sent= directories;
=muchsync= synchronizes these directories as well, but I've had problems
with mails appearing twice, or appearing not at all on the respective
"other" machine, at least in the past.  It looks or feels like my
usage of =muchsync --nonew= on the clients was a potential problem: I've
verified that after sending a mail and it having landed in the correct
=sent= directory, a simple =muchsync my-server= didn't lead to the mail
appearing on my servers.  It worked after executing =notmuch new= once,
though, so I guess =muchsync= only synchronizes those mails that are
part of the current =notmuch= database state.

One solution would be to make sure that whenever I'm polling from
within Emacs, both =muchsync my-server= and =notmuch new= are executed.
Since =notmuch= has deprecated the =notmuch-poll-script= variable in their
Emacs client, I have to use the hooks it provides to make sure
=muchsync= is executed.  Putting =muchsync --nonew= into the =preNew= hook
while having an unsynchronized sent mail on the client sounds correct
on paper in order to not execute =notmuch new= twice, but it means that
in the case of an unsynchronized sent mail, this mail won't have been
pushed to the server after the first call, if I am correct.  So I'll
have to experiment and probably live with =notmuch new= being called
twice (which is fine as it's blazingly fast).

Let's first define some utility functions that I'll then bind to
special keys later.

#+begin_src emacs-lisp
(defun my/notmuch-search-toggle-unread ()
  "Toggle unread tag at point in `notmuch-search-mode'."
  (interactive)
  (if (member "unread" (notmuch-search-get-tags))
      (notmuch-search-tag '("-unread"))
    (notmuch-search-tag '("+unread")))
  (notmuch-search-next-thread))

(defun my/notmuch-search-toggle-deleted ()
  "Toggle deleted tag at point in `notmuch-search-mode'."
  (interactive)
  (if (member "deleted" (notmuch-search-get-tags))
      (notmuch-search-tag '("-deleted"))
    (notmuch-search-tag '("+deleted")))
  (notmuch-search-next-thread))

(defun my/notmuch-show-toggle-deleted ()
  "Toggle deleted tag at point in `notmuch-show-mode'."
  (interactive)
  (if (member "deleted" (notmuch-show-get-tags))
      (notmuch-show-tag '("-deleted"))
    (notmuch-show-tag '("+deleted")))
  (notmuch-show-next-thread t))
#+end_src

Now pull in and configure the actual =notmuch= package.  Note that same
options here rather belong to built-in functionality, but they fit in
here very well.

#+begin_src emacs-lisp
(use-package notmuch
  :defer
  :init
  (setq user-mail-address "johannes.maier@mailbox.org")
  :custom
  ;; msmtp is registered as sendmail
  (message-send-mail-function 'message-send-mail-with-sendmail)
  (message-kill-buffer-on-exit t)
  ;; When replying to mail, choose the account to use
  ;; based on the recipient address
  (message-sendmail-envelope-from 'header)
  (mail-envelope-from 'header)
  (mail-user-agent 'message-user-agent)
  ;; Settings for notmuch itself
  (notmuch-show-all-multipart/alternative-parts nil)
  (notmuch-hello-sections
   '(notmuch-hello-insert-header
     notmuch-hello-insert-saved-searches
     notmuch-hello-insert-footer))
  (notmuch-always-prompt-for-sender t)
  (notmuch-search-oldest-first nil)
  (notmuch-maildir-use-notmuch-insert t)
  (notmuch-archive-tags '("-inbox" "-unread"))
  (notmuch-message-replied-tags '("+replied" "+sent"))
  (notmuch-fcc-dirs
   '(("johannes.maier@mailbox.org" . "mailbox/Sent -inbox -unread +sent +private")
     ("johannes.maier@active-group.de" . "ag/Sent -inbox -unread +sent +work")
     (".*" . "sent")))
  (notmuch-saved-searches
   '((:name "inbox" :query "tag:inbox" :key "i")
     (:name "sent" :query "tag:sent" :key "s")
     (:name "work" :query "tag:inbox and tag:work" :key "w")
     (:name "private" :query "tag:inbox and tag:private" :key "p")
     (:name "all mail" :query "*" :key "a")))
  :bind
  (:map notmuch-show-mode-map
        ("d" . my/notmuch-show-toggle-deleted)
        :map notmuch-search-mode-map
        ("d" . my/notmuch-search-toggle-deleted)
        ("u" . my/notmuch-search-toggle-unread)))
#+end_src

=Gnus-alias= makes it possible to use different identities when
composing mail.  I mostly use it to make sure that replies to a mail
are sent from the address I've received it at.

#+begin_src emacs-lisp
(use-package gnus-alias
  :defer t
  :config
  (setq gnus-alias-identity-alist
        `(("mailbox"
           nil
           "Johannes Maier <johannes.maier@mailbox.org>"
           nil
           nil
           nil
           nil)
          ("ag"
           nil
           "Johannes Maier <johannes.maier@active-group.de>"
           "Active Group GmbH"
           nil
           nil
           ,(concat
             "Johannes Maier\n"
             "johannes.maier@active-group.de\n\n"
             "+49 (7071) 70896-67\n\n"
             "Active Group GmbH\n"
             "Hechinger Str. 12/1\n"
             "72072 Tübingen\n"
             "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
             "Geschäftsführer: Dr. Michael Sperber"))))
  (setq gnus-alias-default-identity "mailbox")
  (setq gnus-alias-identity-rules
        '(("ag" ("any" "@active-group.de" both) "ag")))
  :hook
  (message-setup . gnus-alias-determine-identity))
#+end_src

** Gnus

I've not given =gnus= the trial it deserves.  Reading newsgroups and
mailing lists is something I can image using =gnus= for in the future.
Using it for e-mail, though, would require another synchronization
process of the =gnus= state.

I could utilize =syncthing=, which I use for synchronization of my =org=
files, to do this as well, but I've given it a couple of tries and
couldn't do it.  An experiment for another time, for sure.

** Mu for Emacs

[[https://www.djcbsoftware.nl/code/mu/][Mu]] is what I'm currently using, and =mu4e= is its Emacs frontend.  It's
not as customizable as =notmuch=, but part of its charme is that I don't
need to sync anything between my machines, at the cost of =mu= touching
my e-mail (adding custom headers I believe).  I don't mind this at
all, and I can use =isync= and =msmtp= to receive and send mail on any
host.

For writing e-mails =mu4e= uses =message-mode= like the other tools.  This
checks the =user-full-name= variable to fill in my name.

#+begin_src emacs-lisp
(setq user-full-name "Johannes Maier")
#+end_src

The actual =mu4e= configuration is one huge =use-package= block, but most
of it is due to its concept of /contexts/.  Usually there's one context
for each of my e-mail addresses, and switching between them I may set
some context-specific variables, or even change the =mu4e= UI
accordingly.

#+begin_src emacs-lisp :tangle no
(use-package mu4e
  :disabled
  :load-path "~/.nix-profile/share/emacs/site-lisp/mu4e"
  :defer
  :commands (mu4e)
  :config
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-completing-read-function #'completing-read)
  ;; I don't sync drafts to either of the accounts
  (setq mu4e-confirm-quit nil)
  (setq mu4e-change-filenames-when-moving t)
  (setq mu4e-drafts-folder "/drafts")
  (setq mu4e-attachment-dir "~/Downloads/")
  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "mailbox"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/mailbox"
                                             (mu4e-message-field msg :maildir)
                                             t)))
            :vars '((user-mail-address . "johannes.maier@mailbox.org")
                    (mu4e-compose-signature . nil)
                    (mu4e-sent-folder . "/mailbox/Sent")
                    (mu4e-trash-folder . "/mailbox/Trash")
                    (mu4e-refile-folder . (lambda (msg)
                                            (let* ((date (mu4e-message-field-at-point :date))
                                                   (year (decoded-time-year (decode-time date))))
                                              (concat "/mailbox/Archive/"
                                                      (number-to-string year)))))))
          ,(make-mu4e-context
            :name "ag"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/ag"
                                             (mu4e-message-field msg :maildir)
                                             t)))
            :vars `((user-mail-address . "johannes.maier@active-group.de")
                    ;; FIXME: Signature in a file?
                    (mu4e-compose-signature . ,(concat
                                                "Johannes Maier\n"
                                                "johannes.maier@active-group.de\n\n"
                                                "+49 (7071) 70896-67\n\n"
                                                "Active Group GmbH\n"
                                                "Hechinger Str. 12/1\n"
                                                "72072 Tübingen\n"
                                                "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                                                "Geschäftsführer: Dr. Michael Sperber"))
                    (mu4e-sent-folder . "/ag/Sent")
                    (mu4e-refile-folder . (lambda (msg)
                                            (let* ((date (mu4e-message-field-at-point :date))
                                                   (year (decoded-time-year (decode-time date))))
                                              (concat "/ag/Archives/"
                                                      (number-to-string year)))))
                    (mu4e-trash-folder . "/ag/Trash")))))
  (setq mu4e-bookmarks '((:name "Active-Group inbox" :query "maildir:/ag/Inbox" :key ?a)
                         (:name "Mailbox inbox" :query "maildir:/mailbox/Inbox" :key ?m)
                         (:name "Unread messages" :query "flag:unread AND NOT flag:trashed" :key ?u)
                         (:name "Sent" :query "maildir:/ag/Sent OR maildir:/mailbox/Sent" :key ?s)))
  (setf (alist-get 'trash mu4e-marks)
        (list :char '("d" . "▼")
              :prompt "dtrash"
              :dyn-target (lambda (target msg)
                            (mu4e-get-trash-folder msg))
              :action (lambda (docid msg target)
                        (mu4e~proc-move docid (mu4e~mark-check-target target)) "-N")))
  (setq mu4e-headers-fields '((:human-date . 12)
                              (:flags . 6)
                              (:maildir . 15)
                              (:mailing-list . 10)
                              (:from . 22)
                              (:subject)))
  (setq mu4e-context-policy 'pick-first)
  (setq mu4e-compose-policy 'ask)
  ;; Getting mail via mbsync
  (setq mu4e-get-mail-command "mbsync -a")
  ;; Composing emails
  (setq message-send-mail-function #'message-send-mail-with-sendmail)
  (setq send-mail-function #'message-send-mail-with-sendmail)
  (setq message-sendmail-envelope-from 'header)
  (setq mail-envelope-from 'header)
  (setq mail-specify-envelope-from 'header)
  (setq message-kill-buffer-on-exit t)
  ;; Visuals
  (setq mu4e-headers-thread-single-orphan-prefix '("─> " . "─▶"))
  (setq mu4e-headers-thread-orphan-prefix '("┬> " . "┬▶ "))
  (setq mu4e-headers-thread-child-prefix '("├> " . "├▶"))
  (setq mu4e-headers-thread-connection-prefix '("│ " . "│ "))
  (setq mu4e-headers-thread-duplicate-prefix '("= " . "≡ "))
  (setq mu4e-headers-thread-first-child-prefix '("├> " . "├▶"))
  (setq mu4e-headers-thread-last-child-prefix '("└> " . "╰▶")))
#+end_src

* Window management
** Taming popups

TODO: reevaluate whether I need this after switching away from =evil=

One thing I'm missing from Doom Emacs is the way it handled all sorts
of popup-like buffers.  When using vanilla Emacs with packages, there
are some different behaviors w.r.t. popups:

- Window splits, new buffer is focused
- Window splits, but new buffer is not focused
- Popup opens over current buffer
- The popup may be closed by pressing =q=
- The popup needs to be closed by killing the window
- The popup needs to be closed by killing the buffer
- ... and probably others

Doom makes it so there is a unified way of dealing with these, and
they all open and behave the same way.  In theory much of this should
boil down to good customization of =display-buffer-alist=, but that's
pretty arcane.  =Shackle.el= seems to make this easier.  There's also
=popper.el=, and I'm not quite sure yet where the differences are.  My
guess is that they probably go well together.

#+begin_src emacs-lisp
(use-package shackle
  :init (shackle-mode)
  :config
  (setq shackle-inhibit-window-quit-on-same-windows t)
  (setq shackle-default-alignment 'below)
  (setq shackle-default-size 0.4)
  (setq shackle-rules '((helpful-mode :align t :select t)
                        (help-mode :align t :select t)
                        (compilation-mode :align t :select t)
                        (apropos-mode :align t :select t)
                        ("^\\*eldoc" :regexp t :align below :select t)
                        ("^\\*Occur" :regexp t :align t :select t)
                        ("^\\*sly-description" :regexp t :align t :select t)
                        ("^\\*lispy" :regexp t :align t :noselect t)))
  (setq shackle-default-rule nil))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package popper
  :disabled
  :defer
  :init (popper-mode))
#+end_src

*** TODO What kinds of popups to try and tame? [0/7]
- [ ] REPLs
- [ ] =helpful=
- [ ] =apropos=
- [ ] Compilation results
- [ ] Shell command results
- [ ] LSP / =eglot=

** Resizing windows in splits

Resizing windows is one of those things that still make me use a
mouse, as I find the default bindings awkward to use and especially
chain.  A =hydra= might just remedy that:

#+begin_src emacs-lisp
(defhydra hydra-window-size (:hint nil)
  "\n
  Adjust window sizes.\n
  height   +: [_g_]   -: [_l_]
  width    +: [_w_]   -: [_n_]\n
  "
  ("b" balance-windows "balance windows" :color blue)
  ("g" enlarge-window)
  ("l" shrink-window)
  ("w" enlarge-window-horizontally)
  ("n" shrink-window-horizontally)
  ("q" nil "exit"))

(keymap-global-set "C-t w" 'hydra-window-size/body)
#+end_src

* IRC with ERC

I've been using [[https://weechat.org][weechat]] for IRC communication in the past.  And while
my usage of IRC has decreased quite a bit due to a lot of things
moving over to Discord, there are some channels and communities that
have their sole online presence in IRC.  As with anything, it's worth
trying whether just using Emacs might be preferable.  So far my
experience with ERC has been quite smooth and I don't regret it yet,
so I've fully switched over.

#+begin_src emacs-lisp
(use-package erc
  :defer
  :config
  (setq erc-autojoin-channels-alist
        '((libera "#emacs"
                  "#nyxt"
                  "#systemcrafters"
                  "#org-mode"
                  "#haskell"
                  "#nim"
                  "#notmuch"
                  "#zig"
                  "#crawl"
                  "#guix"
                  "#commonlisp"
                  "#lisp"
                  "#herrhotzenplotz")))
  (setq erc-track-exclude
        '("#org-mode" "#crawl" "#nim" "#zig"))
  (setq erc-track-exclude-types '("333" "353"))
  (setq erc-hide-list '("NICK" "MODE" "AWAY" "JOIN" "PART" "QUIT" "AWAY"))
  (setq erc-track-exclude-server-buffer t)
  (setq erc-kill-server-buffer-on-quit t)
  (setq erc-kill-buffer-on-part t)
  (setq erc-fill-column 130)
  (setq erc-fill-static-center 20)
  (setq erc-fill-function #'erc-fill-static))

(use-package erc-hl-nicks
  :after erc
  (add-to-list 'erc-modules 'hl-nicks))

(use-package erc-image
  :after erc
  :config
  (setq erc-image-inline-rescale 200)
  (add-to-list 'erc-modules 'image))

(defun start-irc ()
  "Connect to some IRC servers."
  (interactive)
  (erc-tls :id 'libera
           :server "irc.libera.chat"
           :port 6697
           :nick "kenran"
           :full-name "kenran"
           :client-certificate (let ((cert-dir (getenv "KENRAN_IRC_CERTS")))
                                 `(,(concat cert-dir "/kenran.key")
                                   ,(concat cert-dir "/kenran.crt")))))
#+end_src

* Repeating the last edit with =dot-mode=

One thing I found myself missing from my time with vim or =evil= was the
=.= operator, which repeats the previous "edit".  Since vim uses
separate modes for "inserting text" and "movement and other commands",
it is always intuitively clear what "the last thing I've done" means
in any context.

With =dot-mode=, I'm concerned about two things:

- I don't have any intuition for what constitutes "the last edit", and
  I also don't have a mental model of what I should expect here, yet.
- Built-in functionality might be better, or at least suffice!  In
  vim, my most frequent uses of the =.= operator where actually edits
  combined with going through search (via =/=) results, say, doing
  =/fooBar= followed by =ctB baz <esc>= and repeated applications of =n.=.
  This usually isn't even the most efficient way to do this in vim, as
  you have tools like =:s.../c= and =:g= at your disposal.  Now in Emacs
  I'm also trying out multiple cursors, which might remove the need
  for the =.= operator in another whole class of situations.

So I'll add this package for now; but I will try to stop and think
when attempting to use it, and compare it with region-restricted usage
of =query-replace= (or similar), multiple cursors, and maybe rectangular
selection/edits.  This way I hope I can /really/ understand if and when
to use it.

#+begin_src emacs-lisp
(use-package dot-mode
  :init
  (global-dot-mode 1)
  :config
  (setq dot-mode-ignore-undo t)
  :bind
  (:map dot-mode-map
        ("C-." . nil)
        ("C-c ." . nil)
        ("C-M-." . nil)
        ("C-q" . dot-mode-execute)))
#+end_src

* Multiple cursors

I'm still new to this, and have only scratched the surface of when to
successfully use them.  In particular I'm not sure about what my
most-used commands will be, and if and where to bind those.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :defer
  :config
  (keymap-unset mc/keymap "<return>")
  :init
  (add-hook 'multiple-cursors-mode-hook
            (defun my/work-around-multiple-cursors-issue ()
              "Loads the file multiple-cursors-core.el (probably for the second
time), which makes the cursors work again.  See
https://www.reddit.com/r/emacs/comments/121swxh/multiplecursors_error_on_emacs_29060/."
              (load "multiple-cursors-core.el")
              (remove-hook 'multiple-cursors-mode-hook #'my/work-around-multiple-cursors-issue))))
#+end_src

I'm still not used to using hydras for lots of things, but in the case
of =multiple-cursors=, I could not decide which of all the very useful
commands should be bound to easily accessible keys.  Due to the nature
of =mc/mark-next-like-this= and consorts, a hydra should lend itself
very well to this package.  It can then be bound to a top-level
keybinding for the best of both worlds.

Credit: I found [[https://github.com/ejmr/DotEmacs][ejmr's archived Emacs configuration]] on GitHub; it
contains lots of hydras, so I took heavy inspiration there.

#+begin_src emacs-lisp
(defhydra hydra-multiple-cursors (:hint nil)
  "\n
  ^^forward       ^^backward        region-based
  ^^--------------^^-------------   ^^-------------------^^---------------------
  [_n_]   next    [_p_]   next      [_l_]   lines        [_C-a_] beg. of lines
  [_N_]   skip    [_P_]   skip      [_a_]   all          [_C-e_] end. of lines
  [_M-n_] unmark  [_M-p_] unmark    [_M-w_] all words    [_M-w_] words in defun
  [_w_]   word    [_W_]   word      [_r_]   regexp

  "
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("w" mc/mark-next-like-this-word)
  ("W" mc/mark-previous-like-this-word)
  ("r" mc/mark-all-in-region-regexp :exit t)
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("M-w" mc/mark-all-words-like-this :exit t)
  ("C-w" mc/mark-all-words-like-this-in-defun :exit t)
  ("C-a" mc/edit-beginnings-of-lines :exit t)
  ("C-e" mc/edit-endings-of-lines :exit t)
  ("q" nil "exit"))

(keymap-global-set "C-z" #'hydra-multiple-cursors/body)
#+end_src

* Package-specific configuration
** Mode-specific code snippets

#+begin_src emacs-lisp
(use-package tempel
  :commands (tempel-done)
  :config
  (setq tempel-path
        (expand-file-name "templates.eld"
                          user-emacs-directory))
  :bind
  (("M-*" . tempel-expand)
   (:map tempel-map
         ("C-j" . tempel-next)
         ("TAB" . tempel-next)
         ("C-k" . tempel-previous))))
#+end_src

** Unified interface for creating code formatters

Another generally useful package by Steve Purcell is [[https://github.com/purcell/emacs-reformatter][reformatter.el]].
It enables easy definition of commands to format buffers, as well as
minor modes that, when active, automatically apply these commands on
save.

#+begin_src emacs-lisp
(use-package reformatter
  :defer)
#+end_src

** Terminal emulator in Emacs

=vterm= is a terminal emulator for Emacs, more feature-rich than the
built-in =term=.  This is very useful for quickly spawning a terminal,
for instance in the top-level directory of a project.

#+begin_src emacs-lisp
(use-package vterm
  :commands (vterm)
  :defer)
#+end_src

** C/C++

#+begin_src emacs-lisp
(setq c-default-style '((awk-mode . "awk")
                        (other . "stroustrup")))
#+end_src

** Zig

[[https://ziglang.org/][Zig]] is a relatively new systems programming language that I could see
me learning more in-depth in the near future.  It's a smaller language
than, say, Rust, and less safe; but I like its explicit nature and
great defaults.  The community is very welcoming so far, as well!

#+begin_src emacs-lisp
(use-package zig-mode
  :defer)
#+end_src

** OCaml

[[https://github.com/ocaml/tuareg][tuareg]] is the standard mode for OCaml editing, providing syntax
highlighting, REPL support, etc., similar to what =haskell-mode= does
for Haskell.

#+begin_src emacs-lisp
(use-package tuareg
  :defer
  :hook (tuareg-mode . (lambda () (setq mode-name "🐫")))
  :config
  (setq tuareg-indent-align-with-first-arg nil)
  (setq tuareg-match-patterns-aligned t))
#+end_src

To get some IDE features for OCaml in Emacs I use [[https://github.com/ocaml/merlin][merlin]].

#+begin_src emacs-lisp
(use-package merlin
  :hook ((tuareg-mode . merlin-mode)))
#+end_src

[[https://github.com/Khady/merlin-eldoc][merlin-eldoc]] integrates =merlin= with =eldoc-mode=, automatically
documenting things at point.

#+begin_src emacs-lisp
(use-package merlin-eldoc
  :after merlin
  :hook (tuareg-mode . merlin-eldoc-setup)
  :config
  (setq merlin-eldoc-max-lines 8)
  (setq merlin-eldoc-type-verbosity 'min)
  (setq merlin-eldoc-function-arguments t)
  (setq merlin-eldoc-doc t))
#+end_src

** Fish

I'm often using the [[https://fishshell.com/][fish]] shell.  It comes with its own,
POSIX-incompatible language, but I mainly use it for =fish='s
configuration (though most of that is done via =nix=, anyway).  It's
nice to have syntax highlighting, though.

#+begin_src emacs-lisp
(use-package fish-mode
  :defer)
#+end_src

** EditorConfig

I want to be able to simply clone and work in projects and adapt to
their respective styles of indentation, newlines at the end of files,
and the like.  [[https://editorconfig.org/][EditorConfig]] comes with a specified file format to
describe these things, possible even on per-file basis; all one needs
to use these is support of one's editor.  Many editors have
out-of-the-box EditorConfig support nowadays.  For Emacs, there's the
official [[https://github.com/editorconfig/editorconfig-emacs][editorconfig-emacs]] package.

#+begin_src emacs-lisp
(use-package editorconfig
  :config
  (setq editorconfig-mode-lighter " EC")
  (editorconfig-mode 1))
#+end_src

** Ini files

I'm not 100 percent happy with this package, as paragraphs seem to be
acting strange.  Deleting a paragraph via =dap= for instance often
deletes the following one, too, plus sometimes the previous section
header.

#+begin_src emacs-lisp
(use-package ini-mode
  :defer)
#+end_src

** JavaScript

#+begin_src emacs-lisp
(use-package js
  :defer
  :config
  (setq js-indent-level 2))
#+end_src

** Purescript

#+begin_src emacs-lisp
(use-package psc-ide
  :hook (purescript-mode . psc-ide-mode)
  :config
  (setq psc-ide-rebuild-on-save t))

(use-package purescript-mode
  :hook (purescript-mode . turn-on-purescript-indentation))
#+end_src

** Nix

#+begin_src emacs-lisp
(reformatter-define my/nix-format
  :program "nixfmt"
  :args '()
  :lighter " k/nixfmt")

(use-package nix-mode
  :mode "\\.nix\\'"
  :hook (nix-mode . my/nix-format-on-save-mode))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "pandoc")
  :hook ((markdown-mode gfm-mode) . auto-fill-mode))
#+end_src

** Haskell

Provide an interactive mode for writing Haskell.  I can work with a
REPL, get feedback and compilation errors shown in the code, and so
on.  I've also added a bunch of utility functions and want to load
everything lazily, so I've created a [[file:my-packages/my-haskell.org][custom local Emacs package]] that
contains everything.

#+begin_src emacs-lisp
(use-package my-haskell
  :demand
  :load-path my/custom-package-dir)
#+end_src

** Dhall

#+begin_src emacs-lisp
(use-package dhall-mode
  :mode "\\.dhall\\'"
  :config
  (setq dhall-type-check-inactivity-timeout 2))
#+end_src

** Docker

I still have to semi-regularly write Dockerfiles.  This package comes
with syntax highlighting for those.

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :defer)
#+end_src

I'm trying out this package, as it provides a =magit=-like UI to control
images, containers, volumes, networks, etc. from inside Emacs.

#+begin_src emacs-lisp
(use-package docker
  :defer)
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :defer)
#+end_src

** Clojure

The key to using Clojure effectively with Emacs seems to be [[https://github.com/clojure-emacs/cider][CIDER]].

#+begin_src emacs-lisp
(use-package clojure-mode
  :defer)

(use-package cider
  :after clojure-mode
  :defer)
#+end_src

** CSV

#+begin_src emacs-lisp
(use-package csv-mode
  :defer)
#+end_src

** PlantUML

#+begin_src emacs-lisp
(use-package plantuml-mode
  :defer
  :init
  (add-to-list 'auto-mode-alist
               '("\\.\\(plantuml\\|puml\\)\\'" . plantuml-mode))
  :config
  (setq plantuml-default-exec-mode 'executable))
#+end_src

** Common Lisp

[[https://github.com/joaotavora/sly][SLY]] seems to be a bit more actively developed and modern than [[https://slime.common-lisp.dev/][SLIME]].

#+begin_src emacs-lisp
(use-package sly
  :defer
  :config
  (setq inferior-lisp-program "sbcl"))
#+end_src

=sly-asdf= gives integration with Common Lisp's package manager, [[https://asdf.common-lisp.dev/][ASDF]].

#+begin_src emacs-lisp
(use-package sly-asdf
  :defer)
#+end_src

** Racket

#+begin_src emacs-lisp
(use-package racket-mode
  :defer
  :hook ((racket-mode . racket-xp-mode)
         (racket-mode . racket-unicode-input-method-enable)
         (racket-repl-mode . racket-unicode-input-method-enable)))
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :defer
  :config
  (setq rust-format-on-save t))
#+end_src

** Java

I don't use Java, but Bob Nystrom's excellent and free book [[https://craftinginterpreters.com/][Crafting
Interpreters]] uses it for the first part.  It's actually quite OK to
write Java with =meghanada,= but it takes a long time to download all
its dependencies.

It's currently commented out as it's the last remaining package
pulling in =yasnippet=.

#+begin_src emacs-lisp
;; (use-package meghanada
;;   :defer
;;   :init
;;   (add-hook 'java-mode-hook
;;             (lambda ()
;;               (meghanada-mode t)
;;               (flycheck-mode +1)
;;               (setq c-basic-offset 2)
;;               (add-hook 'before-save-hook 'meghanada-code-beautify-before-save))))
#+end_src

** Python

#+begin_src emacs-lisp
(use-package anaconda-mode
  :defer
  :hook (python-mode . anaconda-mode))

(use-package pyimport
  :defer)
#+end_src

** Nim

#+begin_src emacs-lisp
(use-package nim-mode
  :defer)
#+end_src

** F#

#+begin_src emacs-lisp
(use-package fsharp-mode
  :defer
  :config
  (setq fsharp-indent-offset 2)
  (setq fsharp-continuation-offset 2)
  (setq inferior-fsharp-program "dotnet fsi --readline-"))
#+end_src

** Go

I neither like nor normally use Go, but it's nice to have some syntax
highlighting at least for when I /do/ have to read it.

#+begin_src emacs-lisp
(use-package go-mode
  :defer)
#+end_src

** LSP integration

I've used =lsp-mode= in the past and while it's nice, I feel like it's
more in line with the rest of this configuration to try out something
more lightweight and closer to vanilla Emacs.  This is where [[https://github.com/joaotavora/eglot][eglot]]
comes into play.

#+begin_src emacs-lisp
(use-package eglot
  :ensure nil
  :defer)
#+end_src

** Better Emacs help and documentation

This gives us better and more readable help pages.  We also replace
some built-in =C-h= keybings with =helpful-*= functions.

#+begin_src emacs-lisp
(use-package helpful
  :bind (("C-h f" . helpful-callable)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)))
#+end_src

** Project management

I've used [[https://github.com/bbatsov/projectile][projectile]] for a while.  It's great, but I found myself not
using most of its features.  Now that the built-in =project.el= has been
coming along great, I'm giving it a try.  I'm very happy with it so
far.

The following are utility functions that mostly rely on being in the
top-level directory of a known project.  =project.el= is making this
possible in a straightforward way.

#+begin_src emacs-lisp
(defun my/add-nix-envrc-file ()
  "If it doesn't already exist create a .envrc file containing 'use
nix' in the current directory."
  (interactive)
  (let ((envrc (expand-file-name ".envrc")))
    (if (file-exists-p envrc)
        (message "Envrc file already exists")
      (write-region "use nix" nil envrc))))

(defun my/project-vterm ()
  "Open a `vterm' session in the project root of the current
project.  Prompt if no project can be found."
  (interactive)
  (let ((default-directory (project-root (project-current t))))
    (vterm)))

(defun my/project-edit-dir-local-variable (mode variable value)
  "Edit directory-local variables in the root directory of the
current project."
  (interactive
   ;; Taken from `add-dir-local-variable', as I don't know of a better
   ;; way to simply wrap that command.
   (let (variable)
     (require 'files-x)
     (list
      (read-file-local-variable-mode)
      (setq variable (read-file-local-variable "Add or edit directory-local variable"))
      (read-file-local-variable-value variable))))
  (let ((default-directory (project-root (project-current t))))
    (modify-dir-local-variable mode variable value 'add-or-replace)))
#+end_src

Another thing I sometimes need is quickly navigate into my project
directory, so why not write something to open =dired= there and then add
this function to =project-prefix-map=?

#+begin_src emacs-lisp
(defun my/navigate-to-projects ()
  "Open a `dired' buffer in my personal project directory."
  (interactive)
  (dired "~/projects"))
#+end_src

One tricky thing was making it possible to bind the keymap
=project-prefix-map= to a key.  One needs to make it callable via =fset=.

#+begin_src emacs-lisp
(use-package project
  :config
  (fset 'project-prefix-map project-prefix-map)
  (setq project-switch-commands
        '((project-find-file "find file")
          (consult-ripgrep "search/grep" ?s)
          ((lambda ()
             (interactive)
             (magit-status (project-root (project-current t))))
           "git status"
           ?g)
          (project-dired "dired")
          (my/project-vterm "vterm" ?t)
          (project-switch-to-buffer "find buffer" ?b)
          (project-vc-dir "vc")))
  :bind (:map project-prefix-map
              ("t" . my/project-vterm)
              ("d" . project-dired)
              ("s" . consult-ripgrep)
              ("D" . my/project-edit-dir-local-variable)
              ("n" . my/navigate-to-projects)))
#+end_src

** Magit

Not much to say here: =magit= is awesome and in my top 3 reasons why I
can't ever switch to anything that doesn't have this.  I've tried
=vim-fugitive= and =neogit= for (neo)vim, and while they're great, I still
missed =magit=.  I'm in the process of getting used to the non-=evil=
keybindings (again); once that is finished, I might add some custom
bindings here.  =magit-status-here= is surely the one I use the most,
but I have a hunch it's not used nearly often enough to warrant a
custom key chord; I can just use =M-x=, where I don't have to enter
much due to =savehist-mode=.

#+begin_src emacs-lisp
(use-package magit
  :defer
  :config
  ;; No autosave for open buffers, as that might trigger hooks and
  ;; such.
  (setq magit-save-repository-buffers nil)
  (setq magit-diff-refine-hunk t)
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (setq magit-bury-buffer-function #'magit-restore-window-configuration)
  ;; I frequently pull with the autostash option, so add that to the
  ;; transient command list.
  (transient-append-suffix 'magit-pull "-r"
    '("-a" "Autostash" "--autostash")))
#+end_src

I used to have way more =magit= keybindings when I used =evil=, but as
mentioned above =M-x= seems like the way to go.  I was missing
=magit-status-here= a lot, though, so add it in an accessible spot.

#+begin_src emacs-lisp
(keymap-global-set "C-t g" 'magit-status-here)
#+end_src

*** Interactively browse =git= history

#+begin_src emacs-lisp
(use-package git-timemachine
  :defer)
#+end_src

*** Modes for other kinds of =git=-related files

It's useful to have a little bit of syntax highlighting in files like
=.gitignore= or =.gitattributes=.  The =git-modes= package provides just
that, and autoloads the specific modes for the respective file types.
Like its readme proposes it's also possible to reuse the
=gitignore-mode= for other things, in this case =.dockerignore= files.

#+begin_src emacs-lisp
(use-package git-modes
  :defer
  :init
  (add-to-list 'auto-mode-alist
               (cons "/.dockerignore\\'" 'gitignore-mode)))
#+end_src

** "Modal" Lisp editing with =lispy=

I've grown very fond of the way the [[https://github.com/abo-abo/lispy][lispy]] package works, especially
without =evil=.  The basic idea is that there are certain /special/
positions in Lisp code where it's *very* uncommon to insert any letter.
When point is in such a /special/ position -- most commonly on an
opening parenthesis or directly behind a closing parenthesis --
letters that you enter execute special Lisp editing commands: =>= slurps
s-expressions, =j= and =k= move down and up on the same level, =r= raises
and lots and lots more.  After getting used to it for a bit, it feels
/absolutely great/ and I continue to discover new bindings gradually.
There's also an awesome video by abo-abo, linked in the readme, where
they showcase many things =lispy= has to offer.

#+begin_src emacs-lisp
(use-package lispy
  :defer
  :config
  (setq lispy-colon-p nil)
  :hook
  ((emacs-lisp-mode
    lisp-mode
    clojure-mode
    clojurec-mode
    clojurescript-mode
    common-lisp-mode
    racket-mode
    racket-repl-mode
    sly-repl-mode
    slime-repl-mode)
   . lispy-mode))
#+end_src

** Display commands bound to keys in the minibuffer

When pressing the first key in a hotkey chain, show a popup that
displays the possible completions and associated functions.

#+begin_src emacs-lisp :tangle no
(use-package which-key
  :defer
  :custom
  (which-key-idle-delay 0.3)
  :init
  ;; See https://github.com/justbur/emacs-which-key/issues/306
  (if (daemonp)
      (add-hook 'server-after-make-frame-hook 'which-key-mode)
    (add-hook 'after-init-hook 'which-key-mode)))
#+end_src

** Annotate minibuffer completions

Annotate minibuffer completions, like showing the bound keys and
docstrings for commands in =M-x=, variable values in =C-h v=, file sizes
and permissions in =C-x C-f=, and much more.

#+begin_src emacs-lisp
(use-package marginalia
  :init
  (marginalia-mode)
  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode)
                           (selectrum-exhibit 'keep-selected))))
  :config
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle)))
#+end_src

** Make Emacs =direnv=-sensitive

Steve Purcell's [[https://github.com/purcell/envrc][envrc]] package is an alternative to [[https://github.com/wbolster/emacs-direnv][emacs-direnv]].  The
latter has a long-standing issue where it sometimes loads too late,
that is, /after/ packages like =lsp-mode= would need it.  =envrc= has worked
flawlessly so far.  Note: this should probably be one of the last
modes to load, as the hook function is then placed before the other
modes to ensure =direnv= integration is working as expected.

#+begin_src emacs-lisp
(use-package envrc
  :defer
  :init (envrc-global-mode))
#+end_src

** Fast grepping via =ripgrep=

I use [[https://github.com/BurntSushi/ripgrep][ripgrep]] on the command line a lot.  This package makes it
comfortably usable from within Emacs.

#+begin_src emacs-lisp
(use-package ripgrep
  :defer)
#+end_src

** Interactive window switching

#+begin_src emacs-lisp
(use-package ace-window
  :defer
  :init
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r))
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5))
#+end_src

** Global font scaling

The =default-text-scale= package (again by Steve Purcell) makes it a
breeze to "globally" scale text in Emacs.  That is, it won't only
increase the font size in the current buffer as the
=text-scale-increase= command does, but rather do it everywhere.

#+begin_src emacs-lisp
(use-package default-text-scale
  :defer
  :after hydra
  :config
  (setq default-text-scale-amount 15))
#+end_src

Now I like increasing/decreasing the font, for instance when
presenting or pair programming, untit it "fits".  Let's create a =hydra=
for this, so that I can press single keys until it quits -- either
after =q= or a timeout.

#+begin_src emacs-lisp
(defhydra hydra-global-zoom (:hint nil :timeout 3)
  "\n
  Globally adjust the font size.\n
  _g_: increase
  _l_: decrease\n
  "
  ("g" default-text-scale-increase)
  ("l" default-text-scale-decrease)
  ("r" (lambda ()
         (interactive)
         (setq default-text-scale--complement 0)
         (face-spec-set 'default `((t (:height ,my/default-font-height))))
         (set-face-attribute 'default nil
                             :height my/default-font-height))
   "reset" :color blue)
  ("s" (lambda (height)
         (interactive "nFont size: ")
         (set-face-attribute 'default nil
                             :height height))
   "set size" :color blue)
  ("q" nil "exit"))

(keymap-global-set "C-t z" 'hydra-global-zoom/body)
#+end_src

** Edit =grep= results over multiple buffers

#+begin_src emacs-lisp
(use-package wgrep
  :defer
  :custom
  ((wgrep-auto-save-buffer t)
   (wgrep-change-readonly-file nil)
   (wgrep-too-many-file-length 15)))
#+end_src

** Improve garbage collector behavior

#+begin_src emacs-lisp
(use-package gcmh
  :init
  (gcmh-mode 1))
#+end_src
