#+TITLE: Haskell configuration and utilities
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: showall
#+OPTIONS: toc:nil

* Insert language extensions and GHC options

This package contains A couple of Emacs Lisp functions that help me to
make quick changes to Haskell files (adding pragmas, language
extensions, GHC options).

#+begin_src emacs-lisp
(defun my/make-pragma (pragma content)
  "Create a pragma line of type `pragma' containing `content'."
  (concat "{-# " pragma " " content " #-}\n"))

(defun my/haskell-add-language-extension (ext-name)
  "Add an extension from the list of available language extensions
to the top of the file."
  (interactive
   (list
    (completing-read
     "Extension: "
     haskell-ghc-supported-extensions)))
  (let ((pragma (my/make-pragma "LANGUAGE" ext-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun my/haskell-add-ghc-option (opt-name)
  "Add a GHC option from the list of options to the top of the
file."
  (interactive
   (list
    (completing-read
     "GHC option: "
     haskell-ghc-supported-options)))
  (let ((pragma (my/make-pragma "OPTIONS_GHC" opt-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))
#+end_src

* Insert imports

This function is the one is use by far the most It makes it somewhat
easy to add =import= statements to Haskell files.  It's surely not
perfect, but fits my preferences well; that is, I almost never use the
combinations that are harder to add with this template.  For instance,
adding a qualified import with import list, or an unqualified one with
an alias, would require "tricks".

#+begin_src emacs-lisp
(defun my/read-non-empty-string (prompt)
  "Read a string from the minibuffer.  When the result is the empty
string, return nil instead."
  (let ((str (read-string prompt)))
    (unless (string-empty-p str)
      str)))

(defun my/haskell-add-import (module &optional qualified? alias)
  "Add an import to the import list.  Prompts for qualified import
and alias."
  (interactive
   (let* ((module (read-string "Module: "))
          (qualified?
           (unless (string-match-p "(" module)
             (y-or-n-p (concat "Import " module " qualified?"))))
          (alias (when qualified?
                   (my/read-non-empty-string "Alias [or leave empty]: "))))
     (list module qualified? alias)))
  (let ((import-line
         (concat "import "
                 (when qualified? "qualified ")
                 module
                 (when alias (concat " as " alias))
                 "\n")))
    (save-excursion
      (haskell-navigate-imports-go)
      (insert import-line))))
#+end_src

* Templates

While I'm using =TempEL= for templates in Emacs, some things are just a
tad bit too complex to handle in a template language, and much easier
to do in ELisp.  These go here.

** Newtypes

In Haskell, =newtype= is a mechanism I use all the time.  These are
different (but not all) scenarios that need to be possible to output
with a utility command:

#+begin_src haskell :tangle no
newtype Foo = Foo Int
newtype Foo a = Foo (IO a)
newtype Foo = Foo { unFoo :: Int } -- the default
newtype Foo = SomeCtor { unFoo :: Int }
newtype Foo = SomeCtor { custom :: Int }
newtype Foo a = SomeCtor { unFoo :: ReaderT Config IO a }
#+end_src

The following command /can/ handle all the cases above, albeit with a
drawback: the cases with a type parameter are harder to enter.  I will
try and add some logic to "calculate" that case from the =type= argument
later on.

#+begin_src emacs-lisp
(defun my/haskell-newtype-template (arg name type &optional ctor accessor)
  "Create a Haskell newtype declaration.  This will ask you for the
type NAME, the inner TYPE, and optionally for constructor and
accessor name.  If called with a non-nil prefix ARG then it won't
create and accessor and omit the curly braces."
  (interactive
   (let* ((name (my/read-non-empty-string "Name: "))
          (type (my/read-non-empty-string "Inner type: "))
          (ctor (or (my/read-non-empty-string
                     (concat "Constructor [default " name "]: "))
                    name))
          (accessor-def (concat "un" name))
          (accessor (unless current-prefix-arg
                      (or (my/read-non-empty-string
                           (concat "Accessor [default " accessor-def "]: "))
                          accessor-def))))
     (list current-prefix-arg name type ctor accessor)))
  (let ((content (concat "{ " accessor " :: " type " }")))
    (insert
     (concat "newtype " name " = " ctor " " content))))
#+end_src

* Navigating errors

As always, =hydra= is highly capable of simplifying all sorts of
navigational sets of commands.

#+begin_src emacs-lisp
(defhydra hydra-haskell-error-navigation (:hint nil)
  "\n
  [_f_]: first   [_n_]: next   [_p_]: previous"
  ("f" haskell-goto-first-error)
  ("n" haskell-goto-next-error)
  ("p" haskell-goto-prev-error))
#+end_src

* =Haskell-mode= configuration

Now load the actual =haskell-mode= package, and put some often-used
functions as well as some of the above utilities into a local keymap
for easy access.

#+begin_src emacs-lisp
(require 'use-package)
(use-package haskell-mode
  :defer
  :custom
  (haskell-process-type 'cabal-repl)
  (haskell-interactive-popup-errors nil)
  :hook
  (haskell-mode . interactive-haskell-mode)
  :bind
  (:map haskell-mode-map
        ("C-c e" . hydra-haskell-error-navigation/body)
        ("C-c i" . my/haskell-add-import)
        ("C-c p l" . my/haskell-add-language-extension)
        ("C-c p o" . my/haskell-add-ghc-option)
        ("C-c h k" . haskell-session-kill)
        ("C-c h r" . haskell-process-type)))

(provide 'my-haskell)
#+end_src
