#+TITLE: My Doom Emacs configuration
#+AUTHOR: Johannes Maier
#+EMAIL: johannes.maier@mailbox.org
#+STARTUP: showall

* Quickly jumping to this Doom Emacs configuration

I /very often/ jump into /this/ file to quickly tweak things. So let's make this
even more convenient than the default binding =SPC f P=.

#+begin_src emacs-lisp
(defun my/open-init-file ()
  "Open my config.org file."
  (interactive)
  (find-file (concat doom-user-dir "config.org")))

(map! :leader :desc "Open config" :n "e" #'my/open-init-file)
#+end_src

* Custom Emacs look

Load themes and other improvements over the default Emacs look.

One thing to pay attention to is that nearly all those operations on "visuals"
work slightly differently when starting Emacs as =emacsclient=, for instance via

#+begin_src shell :tangle no
emacsclient -a ''
#+end_src

Setting some things at this point often results in the changes not being applied
correctly. It's due to them happening in a technical, invisible Emacs frame. So
you'll often see =(daemonp)= being called, checking whether this instance of
Emacs is using the daemon, then adding some initializer function to
=server-after-make-frame-hook= if it is.

** Add an SVG splash screen image

An awesome source for ELisp bits and Doom/Emacs configuration is [[https://tecosaur.github.io/emacs-config/config.html][tecosaur's Doom
Emacs configuration]]. That's where I got the splash screen from and I love this
crisp Emacs =E=.

#+begin_src emacs-lisp
(setq fancy-splash-image (concat doom-private-dir "splash.svg"))
#+end_src

FIXME: add MIT license to dotfiles in order to use the splash screen

** Don't highlight the current line

Vanilla Emacs does not enable =hl-line-mode= (which always highlights the line
the point is currently on), but Doom does. I don't like it, so let's turn it off
again.

#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook #'global-hl-line-mode)
#+end_src

** Cursor

The default cursor is black, which interferes with mostly using a dark theme.
Brighten it up a bit.

#+begin_src emacs-lisp
(set-mouse-color "white")
(add-hook 'server-after-make-frame-hook
          (lambda () (set-mouse-color "white")))
#+end_src

Enable a forever-blinking cursor. I used to disable this mode but I found myself
searching for the cursor a couple of times lately.

#+begin_src emacs-lisp
(setq blink-cursor-delay 0.5)
(setq blink-cursor-blinks -1)
(blink-cursor-mode 1)
#+end_src

Don't show a cursor in inactive windows.

#+begin_src emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
#+end_src

** Fonts

An alist of my preferred font families, together with a plist of certain
attributes that need to be applied when switching to the respective font.

#+begin_src emacs-lisp
(setq my/font-alist
      '((pragmata-pro
         . (:family
            "Pragmata Pro Mono"))
        (ibm-vga-8x14
         . (:family
            "MxPlus IBM VGA 8x14"))
        (ibm-vga-9x16
         . (:family
            "MxPlus IBM VGA 9x16"))
        (dos-16
         . (:family
            "Mx437 DOS/V TWN16"))
        (iosevka
         . (:family
            "Iosevka Term"))
        (iosevka-slab
         . (:family
            "Iosevka Slab"))
        (iosevka-curly
         . (:family
            "Iosevka Curly"))
        (iosevka-curly-slab
         . (:family
            "Iosevka Curly Slab"))
        (dejavu
         . (:family
            "DejaVu Sans Mono"))
        (ibm-plex
         . (:family
            "IBM Plex Mono"))
        (cascadia
         . (:family
            "Cascadia Code"))
        (source-code-pro
         . (:family
            "Source Code Pro"))
        (consolas
         . (:family
            "Consolas"))
        (fira-code
         . (:family
            "Fira Code"))
        (jetbrains-mono
         . (:family
            "JetBrains Mono"))
        (julia-mono
         . (:family
            "JuliaMono"))
        (courier-prime
         . (:family
            "Courier Prime"))
        (sf-mono
         . (:family
            "SFMono"))
        (fantasque-sans-mono
         . (:family
            "Fantasque Sans Mono"))
        (lucida-console
         . (:family
            "Lucida Console"))
        (inconsolata
         . (:family
            "Inconsolata"))
        (borg
         . (:family
            "Borg Sans Mono"))
        (termingus
         . (:family
            "Termingus"))
        (unifont
         . (:family
            "Unifont"))
        (twilio-sans-mono
         . (:family
            "Twilio Sans Mono"))))
#+end_src

#+begin_src emacs-lisp
(setq my/current-font 'borg)
(setq my/default-font-size 20)
(setq doom-font (apply #'font-spec
                       (plist-put (alist-get my/current-font my/font-alist) :size my/default-font-size)))
#+end_src

The default text scaling increment produces jumps in font size that are way too
big for me. Let's tune it down a bit.

#+begin_src emacs-lisp
(setq doom-font-increment 1)
#+end_src

When streaming or just showing something to colleagues at work, there's no need
to manually zoom due to =doom-big-font-mode= now! I don't specify a different
font; =doom-big-font-increment= then controls how much the current font size is
increased.

#+begin_src emacs-lisp
(setq doom-big-font-increment 10)
#+end_src

The function I use to switch between the various fonts I like. It applies the
attributes of its value in =my/font-alist=.

#+begin_src emacs-lisp
(defun my/switch-font (font)
  "Apply the attributes stored for FONT in `my/font-alist'."
  (interactive
   (list
    (intern
     (completing-read
      "Font: "
      (mapcar #'car
              (assoc-delete-all my/current-font
                                (copy-alist my/font-alist)))))))
  (let* ((size (font-get doom-font :size))
         (attrs (plist-put (alist-get font my/font-alist) :size size)))
    (setq my/current-font font)
    (setq doom-font (apply #'font-spec attrs))
    (doom/reload-font)))
#+end_src

*** Changing the font size

#+begin_src emacs-lisp
(defun my/set-font-size (size)
  "Set the font size of the current font to a fixed value SIZE."
  (interactive "nSize: ")
  (doom-adjust-font-size size t))

(setq my/font-resize-map
      (define-keymap
        (kbd "g") #'doom/increase-font-size
        (kbd "l") #'doom/decrease-font-size
        (kbd "r") #'doom/reset-font-size
        (kbd "s") #'my/set-font-size))

(hercules-def
 :toggle-funs #'my/font-resize
 :keymap 'my/font-resize-map
 :transient t)

(map! :leader :desc "Font zoom" :g "z" #'my/font-resize)
#+end_src

** Color theme(s)

Since I cannot ever decide which theme I like best, there are a few themes, or
theme collections, loaded here.

**** Custom theme: =naga=

I usually use [[https://github.com/kenranunderscore/emacs-naga-theme][my own /naga/ theme]]. It can be found on MELPA nowadays, though
it's still only "finished" for the parts I really use. Should there be enough
interest, I could style some more parts, but it's not anything I plan on doing
for now.

This theme is loaded directly from GitHub via [[file:packages.el][packages.el]], but I have to see
whether this suffices for quick iteration. I don't know what the workflow is
going to look like yet.

FIXME: how to configure this now? some options don't seem to be respected, like
the red cursor

#+begin_src emacs-lisp
(use-package! naga-theme
  :defer
  :init
  (setq naga-theme-modeline-style 'green-box)
  (setq naga-theme-use-red-cursor t)
  (setq naga-theme-surround-org-blocks t)
  (setq naga-theme-use-lighter-org-block-background t))
#+end_src

**** Modus themes

[[https://protesilaos.com/emacs/modus-themes][This package]] by Protesilaos Stavrou is my first choice of "external" themes. I
find myself going back to =modus-vivendi= in the evening, even though I keep
saying that I don't like that high of a contrast.

These two themes are very customizable and come with the most comprehensive and
extensive documentation (same as with basically anything that Prot makes
available).

#+begin_src emacs-lisp
(use-package! modus-themes
  :defer
  :config
  (setq modus-themes-subtle-line-numbers t)
  (setq modus-themes-bold-constructs t)
  (setq modus-themes-italic-constructs nil)
  (setq modus-themes-syntax '(green-strings alt-syntax))
  (setq modus-themes-prompts '(background bold))
  (setq modus-themes-mode-line nil)
  (setq modus-themes-completions
        '((matches . (intense background))
          (selection . (intense accented))
          (popup . (intense accented))))
  (setq modus-themes-fringes nil)
  (setq modus-themes-paren-match '(bold intense))
  (setq modus-themes-region '(accented bg-only))
  ;; TODO: org agenda, mail citations
  (setq modus-themes-org-blocks nil))
#+end_src

**** Gruber darker

Whenever you want or need to channel your inner [[https://twitch.tv/tsoding][Tsoding]], switch to Iosevka and
turn on:

#+begin_src emacs-lisp
(use-package! gruber-darker-theme
  :defer)
#+end_src

**** Srcery

I discovered this package by accident, while randomly selecting themes to try
out via =straight-use-package=.

#+begin_src emacs-lisp
(use-package! srcery-theme
  :defer)
#+end_src

**** Default theme

Doom comes with the =doom-themes= package which contains lots of great themes
(even though in some themes I dislike the low contrast between the mode line and
buffers).  Let's use one of those for now until everything else is up and
running.  =Gruvbox= is always a good choice, anywhere.

#+begin_src emacs-lisp
(setq doom-theme 'doom-gruvbox)
#+end_src

** Mode line (TODO: port and conditionalize with =featurep!=)

* Basic options
** Use =SPC SPC= as an alias for =M-x=

Doom by default sets =SPC SPC= to =projective-find-file=, which I am used to
invoking via =SPC p f= (that's also bound by default).

I'd like to get used to just pressing =M-x= for extended commands, but =SPC SPC=
is ingrained in my muscle memory. Remapping it for when I "accidentally" press
it seems like a good idea.

#+begin_src emacs-lisp
(map! :leader :desc "M-x" :nmv "SPC" #'execute-extended-command)
#+end_src

** Mode-sensitive completion for extended commands

Make commands shown with M-x depend on the active major mode. Note: this doesn't
work correctly yet, as =(command-modes 'some-command)= seems to return the modes
in an unexpected format.

#+begin_src emacs-lisp
(setq read-extended-command-predicate
      #'command-completion-default-include-p)
#+end_src

** Line and column numbers

To display line numbers, the aptly named =display-line-numbers= package is used.
I prefer a hybrid mode for displaying line numbers. That is, line numbers are
shown in a relative way, but the current line displays its absolute line number.
In insert mode, line numbers should be disabled altogether. That's what these
two functions are used for.

#+begin_src emacs-lisp
(defun my/switch-to-absolute-line-numbers ()
  "Enable absolute line numbers."
  (interactive)
  (when (and (boundp 'display-line-numbers-mode) display-line-numbers-mode)
    (setq display-line-numbers t)))

(defun my/switch-to-hybrid-line-numbers ()
  "Enable relative line numbers, but with the current line
showing its absolute line number."
  (interactive)
  (when (and (boundp 'display-line-numbers-mode) display-line-numbers-mode)
    (setq display-line-numbers 'relative)
    (setq display-line-numbers-current-absolute t)))

(defun my/toggle-line-numbers ()
  "Toggle `display-line-numbers-mode'.  Meant to be used in a
keybinding."
  (interactive)
  (display-line-numbers-mode 'toggle))

(use-package! display-line-numbers
  :defer
  :hook ((evil-insert-state-entry . my/switch-to-absolute-line-numbers)
         (evil-insert-state-exit . my/switch-to-hybrid-line-numbers))
  :config
  (setq display-line-numbers-type 'relative)
  (setq display-line-numbers-current-absolute t)
  (map! :leader :desc "Line numbers" :nmv "t l" #'my/toggle-line-numbers))
#+end_src

** If I have to use tabs, at least make them smaller

Looking at you, [[https://go.dev/][Go]].

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

** File name searches should be case-insensitive

#+begin_src emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+end_src

** Yank (paste) at point with the mouse

The default Emacs behavior when yanking (in the Emacs sense of the word) things
from the clipboard by clicking the middle mouse button is to insert those at the
mouse cursor position.  I wish to be able to carelessly click anywhere and have
it insert at point, similar to how it's done in most terminal emulators.

Of course there's an existing Emacs options for this:

#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

** Breaking long lines

When writing prose I often use =auto-fill-mode= to automatically break long lines.
Emacs uses the =fill-column= variable to determine when to break.  Its default of
70 is a little low for my taste, though.

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

* Vim emulation with =evil=

The =evil= package offers a very complete Vim experience inside of Emacs. Most
of the configuration is done by Doom already, so I only need to slightly tweak
some things to my liking.

#+begin_src emacs-lisp
(after! evil
  ;; Use a special cursor for insert mode
  (setq evil-insert-state-cursor '(hbar . 5))
  ;; Don't make certain commands repeatable with '.'
  (mapc #'evil-declare-ignore-repeat
        '(haskell-process-load-file
          haskell-process-reload
          haskell-goto-first-error
          haskell-goto-next-error
          haskell-goto-prev-error
          hydra-haskell-error-navigation/body
          my/haskell-add-import
          my/haskell-add-ghc-option
          my/haskell-add-language-extension))
  (add-to-list 'evil-emacs-state-modes 'sieve-manage-mode)
  ;; U for `redo' is easier to type than C-r for me
  (map! :desc "Redo" :n "U" #'evil-redo
        :map evil-window-map
        :g "C-d" #'evil-window-delete))
#+end_src

* Window management
** Interactive window switching

The =ace-window= package comes with Doom's =window-select= module.  I need a
couple of customizations due to using the alternative keyboard layout MTGAP; I'm
also used to my =C-l= rebind to more comfortably switch than =C-w C-w=.

#+begin_src emacs-lisp
(use-package! ace-window
  :defer
  :init
  (map! :desc "Switch window" :inmve "C-l" #'ace-window)
  :config
  (set-face-attribute 'aw-leading-char-face nil :height 2.5)
  (setq aw-keys '(?i ?n ?e ?a ?h ?t ?s ?r)))
#+end_src

* Centering the screen after jumps

In neovim I used to remap lots of movement keybindings to execute =zz= after, so
that the result of the jump would be centered in the target window. I'll try and
reproduce that in Emacs.

#+begin_src emacs-lisp
(add-hook 'imenu-after-jump-hook #'recenter)
(add-hook 'evil-jumps-post-jump-hook #'recenter)
(add-hook 'better-jumper-post-jump-hook #'recenter)

(defun my/recenter-advice (&rest _) (recenter nil))
(advice-add 'evil-ex-search-next :after #'my/recenter-advice)
(advice-add 'evil-ex-search-previous :after #'my/recenter-advice)
(advice-add 'evil-scroll-up :after #'my/recenter-advice)
(advice-add 'evil-scroll-down :after #'my/recenter-advice)
(advice-add '+lookup/definition :after #'my/recenter-advice)
#+end_src

* Built-in packages with extensions
** Emacs Lisp
*** Evaluating with =C-c C-c=

I like evaluating the top-level form I'm currently on by pressing =C-c C-c=,
similar to how one compiles in SLY/SLIME.

FIXME: this destroys the nice bindings in =org-src= buffers.  fix possible?

#+begin_src emacs-lisp :tangle no
(map! :map emacs-lisp-mode-map
      :desc "Eval defun" :g "C-c C-c" #'eval-defun)
#+end_src

*** Don't trim ELisp evaluation results

#+begin_src emacs-lisp
(setq eval-expression-print-length nil)
(setq eval-expression-print-level nil)
#+end_src

** Display whitespace

Make whitespace symbols visible using =whitespace-mode=. I don't use this often
anymore, but sometimes it's helpful.

#+begin_src emacs-lisp
(use-package! whitespace
  :defer
  :config
  (setq whitespace-line-column 100)
  (setq whitespace-global-modes
        '(not magit-status-mode
              org-mode))
  (setq whitespace-style
        '(face newline newline-mark missing-newline-at-eof
               trailing empty tabs tab-mark))
  (setq whitespace-display-mappings
        '((newline-mark 10
                        [9166 10])
          (tab-mark 9
                    [187 9]
                    [92 9]))))
#+end_src

** Render manpages in Emacs

#+begin_src emacs-lisp
(after! man
  ;; As soon as it is ready open the manpage in a separate, focused window.
  (setq Man-notify-method 'aggressive))
#+end_src

** Directory editor: =dired=

#+begin_src emacs-lisp
(after! dired
  (setq dired-kill-when-opening-new-dired-buffer t))
#+end_src

** Ediff

=Ediff= is a great way to diff and/or merge files or buffers. By default it
creates a new frame containing a "control buffer" used to navigate the diff and
manipulate the output. Unfortunately for the longest time this behaved weirdly
for me: whenever I'd tab to the frame containing the diff, do something, then
tab back, the next navigational command from the control frame would work but
drop me back in the diff frame. It's possible to use =ediff-setup-windows-plain=
as setup function, which makes =ediff= single-frame, circumventing the problem.

#+begin_src emacs-lisp
(after! ediff-wind
  (setq ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

** Disabling =smartparens=

I don't use or need =smartparens=. If I want auto-closing parentheses then
=electric-pair-mode= is great, and for LISPy languages there's =lispy-mode= and
=lispyville-mode=.

#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook #'smartparens-global-mode)
#+end_src

** Correct typos while typing with =abbrev=

=Abbrev-mode= is a nice built-in minor mode that silently replaces some things I
type with other things. It is mostly used for correcting typos, though I haven't
really "trained" my self-made list of abbrevs -- I've just started using it.

Since it doesn't come with a global mode itself, I use =setq-default= to enable
it everywhere.

#+begin_src emacs-lisp
(use-package! emacs
  :init
  (setq-default abbrev-mode t)
  :config
  (setq save-abbrevs nil
        abbrev-file-name (locate-user-emacs-file "abbrev_defs")))
#+end_src

* Incremental narrowing etc.
** =Vertico=

Doom does it well out of the box. I should probably look into configuring
=embark= here later on, maybe to even obsolete =which-key=.

*** =Consult=

The [[https://github.com/minad/consult][consult]] package is the analogue of =counsel=, which I used for quite some
time, though not in any extent close to full. This only defines some basic
bindings that Doom doesn't use by default.

#+begin_src emacs-lisp
(map! :g "M-g o" #'consult-outline)
#+end_src

*** =Embark=

I haven't really grokked [[https://github.com/oantolin/embark][Embark]] yet. It seems to be amazing, though! What I
mostly use it for at the moment is its =embark-act= command in conjunction with
=embark-export=. With this I often push the results of some =grep=-like command
into a separate buffer, where I can then utilize =wgrep= to bulk-modify the
original buffers.

* TODO Jumping around with =avy=
* TODO Org mode
** Tweaks to the default configuration

When writing text with =org=, =auto-fill-mode= should be enabled to
automatically break overly long lines into smaller pieces when typing. One may
still use =M-q= to re-fill paragraphs when editing text. After loading =org=, a
custom font setup might run to adjust the headers.

#+begin_src emacs-lisp
(use-package! org
  :hook
  ((org-mode . auto-fill-mode))
  :custom
  ((org-directory "~/org")
   (org-startup-indented t)
   (org-log-done t)
   (org-edit-src-content-indentation 0)
   (org-agenda-files '("~/org/inbox.org"))
   (org-html-htmlize-output-type 'css))
  :config
  (setq-default org-hide-emphasis-markers t)
  (advice-add 'org-refile
              :after (lambda (&rest _) (org-save-all-org-buffers))))
#+end_src

** Giving org a more modern look&feel

Minad's [[https://github.com/minad/org-modern][org-modern package]] looks very promising, so let's try it out.

#+begin_src emacs-lisp
(use-package! org-modern
  :hook
  (org-mode . org-modern-mode)
  :config
  (setq org-modern-star '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-modern-block-name '((t . t)
                                ("src" "»" "«")
                                ("example" "»–" "–«")
                                ("quote" "❝" "❞")
                                ("export" "⏩" "⏪"))))
#+end_src

** Show emphasis markers depending on point

In my =org= configuration I'm setting =org-hide-emphasis-markers= to =t=, thus
hiding certain markup elements around text. Unfortunately it seem to be
currently impossible to switch this interactively, or I just don't know how,
which prevents me from simply adding a keybinding to toggle it.

Thankfully a new package has appeared recently: [[https://github.com/awth13/org-appear][org-appear]]. It reacts to the
position of point to automatically show surrounding markup.

#+begin_src emacs-lisp
(use-package! org-appear
  :defer
  :hook ((org-mode . org-appear-mode))
  :config
  (setq org-appear-autolinks t
        org-appear-autosubmarkers t
        org-appear-autoentities t
        org-appear-autokeywords t
        org-appear-trigger 'always))
#+end_src

* On-the-fly syntax checking (and other things): =Flymake=

#+begin_src emacs-lisp
(after! flymake
  ;; HACK: This variable is needed for helpful or haskell-mode to start up for
  ;; some reason
  (setq flymake-allowed-file-name-masks nil))

(add-hook! sh-mode #'flymake-mode)
#+end_src

** Static analysis of shell scripts

[[https://github.com/koalaman/shellcheck][ShellCheck]] is a great little program providing feedback when writing shell
scripts.  The Emacs package [[https://github.com/federicotdn/flymake-shellcheck][flymake-shellcheck]] integrates ShellCheck with
Flymake.  We have to trigger =flymake-shellcheck-load= when loading shell scripts,
and also enable Flymake itself, both done via hooks to =sh-mode=.

#+begin_src emacs-lisp :tangle no
(use-package! flymake-shellcheck
  :commands (flymake-shellcheck-load)
  :hook ((sh-mode . flymake-shellcheck-load)
         (sh-mode . flymake-mode)))
#+end_src

* E-mail configuration

There are several different ways to "do e-mail in Emacs". Over the last two
years I've tried out =notmuch=, =gnus=, and =mu4e=. Some thoughts on each of
those:

** Mu for Emacs (=mu4e=)

[[https://www.djcbsoftware.nl/code/mu/][Mu]] is what I was using for the longest period of time, with =mu4e= being its
Emacs frontend. It's not as customizable as =notmuch=, but part of its charm is
that I don't need to sync anything between my machines, at the cost of =mu=
touching my e-mail (adding custom headers I believe). I don't mind this at all,
and I can use =isync= and =msmtp= to receive and send mail on any host.

For writing e-mails =mu4e= uses =message-mode= like the other tools. This checks
the =user-full-name= variable to fill in my name.

#+begin_src emacs-lisp
(setq user-full-name "Johannes Maier")
#+end_src

Usually there's one /context/ (see =mu4e-contexts=) for each of my e-mail
addresses, and switching between them I may set some context-specific variables,
or even change the =mu4e= UI accordingly. The Doom Emacs =mu4e= module hides
this variable behind a nicer interface. I don't yet know whether everything
still works as intended, but let's give it a try.

#+begin_src emacs-lisp
(after! mu4e
  (setq message-send-mail-function #'message-send-mail-with-sendmail
        message-kill-buffer-on-exit t
        send-mail-function #'message-send-mail-with-sendmail
        message-sendmail-envelope-from 'header
        mail-envelope-from 'header
        mail-specify-envelope-from 'header
        +mu4e-backend 'mbsync
        mu4e-drafts-folder "/drafts"
        mu4e-completing-read-function #'completing-read
        mu4e-confirm-quit nil
        mu4e-change-filenames-when-moving t
        mu4e-attachment-dir "~/Downloads/"
        mu4e-context-policy 'pick-first
        mu4e-compose-context-policy 'ask
        mu4e-headers-results-limit -1
        mu4e-search-results-limit -1
        mu4e-search-skip-duplicates nil
        mu4e-headers-skip-duplicates nil
        mu4e-headers-fields '((:human-date . 12)
                              (:flags . 6)
                              (:maildir . 15)
                              (:mailing-list . 10)
                              (:from . 22)
                              (:subject))
        mu4e-bookmarks '((:name "AG inbox" :query "maildir:/ag/Inbox" :key ?a)
                         (:name "Mailbox inbox" :query "maildir:/mailbox/Inbox" :key ?m)
                         (:name "Unread messages" :query "flag:unread AND NOT flag:trashed" :key ?u)
                         (:name "Sent" :query "maildir:/ag/Sent OR maildir:/mailbox/Sent" :key ?s)))
  (set-email-account!
   "mailbox"
   '((user-mail-address . "johannes.maier@mailbox.org")
     (mu4e-sent-folder . "/mailbox/Sent")
     (mu4e-trash-folder . "/mailbox/Trash")
     (mu4e-compose-signature . nil)
     (mu4e-refile-folder . (lambda (msg)
                             (let* ((date (mu4e-message-field-at-point :date))
                                    (year (decoded-time-year (decode-time date))))
                               (concat "/mailbox/Archive/"
                                       (number-to-string year))))))
   t)
  (set-email-account!
   "ag"
   `((user-mail-address . "johannes.maier@active-group.de")
     (mu4e-sent-folder . "/ag/Sent")
     (mu4e-trash-folder . "/ag/Trash")
     (mu4e-compose-signature . ,(concat
                                 "Johannes Maier\n"
                                 "johannes.maier@active-group.de\n\n"
                                 "+49 (7071) 70896-67\n\n"
                                 "Active Group GmbH\n"
                                 "Hechinger Str. 12/1\n"
                                 "72072 Tübingen\n"
                                 "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
                                 "Geschäftsführer: Dr. Michael Sperber"))
     (mu4e-refile-folder . (lambda (msg)
                             (let* ((date (mu4e-message-field-at-point :date))
                                    (year (decoded-time-year (decode-time date))))
                               (concat "/ag/Archives/"
                                       (number-to-string year))))))
   t))
#+end_src

I also want to use a slightly wider =fill-column= in e-mails.

#+begin_src emacs-lisp
(setq-hook! mml-mode fill-column 80)
#+end_src

=Mu4e= buffers are recognized as popups by Doom, so the initial buffer opens up
very small at the bottom of the frame; subsequent buffers do the same. Now that
it's easier to handle popup, I'm not entirely certain what kind of behavior I'd
like to have, but let's try some things out:

#+begin_src emacs-lisp
(set-popup-rule! "^\\*mu4e"
  :ignore t)
#+end_src

*** Warn/confirm when trying to send with empty subject

=mu4e= uses the built-in =message-mode= for composing mail. In order to receive
a warning or yes/no question whenever I try sending without having specified a
subject header, I have to hook into this.

#+begin_src emacs-lisp
(defun my/confirm-empty-mail-subject ()
  "Check whether the subject header of the current message is empty,
and abort in this case (https://emacs.stackexchange.com/a/41176)."
  (or (message-field-value "Subject")
      (y-or-n-p "Really send without subject? ")
      (keyboard-quit)))

(add-hook 'message-send-mail-hook #'my/confirm-empty-mail-subject)
#+end_src

** Notmuch

The Emacs integration for =notmuch= is great; it has the most intuitive and
appealing UI from each of the options.  =Notmuch= works by referencing incoming
e-mail in a separate database only, not ever touching or modifying it.  I really
like this idea, and in practice it also felt great due to the quick und
customizable searches.  The usual approach is to use a tag-based system of
categorizing your e-mail, but simply having lots of stored queries is a little
bit more flexible.

But =notmuch= only handles this single aspect; this means that one needs to find
solutions to the following:

- Getting mail
- Initial tagging
- Sending mail
- Synchronization between machines

Due to the declarative e-mail account configuration from =home-manager= the first
part is very simple, and I could also easily switch between different tools like
=isync= or =offlineimap=.

The initial tagging can be done with a shell script using the well-documented
=notmuch= CLI, or via =afew=.

For sending mail I use =msmtp=.

I'm using =muchsync= on my personal server to be the "source of truth".  This
means that only the server downloads e-mail via IMAP, and the machines are
simply its /clients/; they use =muchsync= to download mail from the server.

This sounds great on paper but is a little finicky with sent mail, which I'd
also like to sync back via IMAP to my accounts.  The client machine sends this
and puts it into respective =sent= directories; =muchsync= synchronizes these
directories as well, but I've had problems with mails appearing twice, or
appearing not at all on the respective "other" machine, at least in the past.
It looks or feels like my usage of =muchsync --nonew= on the clients was a
potential problem: I've verified that after sending a mail and it having landed
in the correct =sent= directory, a simple =muchsync my-server= didn't lead to the
mail appearing on my servers.  It worked after executing =notmuch new= once,
though, so I guess =muchsync= only synchronizes those mails that are part of the
current =notmuch= database state.

One solution would be to make sure that whenever I'm polling from within Emacs,
both =muchsync my-server= and =notmuch new= are executed.  Since =notmuch= has
deprecated the =notmuch-poll-script= variable in their Emacs client, I have to use
the hooks it provides to make sure =muchsync= is executed.  Putting =muchsync
--nonew= into the =preNew= hook while having an unsynchronized sent mail on the
client sounds correct on paper in order to not execute =notmuch new= twice, but it
means that in the case of an unsynchronized sent mail, this mail won't have been
pushed to the server after the first call, if I am correct.  So I'll have to
experiment and probably live with =notmuch new= being called twice (which is fine
as it's blazingly fast).

Let's first define some utility functions that I'll then bind to special keys
later.

#+begin_src emacs-lisp :tangle no
(defun my/notmuch-search-toggle-unread ()
  "Toggle unread tag at point in `notmuch-search-mode'."
  (interactive)
  (if (member "unread" (notmuch-search-get-tags))
      (notmuch-search-tag '("-unread"))
    (notmuch-search-tag '("+unread")))
  (notmuch-search-next-thread))

(defun my/notmuch-search-toggle-deleted ()
  "Toggle deleted tag at point in `notmuch-search-mode'."
  (interactive)
  (if (member "deleted" (notmuch-search-get-tags))
      (notmuch-search-tag '("-deleted"))
    (notmuch-search-tag '("+deleted")))
  (notmuch-search-next-thread))

(defun my/notmuch-show-toggle-deleted ()
  "Toggle deleted tag at point in `notmuch-show-mode'."
  (interactive)
  (if (member "deleted" (notmuch-show-get-tags))
      (notmuch-show-tag '("-deleted"))
    (notmuch-show-tag '("+deleted")))
  (notmuch-show-next-thread t))
#+end_src

Now pull in and configure the actual =notmuch= package.  Note that same options
here rather belong to built-in functionality, but they fit in here very well.

#+begin_src emacs-lisp :tangle no
(use-package! notmuch
  :defer
  :disabled
  :init
  (setq user-mail-address "johannes.maier@mailbox.org")
  :custom
  ;; msmtp is registered as sendmail
  (message-send-mail-function 'message-send-mail-with-sendmail)
  (message-kill-buffer-on-exit t)
  ;; When replying to mail, choose the account to use
  ;; based on the recipient address
  (message-sendmail-envelope-from 'header)
  (mail-envelope-from 'header)
  (mail-user-agent 'message-user-agent)
  ;; Settings for notmuch itself
  (notmuch-show-all-multipart/alternative-parts nil)
  (notmuch-hello-sections
   '(notmuch-hello-insert-header
     notmuch-hello-insert-saved-searches
     notmuch-hello-insert-footer))
  (notmuch-always-prompt-for-sender t)
  (notmuch-search-oldest-first nil)
  (notmuch-maildir-use-notmuch-insert t)
  (notmuch-archive-tags '("-inbox" "-unread"))
  (notmuch-message-replied-tags '("+replied" "+sent"))
  (notmuch-fcc-dirs
   '(("johannes.maier@mailbox.org" . "mailbox/Sent -inbox -unread +sent +private")
     ("johannes.maier@active-group.de" . "ag/Sent -inbox -unread +sent +work")
     (".*" . "sent")))
  (notmuch-saved-searches
   '((:name "inbox" :query "tag:inbox" :key "i")
     (:name "sent" :query "tag:sent" :key "s")
     (:name "work" :query "tag:inbox and tag:work" :key "w")
     (:name "private" :query "tag:inbox and tag:private" :key "p")
     (:name "all mail" :query "*" :key "a")))
  :bind
  (:map notmuch-show-mode-map
        ("d" . my/notmuch-show-toggle-deleted)
        :map notmuch-search-mode-map
        ("d" . my/notmuch-search-toggle-deleted)
        ("u" . my/notmuch-search-toggle-unread)))
#+end_src

=Gnus-alias= makes it possible to use different identities when composing mail.  I
mostly use it to make sure that replies to a mail are sent from the address I've
received it at.

#+begin_src emacs-lisp
(use-package gnus-alias
  :defer t
  :config
  (setq gnus-alias-identity-alist
        `(("mailbox"
           nil
           "Johannes Maier <johannes.maier@mailbox.org>"
           nil
           nil
           nil
           nil)
          ("ag"
           nil
           "Johannes Maier <johannes.maier@active-group.de>"
           "Active Group GmbH"
           nil
           nil
           ,(concat
             "Johannes Maier\n"
             "johannes.maier@active-group.de\n\n"
             "+49 (7071) 70896-67\n\n"
             "Active Group GmbH\n"
             "Hechinger Str. 12/1\n"
             "72072 Tübingen\n"
             "Registergericht: Amtsgericht Stuttgart, HRB 224404\n"
             "Geschäftsführer: Dr. Michael Sperber"))))
  (setq gnus-alias-default-identity "mailbox")
  (setq gnus-alias-identity-rules
        '(("ag" ("any" "@active-group.de" both) "ag")))
  :hook
  (message-setup . gnus-alias-determine-identity))
#+end_src

** Gnus

As I've written before, I've never given the mighty =gnus= the trial it deserves.
Getting into this package is really quite scary, for lack of a better word.  The
reason is that =gnus= defines abstractions over "news", where the word nowadays
can incorporate everything from feeds, reddit, usenet, email, etc.  The result
is that one has to learn lots of specialized and often confusing terminology
before being able to use =gnus= (especially for email).  Due to the length and
comprehensiveness of the manual the learning curve is quite steep.

Plus, I feel like you cannot "just start using =gnus=" and get used to it, whereas
that is an actual path to succees in something like =mu4e=, for instance.  With
=gnus= there's a lot of configuration to be done before even being able to do
anything.

I'm not sure yet what I will have to sync between machines; the automatically
created =.newsrc.eld= file is the most likely candidate.  It seems like that the
path to this file can (only?) be configured by setting the path to the /startup
file/, meaning the newsreader-agnostic =.newsrc= file -- that I'm not actually
using, as I will only be using =gnus=.

#+begin_src emacs-lisp :tangle no
(use-package! gnus
  :disabled
  :init
  (setq gnus-directory "~/.gnus/")
  (setq gnus-home-directory "~/.gnus/")
  (setq gnus-startup-file "~/org/newsrc")
  (setq gnus-init-file (locate-user-emacs-file "gnus.el"))
  :config
  (setq user-full-name "Johannes Maier")
  (setq user-mail-address "johannes.maier@mailbox.org")
  (setq message-directory "~/.gnus")
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq send-mail-function 'message-send-mail-with-sendmail)
  (setq message-sendmail-envelope-from 'header)
  (setq mail-envelope-from 'header)
  (setq mail-specify-envelope-from 'header)
  (setq gnus-check-new-newsgroups t)
  (setq gnus-gcc-mark-as-read t)
  (setq nnml-directory "~/.gnus")
  (setq gnus-interactive-exit t)
  (setq gnus-asynchronous t)
  (setq gnus-use-article-prefetch 15)
  (setq gnus-select-method '(nnnil ""))
  (setq gnus-secondary-select-methods
        '((nntp "news.gwene.org")
          (nnimap "ag"
                  (nnimap-address "imap.active-group.de")
                  (nnimap-server-port 993)
                  (nnimap-stream ssl)
                  (nnimap-inbox "INBOX"))
          (nnimap "mailbox"
                  (nnimap-address "imap.mailbox.org")
                  (nnimap-server-port 993)
                  (nnimap-stream ssl)
                  (nnimap-inbox "INBOX")))))
#+end_src

* TODO IRC with =erc=
* TODO Project management
* =Magit=

Not much to say here: =magit= is awesome and in my top 3 reasons why I can't
ever switch to any editor that doesn't have anything remotely comparable. I've
tried =vim-fugitive= and =neogit= for (neo)vim, and while they're great, I still
missed =magit=.

Once again, the default Doom configuration already does most of what I
previously did (and more), like:

- Setting a smaller =fill-column= for commit messages
- Opening commit message buffers in insert mode
- Adding a transient =autostash= flag
- Making windows/popups behave etc.

#+begin_src emacs-lisp
(after! magit
  (map! :leader
        :desc "Magit status here" :nvm "g g" #'magit-status-here
        :desc "Magit status" :nvm "g G" #'magit-status))
#+end_src

** Interactively browse =git= history

The =git-timemachine= plugin lets me go back and forth in a file's history.

#+begin_src emacs-lisp
(map! :leader
      :desc "Git timemachine" :nvm "g t" #'git-timemachine)
#+end_src

* TODO Modal LISP editing with =lispy= and =lispyville=
* Discovering keybindings with =which-key=

When pressing the first key in a hotkey chain, =which-key= displays a popup
showing the possible completions and associated functions. I stopped using this
for my custom Emacs configuration as I had gotten used to all my own
keybindings. With Doom that's a different story, and discovery has become
important once again, because why not leech off of someone else's keybinding
work :)

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.2)
#+end_src

** TODO check out =embark-prefix-help-command=
* Programming languages
** Haskell
*** Insert language extensions and GHC options

A couple of Emacs Lisp functions that help me make quick changes to Haskell
files (adding pragmas, language extensions, GHC options). =Haskell-mode= has some
similar functionality built-in, but I've never been happy with it.

#+begin_src emacs-lisp
(defun my/make-pragma (pragma content)
  "Create a pragma line of type `pragma' containing `content'."
  (concat "{-# " pragma " " content " #-}\n"))

(defun my/haskell-add-language-extension (ext-name)
  "Add an extension from the list of available language extensions
to the top of the file."
  (interactive
   (list
    (completing-read
     "Extension: "
     haskell-ghc-supported-extensions)))
  (let ((pragma (my/make-pragma "LANGUAGE" ext-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))

(defun my/haskell-add-ghc-option (opt-name)
  "Add a GHC option from the list of options to the top of the
file."
  (interactive
   (list
    (completing-read
     "GHC option: "
     haskell-ghc-supported-options)))
  (let ((pragma (my/make-pragma "OPTIONS_GHC" opt-name)))
    (save-excursion
      (goto-char (point-min))
      (insert pragma))))
#+end_src

*** Insert imports

This function is the one is use by far the most. It makes it somewhat easy to
add =import= statements to Haskell files. It's surely not perfect, but fits my
preferences well; that is, I almost never use the combinations that are harder
to add with this template. For instance, adding a qualified import with import
list, or an unqualified one with an alias, would require "tricks".

#+begin_src emacs-lisp
(defun my/read-non-empty-string (prompt &optional initial-input)
  "Read a string from the minibuffer.  When the result is the empty
string, return nil instead."
  (let ((str (read-string prompt initial-input)))
    (unless (string-empty-p str)
      str)))

(defun my/haskell-add-import (arg module &optional qualified? alias)
  "Add an import to the import list.  When no prefix ARG is set, the
user will be prompted whether the import should be qualified, and
what the identifier should be in that case."
  (interactive
   (let* ((arg current-prefix-arg)
          (module (read-string "Module: "))
          (qualified?
           (unless (or arg (string-match-p "(" module))
             (y-or-n-p (concat "Import " module " qualified?"))))
          (default-alias
           (last (split-string module "[\.]" t)))
          (alias (when qualified?
                   (my/read-non-empty-string "Alias: " default-alias))))
     (list arg module qualified? alias)))
  (let ((import-line
         (concat "import "
                 module
                 (when qualified? " qualified")
                 (when (and alias
                            (not (string= alias module)))
                   (concat " as " alias))
                 "\n")))
    (save-excursion
      (haskell-navigate-imports-go)
      (insert import-line))))
#+end_src

*** Formatting

Several formatters are in use in different Haskell projects, like =fourmolu=,
=ormolu=, =brittany= and several more. =Haskell-mode= comes with builtin integration
for =stylish-haskell=, which often works for other formatters but is sometimes a
little flaky. =Reformatter= is a better solution, as I can define modes for
different formatters here and then use =eval= in =.dir-locals.el= on a per-project
basis to enable the fitting mode there.

**** Fourmolu

#+begin_src emacs-lisp
(reformatter-define my/fourmolu-format
  :program "fourmolu"
  :args (list "--stdin-input-file" (or (buffer-file-name) input-file))
  :lighter " my/fourmolu")
#+end_src

**** Cabal files

#+begin_src emacs-lisp
(reformatter-define my/cabal-fmt-format
  :program "cabal-fmt"
  :args (list "-i" input-file)
  :stdin nil
  :stdout nil
  :lighter " my/cabal-fmt")

(map! :map haskell-cabal-mode-map
      :localleader
      :desc "Format" :n "f" #'my/cabal-fmt-format-buffer)
#+end_src

*** Configuration of =haskell-mode=

Now load the actual =haskell-mode= package, and put some often-used functions as
well as some of the above utilities into a local keymap for easy access.

#+begin_src emacs-lisp
(add-hook! haskell-mode #'interactive-haskell-mode)

(after! haskell-mode
  (setq haskell-process-type 'cabal-repl
        haskell-interactive-popup-errors nil
        haskell-process-args-cabal-repl '("--repl-options=-ferror-spans")))

(map! :map haskell-mode-map
      :prefix ("C-c p" . "pragmas")
      :desc "Enable language extension" :n "l" #'my/haskell-add-language-extension
      :desc "Set GHC option" :n "o" #'my/haskell-add-ghc-option
      :prefix "C-c"
      :desc "Add import" :n "i" #'my/haskell-add-import
      :localleader
      :desc "Kill session" :n "k" #'haskell-session-kill
      :desc "Format with fourmolu" :n "f" #'my/fourmolu-format-buffer)
#+end_src
